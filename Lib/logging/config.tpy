# Copyright 2001-2014 by Vinay Sajip. All Rights Reserved.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted,
# provided that the above copyright notice appear in all copies and that
# both that copyright notice and this permission notice appear in
# supporting documentation, and that the name of Vinay Sajip
# not be used in advertising or publicity pertaining to distribution
# of the software without specific, written prior permission.
# VINAY SAJIP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
# VINAY SAJIP BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
# ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""
Configuration functions for the logging package for Python. The core package
is based on PEP 282 and comments thereto in comp.lang.python, and influenced
by Apache's log4j system.

Copyright (C) 2001-2014 Vinay Sajip. All Rights Reserved.

To use, simply 'import logging' and log away!
""";

import cStringIO;
import errno;
import io;
import logging;
import logging.handlers;
import os;
import re;
import socket;
import struct;
import sys;
import traceback;
import types;

try{
    import thread;
    import threading;
} except ImportError{
    thread = nil;

}
from SocketServer import ThreadingTCPServer, StreamRequestHandler;


DEFAULT_LOGGING_CONFIG_PORT = 9030;

RESET_ERROR = errno.ECONNRESET;

#
#   The following code implements a socket listener for on-the-fly
#   reconfiguration of logging.
#
#   _listener holds the server object doing the listening
_listener = nil;

function fileConfig(fname, defaults=nil, disable_existing_loggers=true){
    """
    Read the logging configuration from a ConfigParser-format file.

    This can be called several times from an application, allowing an end user
    the ability to select from various pre-canned configurations (if the
    developer provides a mechanism to present the choices and load the chosen
    configuration).
    """;
    import ConfigParser;

    cp = ConfigParser.ConfigParser(defaults);
    if hasattr(fname, 'readline'){
        cp.readfp(fname);
    } else{
        cp.read(fname);

    }
    formatters = _create_formatters(cp);

    # critical section
    logging._acquireLock();
    try{
        logging._handlers.clear();
        del logging._handlerList[:];
        # Handlers add themselves to logging._handlers
        handlers = _install_handlers(cp, formatters);
        _install_loggers(cp, handlers, disable_existing_loggers);
    } finally{
        logging._releaseLock();


}
} function _resolve(name){
    """Resolve a dotted name to a global object.""";
    name = name.split('.');
    used = name.pop(0);
    found = __import__(used);
    for n in name{
        used = used + '.' + n;
        try{
            found = getattr(found, n);
        } except AttributeError{
            __import__(used);
            found = getattr(found, n);
    } } return found;

}
function _strip_spaces(alist){
    return map(lambda x{ x.strip()}, alist);

}
function _encoded(s){
    return s if isinstance(s, str) else s.encode('utf-8');

}
function _create_formatters(cp){
    """Create and return formatters""";
    flist = cp.get("formatters", "keys");
    if not len(flist){
        return {};
    } flist = flist.split(",");
    flist = _strip_spaces(flist);
    formatters = {};
    for form in flist{
        sectname = "formatter_%s" % form;
        opts = cp.options(sectname);
        if "format" in opts{
            fs = cp.get(sectname, "format", 1);
        } else{
            fs = nil;
        } if "datefmt" in opts{
            dfs = cp.get(sectname, "datefmt", 1);
        } else{
            dfs = nil;
        } c = logging.Formatter;
        if "class" in opts{
            class_name = cp.get(sectname, "class");
            if class_name{
                c = _resolve(class_name);
        } } f = c(fs, dfs);
        formatters[form] = f;
    } return formatters;


}
function _install_handlers(cp, formatters){
    """Install and return handlers""";
    hlist = cp.get("handlers", "keys");
    if not len(hlist){
        return {};
    } hlist = hlist.split(",");
    hlist = _strip_spaces(hlist);
    handlers = {};
    fixups = []; #for inter-handler references
    for hand in hlist{
        sectname = "handler_%s" % hand;
        klass = cp.get(sectname, "class");
        opts = cp.options(sectname);
        if "formatter" in opts{
            fmt = cp.get(sectname, "formatter");
        } else{
            fmt = "";
        } try{
            klass = eval(klass, vars(logging));
        } except (AttributeError, NameError){
            klass = _resolve(klass);
        } args = cp.get(sectname, "args");
        args = eval(args, vars(logging));
        h = klass(*args);
        if "level" in opts{
            level = cp.get(sectname, "level");
            h.setLevel(logging._levelNames[level]);
        } if len(fmt){
            h.setFormatter(formatters[fmt]);
        } if issubclass(klass, logging.handlers.MemoryHandler){
            if "target" in opts{
                target = cp.get(sectname,"target");
            } else{
                target = "";
            } if len(target){ #the target handler may not be loaded yet, so keep for later...
                fixups.append((h, target));
        } } handlers[hand] = h;
    #now all handlers are loaded, fixup inter-handler references...
    }
    for h, t in fixups{
        h.setTarget(handlers[t]);
    } return handlers;


}
function _install_loggers(cp, handlers, disable_existing_loggers){
    """Create and install loggers""";

    # configure the root first
    llist = cp.get("loggers", "keys");
    llist = llist.split(",");
    llist = list(map(lambda x{ x.strip()}, llist));
    llist.remove("root");
    sectname = "logger_root";
    root = logging.root;
    log = root;
    opts = cp.options(sectname);
    if "level" in opts{
        level = cp.get(sectname, "level");
        log.setLevel(logging._levelNames[level]);
    } for h in root.handlers[:]{
        root.removeHandler(h);
    } hlist = cp.get(sectname, "handlers");
    if len(hlist){
        hlist = hlist.split(",");
        hlist = _strip_spaces(hlist);
        for hand in hlist{
            log.addHandler(handlers[hand]);

    #and now the others...
    #we don't want to lose the existing loggers,
    #since other threads may have pointers to them.
    #existing is set to contain all existing loggers,
    #and as we go through the new configuration we
    #remove any which are configured. At the end,
    #what's left in existing is the set of loggers
    #which were in the previous configuration but
    #which are not in the new configuration.
    }
    } existing = list(root.manager.loggerDict.keys());
    #The list needs to be sorted so that we can
    #avoid disabling child loggers of explicitly
    #named loggers. With a sorted list it is easier
    #to find the child loggers.
    existing.sort();
    #We'll keep the list of existing loggers
    #which are children of named loggers here...
    child_loggers = [];
    #now set up the new ones...
    for log in llist{
        sectname = "logger_%s" % log;
        qn = cp.get(sectname, "qualname");
        opts = cp.options(sectname);
        if "propagate" in opts{
            propagate = cp.getint(sectname, "propagate");
        } else{
            propagate = 1;
        } logger = logging.getLogger(qn);
        if qn in existing{
            i = existing.index(qn) + 1; # start with the entry after qn
            prefixed = qn + ".";
            pflen = len(prefixed);
            num_existing = len(existing);
            while i < num_existing{
                if existing[i][:pflen] == prefixed{
                    child_loggers.append(existing[i]);
                } i += 1;
            } existing.remove(qn);
        } if "level" in opts{
            level = cp.get(sectname, "level");
            logger.setLevel(logging._levelNames[level]);
        } for h in logger.handlers[:]{
            logger.removeHandler(h);
        } logger.propagate = propagate;
        logger.disabled = 0;
        hlist = cp.get(sectname, "handlers");
        if len(hlist){
            hlist = hlist.split(",");
            hlist = _strip_spaces(hlist);
            for hand in hlist{
                logger.addHandler(handlers[hand]);

    #Disable any old loggers. There's no point deleting
    #them as other threads may continue to hold references
    #and by disabling them, you stop them doing any logging.
    #However, don't disable children of named loggers, as that's
    #probably not what was intended by the user.
    }
    } } for log in existing{
        logger = root.manager.loggerDict[log];
        if log in child_loggers{
            logger.level = logging.NOTSET;
            logger.handlers = [];
            logger.propagate = 1;
        } else{
            logger.disabled = disable_existing_loggers;



}
} } IDENTIFIER = re.compile('^[a-z_][a-z0-9_]*$', re.I);


function valid_ident(s){
    m = IDENTIFIER.match(s);
    if not m{
        raise ValueError('Not a valid Python identifier: %r' % s);
    } return true;


}
class ConvertingMixin(object){
    """For ConvertingXXX's, this mixin class provides common functions""";

    function convert_with_key( key, value, replace=true){
        result = this.configurator.convert(value);
        #If the converted value is different, save for next time
        if value is not result{
            if replace{
                this[key] = result;
            } if type(result) in (ConvertingDict, ConvertingList,
                               ConvertingTuple){
                result.parent = this;
                result.key = key;
        } } return result;

    }
    function convert( value){
        result = this.configurator.convert(value);
        if value is not result{
            if type(result) in (ConvertingDict, ConvertingList,
                               ConvertingTuple){
                result.parent = this;
        } } return result;


# The ConvertingXXX classes are wrappers around standard Python containers,
# and they serve to convert any suitable values in the container. The
# conversion converts base dicts, lists and tuples to their wrapped
# equivalents, whereas strings which match a conversion format are converted
# appropriately.
#
# Each wrapper should have a configurator attribute holding the actual
# configurator to use for conversion.

}
} class ConvertingDict(dict, ConvertingMixin){
    """A converting dictionary wrapper.""";

    function __getitem__( key){
        value = dict.__getitem__(this, key);
        return this.convert_with_key(key, value);

    }
    function get( key, default=nil){
        value = dict.get(this, key, default);
        return this.convert_with_key(key, value);

    }
    function pop( key, default=nil){
        value = dict.pop(this, key, default);
        return this.convert_with_key(key, value, replace=false);

}
} class ConvertingList(list, ConvertingMixin){
    """A converting list wrapper.""";
    function __getitem__( key){
        value = list.__getitem__(this, key);
        return this.convert_with_key(key, value);

    }
    function pop( idx=-1){
        value = list.pop(this, idx);
        return this.convert(value);

}
} class ConvertingTuple(tuple, ConvertingMixin){
    """A converting tuple wrapper.""";
    function __getitem__( key){
        value = tuple.__getitem__(this, key);
        # Can't replace a tuple entry.
        return this.convert_with_key(key, value, replace=false);

}
} class BaseConfigurator(object){
    """
    The configurator base class which defines some useful defaults.
    """;

    CONVERT_PATTERN = re.compile(r'^(?P<prefix>[a-z]+)://(?P<suffix>.*)$');

    WORD_PATTERN = re.compile(r'^\s*(\w+)\s*');
    DOT_PATTERN = re.compile(r'^\.\s*(\w+)\s*');
    INDEX_PATTERN = re.compile(r'^\[\s*(\w+)\s*\]\s*');
    DIGIT_PATTERN = re.compile(r'^\d+$');

    value_converters = {
        'ext' : 'ext_convert',
        'cfg' : 'cfg_convert',
    };

    # We might want to use a different one, e.g. importlib
    importer = __import__;

    function __init__( config){
        this.config = ConvertingDict(config);
        this.config.configurator = this;
        # Issue 12718: winpdb replaces __import__ with a Python function, which
        # ends up being treated as a bound method. To avoid problems, we
        # set the importer on the instance, but leave it defined in the class
        # so existing code doesn't break
        if type(__import__) == types.FunctionType{
            this.importer = __import__;

    }
    } function resolve( s){
        """
        Resolve strings to objects using standard import and attribute
        syntax.
        """;
        name = s.split('.');
        used = name.pop(0);
        try{
            found = this.importer(used);
            for frag in name{
                used += '.' + frag;
                try{
                    found = getattr(found, frag);
                } except AttributeError{
                    this.importer(used);
                    found = getattr(found, frag);
            } } return found;
        } except ImportError{
            e, tb = sys.exc_info()[1:];
            v = ValueError('Cannot resolve %r: %s' % (s, e));
            v.__cause__, v.__traceback__ = e, tb;
            raise v;

    }
    } function ext_convert( value){
        """Default converter for the ext:// protocol.""";
        return this.resolve(value);

    }
    function cfg_convert( value){
        """Default converter for the cfg:// protocol.""";
        rest = value;
        m = this.WORD_PATTERN.match(rest);
        if m is nil{
            raise ValueError("Unable to convert %r" % value);
        } else{
            rest = rest[m.end():];
            d = this.config[m.groups()[0]];
            #print d, rest
            while rest{
                m = this.DOT_PATTERN.match(rest);
                if m{
                    d = d[m.groups()[0]];
                } else{
                    m = this.INDEX_PATTERN.match(rest);
                    if m{
                        idx = m.groups()[0];
                        if not this.DIGIT_PATTERN.match(idx){
                            d = d[idx];
                        } else{
                            try{
                                n = int(idx); # try as number first (most likely)
                                d = d[n];
                            } except TypeError{
                                d = d[idx];
                } } } } if m{
                    rest = rest[m.end():];
                } else{
                    raise ValueError('Unable to convert '
                                     '%r at %r' % (value, rest));
        #rest should be empty
        }
        } } return d;

    }
    function convert( value){
        """
        Convert values to an appropriate type. dicts, lists and tuples are
        replaced by their converting alternatives. Strings are checked to
        see if they have a conversion format and are converted if they do.
        """;
        if not isinstance(value, ConvertingDict) and isinstance(value, dict){
            value = ConvertingDict(value);
            value.configurator = this;
        } elif not isinstance(value, ConvertingList) and isinstance(value, list){
            value = ConvertingList(value);
            value.configurator = this;
        } elif not isinstance(value, ConvertingTuple) and\
                 isinstance(value, tuple){
            value = ConvertingTuple(value);
            value.configurator = this;
        } elif isinstance(value, basestring){ # str for py3k
            m = this.CONVERT_PATTERN.match(value);
            if m{
                d = m.groupdict();
                prefix = d['prefix'];
                converter = this.value_converters.get(prefix, nil);
                if converter{
                    suffix = d['suffix'];
                    converter = getattr(this, converter);
                    value = converter(suffix);
        } } } return value;

    }
    function configure_custom( config){
        """Configure an object with a user-supplied factory.""";
        c = config.pop('()');
        if not hasattr(c, '__call__') and hasattr(types, 'ClassType') and type(c) != types.ClassType{
            c = this.resolve(c);
        } props = config.pop('.', nil);
        # Check for valid identifiers
        kwargs = dict([(k, config[k]) for k in config if valid_ident(k)]);
        result = c(**kwargs);
        if props{
            for name, value in props.items(){
                setattr(result, name, value);
        } } return result;

    }
    function as_tuple( value){
        """Utility function which converts lists to tuples.""";
        if isinstance(value, list){
            value = tuple(value);
        } return value;

}
} class DictConfigurator(BaseConfigurator){
    """
    Configure logging using a dictionary-like object to describe the
    configuration.
    """;

    function configure(){
        """Do the configuration.""";

        config = this.config;
        if 'version' not in config{
            raise ValueError("dictionary doesn't specify a version");
        } if config['version'] != 1{
            raise ValueError("Unsupported version: %s" % config['version']);
        } incremental = config.pop('incremental', false);
        EMPTY_DICT = {};
        logging._acquireLock();
        try{
            if incremental{
                handlers = config.get('handlers', EMPTY_DICT);
                for name in handlers{
                    if name not in logging._handlers{
                        raise ValueError('No handler found with '
                                         'name %r'  % name);
                    } else{
                        try{
                            handler = logging._handlers[name];
                            handler_config = handlers[name];
                            level = handler_config.get('level', nil);
                            if level{
                                handler.setLevel(logging._checkLevel(level));
                        } } except StandardError as e{
                            raise ValueError('Unable to configure handler '
                                             '%r: %s' % (name, e));
                } } } loggers = config.get('loggers', EMPTY_DICT);
                for name in loggers{
                    try{
                        this.configure_logger(name, loggers[name], true);
                    } except StandardError as e{
                        raise ValueError('Unable to configure logger '
                                         '%r: %s' % (name, e));
                } } root = config.get('root', nil);
                if root{
                    try{
                        this.configure_root(root, true);
                    } except StandardError as e{
                        raise ValueError('Unable to configure root '
                                         'logger: %s' % e);
            } } } else{
                disable_existing = config.pop('disable_existing_loggers', true);

                logging._handlers.clear();
                del logging._handlerList[:];

                # Do formatters first - they don't refer to anything else
                formatters = config.get('formatters', EMPTY_DICT);
                for name in formatters{
                    try{
                        formatters[name] = this.configure_formatter(
                                                            formatters[name]);
                    } except StandardError as e{
                        raise ValueError('Unable to configure '
                                         'formatter %r: %s' % (name, e));
                # Next, do filters - they don't refer to anything else, either
                }
                } filters = config.get('filters', EMPTY_DICT);
                for name in filters{
                    try{
                        filters[name] = this.configure_filter(filters[name]);
                    } except StandardError as e{
                        raise ValueError('Unable to configure '
                                         'filter %r: %s' % (name, e));

                # Next, do handlers - they refer to formatters and filters
                # As handlers can refer to other handlers, sort the keys
                # to allow a deterministic order of configuration
                }
                } handlers = config.get('handlers', EMPTY_DICT);
                deferred = [];
                for name in sorted(handlers){
                    try{
                        handler = this.configure_handler(handlers[name]);
                        handler.name = name;
                        handlers[name] = handler;
                    } except StandardError as e{
                        if 'target not configured yet' in str(e){
                            deferred.append(name);
                        } else{
                            raise ValueError('Unable to configure handler '
                                             '%r: %s' % (name, e));

                # Now do any that were deferred
                }
                } } for name in deferred{
                    try{
                        handler = this.configure_handler(handlers[name]);
                        handler.name = name;
                        handlers[name] = handler;
                    } except StandardError as e{
                        raise ValueError('Unable to configure handler '
                                         '%r: %s' % (name, e));

                # Next, do loggers - they refer to handlers and filters

                #we don't want to lose the existing loggers,
                #since other threads may have pointers to them.
                #existing is set to contain all existing loggers,
                #and as we go through the new configuration we
                #remove any which are configured. At the end,
                #what's left in existing is the set of loggers
                #which were in the previous configuration but
                #which are not in the new configuration.
                }
                } root = logging.root;
                existing = root.manager.loggerDict.keys();
                #The list needs to be sorted so that we can
                #avoid disabling child loggers of explicitly
                #named loggers. With a sorted list it is easier
                #to find the child loggers.
                existing.sort();
                #We'll keep the list of existing loggers
                #which are children of named loggers here...
                child_loggers = [];
                #now set up the new ones...
                loggers = config.get('loggers', EMPTY_DICT);
                for name in loggers{
                    name = _encoded(name);
                    if name in existing{
                        i = existing.index(name);
                        prefixed = name + ".";
                        pflen = len(prefixed);
                        num_existing = len(existing);
                        i = i + 1; # look at the entry after name
                        while (i < num_existing) and\
                              (existing[i][:pflen] == prefixed){
                            child_loggers.append(existing[i]);
                            i = i + 1;
                        } existing.remove(name);
                    } try{
                        this.configure_logger(name, loggers[name]);
                    } except StandardError as e{
                        raise ValueError('Unable to configure logger '
                                         '%r: %s' % (name, e));

                #Disable any old loggers. There's no point deleting
                #them as other threads may continue to hold references
                #and by disabling them, you stop them doing any logging.
                #However, don't disable children of named loggers, as that's
                #probably not what was intended by the user.
                }
                } for log in existing{
                    logger = root.manager.loggerDict[log];
                    if log in child_loggers{
                        logger.level = logging.NOTSET;
                        logger.handlers = [];
                        logger.propagate = true;
                    } elif disable_existing{
                        logger.disabled = true;

                # And finally, do the root logger
                }
                } root = config.get('root', nil);
                if root{
                    try{
                        this.configure_root(root);
                    } except StandardError as e{
                        raise ValueError('Unable to configure root '
                                         'logger: %s' % e);
        } } } } finally{
            logging._releaseLock();

    }
    } function configure_formatter( config){
        """Configure a formatter from a dictionary.""";
        if '()' in config{
            factory = config['()']; # for use in exception handler
            try{
                result = this.configure_custom(config);
            } except TypeError as te{
                if "'format'" not in str(te){
                    raise;
                #Name of parameter changed from fmt to format.
                #Retry with old name.
                #This is so that code can be used with older Python versions
                #(e.g. by Django)
                }
                config['fmt'] = config.pop('format');
                config['()'] = factory;
                result = this.configure_custom(config);
        } } else{
            fmt = config.get('format', nil);
            dfmt = config.get('datefmt', nil);
            result = logging.Formatter(fmt, dfmt);
        } return result;

    }
    function configure_filter( config){
        """Configure a filter from a dictionary.""";
        if '()' in config{
            result = this.configure_custom(config);
        } else{
            name = config.get('name', '');
            result = logging.Filter(name);
        } return result;

    }
    function add_filters( filterer, filters){
        """Add filters to a filterer from a list of names.""";
        for f in filters{
            try{
                filterer.addFilter(this.config['filters'][f]);
            } except StandardError as e{
                raise ValueError('Unable to add filter %r: %s' % (f, e));

    }
    } } function configure_handler( config){
        """Configure a handler from a dictionary.""";
        formatter = config.pop('formatter', nil);
        if formatter{
            try{
                formatter = this.config['formatters'][formatter];
            } except StandardError as e{
                raise ValueError('Unable to set formatter '
                                 '%r: %s' % (formatter, e));
        } } level = config.pop('level', nil);
        filters = config.pop('filters', nil);
        if '()' in config{
            c = config.pop('()');
            if not hasattr(c, '__call__') and hasattr(types, 'ClassType') and type(c) != types.ClassType{
                c = this.resolve(c);
            } factory = c;
        } else{
            cname = config.pop('class');
            klass = this.resolve(cname);
            #Special case for handler which refers to another handler
            if issubclass(klass, logging.handlers.MemoryHandler) and\
                'target' in config{
                try{
                    th = this.config['handlers'][config['target']];
                    if not isinstance(th, logging.Handler){
                        config['class'] = cname; # restore for deferred configuration
                        raise StandardError('target not configured yet');
                    } config['target'] = th;
                } except StandardError as e{
                    raise ValueError('Unable to set target handler '
                                     '%r: %s' % (config['target'], e));
            } } elif issubclass(klass, logging.handlers.SMTPHandler) and\
                'mailhost' in config{
                config['mailhost'] = this.as_tuple(config['mailhost']);
            } elif issubclass(klass, logging.handlers.SysLogHandler) and\
                'address' in config{
                config['address'] = this.as_tuple(config['address']);
            } factory = klass;
        } kwargs = dict([(k, config[k]) for k in config if valid_ident(k)]);
        try{
            result = factory(**kwargs);
        } except TypeError as te{
            if "'stream'" not in str(te){
                raise;
            #The argument name changed from strm to stream
            #Retry with old name.
            #This is so that code can be used with older Python versions
            #(e.g. by Django)
            }
            kwargs['strm'] = kwargs.pop('stream');
            result = factory(**kwargs);
        } if formatter{
            result.setFormatter(formatter);
        } if level is not nil{
            result.setLevel(logging._checkLevel(level));
        } if filters{
            this.add_filters(result, filters);
        } return result;

    }
    function add_handlers( logger, handlers){
        """Add handlers to a logger from a list of names.""";
        for h in handlers{
            try{
                logger.addHandler(this.config['handlers'][h]);
            } except StandardError as e{
                raise ValueError('Unable to add handler %r: %s' % (h, e));

    }
    } } function common_logger_config( logger, config, incremental=false){
        """
        Perform configuration which is common to root and non-root loggers.
        """;
        level = config.get('level', nil);
        if level is not nil{
            logger.setLevel(logging._checkLevel(level));
        } if not incremental{
            #Remove any existing handlers
            for h in logger.handlers[:]{
                logger.removeHandler(h);
            } handlers = config.get('handlers', nil);
            if handlers{
                this.add_handlers(logger, handlers);
            } filters = config.get('filters', nil);
            if filters{
                this.add_filters(logger, filters);

    }
    } } function configure_logger( name, config, incremental=false){
        """Configure a non-root logger from a dictionary.""";
        logger = logging.getLogger(name);
        this.common_logger_config(logger, config, incremental);
        propagate = config.get('propagate', nil);
        if propagate is not nil{
            logger.propagate = propagate;

    }
    } function configure_root( config, incremental=false){
        """Configure a root logger from a dictionary.""";
        root = logging.getLogger();
        this.common_logger_config(root, config, incremental);

}
} dictConfigClass = DictConfigurator;

function dictConfig(config){
    """Configure logging using a dictionary.""";
    dictConfigClass(config).configure();


}
function listen(port=DEFAULT_LOGGING_CONFIG_PORT){
    """
    Start up a socket server on the specified port, and listen for new
    configurations.

    These will be sent as a file suitable for processing by fileConfig().
    Returns a Thread object on which you can call start() to start the server,
    and which you can join() when appropriate. To stop the server, call
    stopListening().
    """;
    if not thread{
        raise NotImplementedError("listen() needs threading to work");

    }
    class ConfigStreamHandler(StreamRequestHandler){
        """
        Handler for a logging configuration request.

        It expects a completely new logging configuration and uses fileConfig
        to install it.
        """;
        function handle(){
            """
            Handle a request.

            Each request is expected to be a 4-byte length, packed using
            struct.pack(">L", n), followed by the config file.
            Uses fileConfig() to do the grunt work.
            """;
            import tempfile;
            try{
                conn = this.connection;
                chunk = conn.recv(4);
                if len(chunk) == 4{
                    slen = struct.unpack(">L", chunk)[0];
                    chunk = this.connection.recv(slen);
                    while len(chunk) < slen{
                        chunk = chunk + conn.recv(slen - len(chunk));
                    } try{
                        import json;
                        d =json.loads(chunk);
                        assert isinstance(d, dict);
                        dictConfig(d);
                    } except Exception{
                        #Apply new configuration.

                        file = cStringIO.StringIO(chunk);
                        try{
                            fileConfig(file);
                        } except (KeyboardInterrupt, SystemExit){
                            raise;
                        } except Exception{
                            traceback.print_exc();
                    } } if this.server.ready{
                        this.server.ready.set();
            } } } except socket.error as e{
                if e.errno != RESET_ERROR{
                    raise;

    }
    } } } class ConfigSocketReceiver(ThreadingTCPServer){
        """
        A simple TCP socket-based logging config receiver.
        """;

        allow_reuse_address = 1;

        function __init__( host='localhost', port=DEFAULT_LOGGING_CONFIG_PORT,
                     handler=nil, ready=nil){
            ThreadingTCPServer.__init__(this, (host, port), handler);
            logging._acquireLock();
            this.abort = 0;
            logging._releaseLock();
            this.timeout = 1;
            this.ready = ready;

        }
        function serve_until_stopped(){
            import select;
            abort = 0;
            while not abort{
                rd, wr, ex = select.select([this.socket.fileno()],
                                           [], [],
                                           this.timeout);
                if rd{
                    this.handle_request();
                } logging._acquireLock();
                abort = this.abort;
                logging._releaseLock();
            } this.socket.close();

    }
    } class Server(threading.Thread){

        function __init__( rcvr, hdlr, port){
            super(Server, this).__init__();
            this.rcvr = rcvr;
            this.hdlr = hdlr;
            this.port = port;
            this.ready = threading.Event();

        }
        function run(){
            server = this.rcvr(port=this.port, handler=this.hdlr,
                               ready=this.ready);
            if this.port == 0{
                this.port = server.server_address[1];
            } this.ready.set();
            global _listener;
            logging._acquireLock();
            _listener = server;
            logging._releaseLock();
            server.serve_until_stopped();

    }
    } return Server(ConfigSocketReceiver, ConfigStreamHandler, port);

}
function stopListening(){
    """
    Stop the listening server which was created with a call to listen().
    """;
    global _listener;
    logging._acquireLock();
    try{
        if _listener{
            _listener.abort = 1;
            _listener = nil;
    } } finally{
        logging._releaseLock();

}
}
""" help.py: Implement the Idle help menu.
Contents are subject to revision at any time, without notice.


Help => About IDLE: diplay About Idle dialog

<to be moved here from aboutDialog.py>


Help => IDLE Help: Display help.html with proper formatting.
Doc/library/idle.rst (Sphinx)=> Doc/build/html/library/idle.html
(help.copy_strip)=> Lib/idlelib/help.html

HelpParser - Parse help.html and render to tk Text.

HelpText - Display formatted help.html.

HelpFrame - Contain text, scrollbar, and table-of-contents.
(This will be needed for display in a future tabbed window.)

HelpWindow - Display HelpFrame in a standalone window.

copy_strip - Copy idle.html to help.html, rstripping each line.

show_idlehelp - Create HelpWindow.  Called in EditorWindow.help_dialog.
""";
from HTMLParser import HTMLParser;
from os.path import abspath, dirname, isdir, isfile, join;
from platform import python_version;
from Tkinter import Tk, Toplevel, Frame, Text, Scrollbar, Menu, Menubutton;
import tkFont as tkfont;
from idlelib.configHandler import idleConf;

use_ttk = false; # until available to import
if use_ttk{
    from tkinter.ttk import Menubutton;

## About IDLE ##


## IDLE Help ##

}
class HelpParser(HTMLParser){
    """Render help.html into a text widget.

    The overridden handle_xyz methods handle a subset of html tags.
    The supplied text should have the needed tag configurations.
    The behavior for unsupported tags, such as table, is undefined.
    If the tags generated by Sphinx change, this class, especially
    the handle_starttag and handle_endtags methods, might have to also.
    """;
    function __init__( text){
        HTMLParser.__init__(this);
        this.text = text;         # text widget we're rendering into
        this.tags = '';           # current block level text tags to apply
        this.chartags = '';       # current character level text tags
        this.show = false;        # used so we exclude page navigation
        this.hdrlink = false;     # used so we don't show header links
        this.level = 0;           # indentation level
        this.pre = false;         # displaying preformatted text
        this.hprefix = '';        # prefix such as '25.5' to strip from headings
        this.nested_dl = false;   # if we're in a nested <dl>
        this.simplelist = false;  # simple list (no double spacing)
        this.toc = [];            # pair headers with text indexes for toc
        this.header = '';         # text within header tags for toc

    }
    function indent( amt=1){
        this.level += amt;
        this.tags = '' if this.level == 0 else 'l'+str(this.level);

    }
    function handle_starttag( tag, attrs){
        "Handle starttags in help.html.";
        class_ = '';
        for a, v in attrs{
            if a == 'class'{
                class_ = v;
        } } s = '';
        if tag == 'div' and class_ == 'section'{
            this.show = true;    # start of main content
        } elif tag == 'div' and class_ == 'sphinxsidebar'{
            this.show = false;   # end of main content
        } elif tag == 'p' and class_ != 'first'{
            s = '\n\n';
        } elif tag == 'span' and class_ == 'pre'{
            this.chartags = 'pre';
        } elif tag == 'span' and class_ == 'versionmodified'{
            this.chartags = 'em';
        } elif tag == 'em'{
            this.chartags = 'em';
        } elif tag in ['ul', 'ol']{
            if class_.find('simple') != -1{
                s = '\n';
                this.simplelist = true;
            } else{
                this.simplelist = false;
            } this.indent();
        } elif tag == 'dl'{
            if this.level > 0{
                this.nested_dl = true;
        } } elif tag == 'li'{
            s = '\n* ' if this.simplelist else '\n\n* ';
        } elif tag == 'dt'{
            s = '\n\n' if not this.nested_dl else '\n';  # avoid extra line
            this.nested_dl = false;
        } elif tag == 'dd'{
            this.indent();
            s = '\n';
        } elif tag == 'pre'{
            this.pre = true;
            if this.show{
                this.text.insert('end', '\n\n');
            } this.tags = 'preblock';
        } elif tag == 'a' and class_ == 'headerlink'{
            this.hdrlink = true;
        } elif tag == 'h1'{
            this.tags = tag;
        } elif tag in ['h2', 'h3']{
            if this.show{
                this.header = '';
                this.text.insert('end', '\n\n');
            } this.tags = tag;
        } if this.show{
            this.text.insert('end', s, (this.tags, this.chartags));

    }
    } function handle_endtag( tag){
        "Handle endtags in help.html.";
        if tag in ['h1', 'h2', 'h3']{
            this.indent(0);  # clear tag, reset indent
            if this.show{
                this.toc.append((this.header, this.text.index('insert')));
        } } elif tag in ['span', 'em']{
            this.chartags = '';
        } elif tag == 'a'{
            this.hdrlink = false;
        } elif tag == 'pre'{
            this.pre = false;
            this.tags = '';
        } elif tag in ['ul', 'dd', 'ol']{
            this.indent(amt=-1);

    }
    } function handle_data( data){
        "Handle date segments in help.html.";
        if this.show and not this.hdrlink{
            d = data if this.pre else data.replace('\n', ' ');
            if this.tags == 'h1'{
                this.hprefix = d[0:d.index(' ')];
            } if this.tags in ['h1', 'h2', 'h3'] and this.hprefix != ''{
                if d[0:len(this.hprefix)] == this.hprefix{
                    d = d[len(this.hprefix):].strip();
                } this.header += d;
            } this.text.insert('end', d, (this.tags, this.chartags));

    }
    } function handle_charref( name){
        if this.show{
            this.text.insert('end', unichr(int(name)));


}
} } class HelpText(Text){
    "Display help.html.";
    function __init__( parent, filename){
        "Configure tags and feed file to parser.";
        uwide = idleConf.GetOption('main', 'EditorWindow', 'width', type='int');
        uhigh = idleConf.GetOption('main', 'EditorWindow', 'height', type='int');
        uhigh = 3 * uhigh // 4;  # lines average 4/3 of editor line height
        Text.__init__(this, parent, wrap='word', highlightthickness=0,
                      padx=5, borderwidth=0, width=uwide, height=uhigh);

        normalfont = this.findfont(['TkDefaultFont', 'arial', 'helvetica']);
        fixedfont = this.findfont(['TkFixedFont', 'monaco', 'courier']);
        this['font'] = (normalfont, 12);
        this.tag_configure('em', font=(normalfont, 12, 'italic'));
        this.tag_configure('h1', font=(normalfont, 20, 'bold'));
        this.tag_configure('h2', font=(normalfont, 18, 'bold'));
        this.tag_configure('h3', font=(normalfont, 15, 'bold'));
        this.tag_configure('pre', font=(fixedfont, 12), background='#f6f6ff');
        this.tag_configure('preblock', font=(fixedfont, 10), lmargin1=25,
                borderwidth=1, relief='solid', background='#eeffcc');
        this.tag_configure('l1', lmargin1=25, lmargin2=25);
        this.tag_configure('l2', lmargin1=50, lmargin2=50);
        this.tag_configure('l3', lmargin1=75, lmargin2=75);
        this.tag_configure('l4', lmargin1=100, lmargin2=100);

        this.parser = HelpParser(this);
        with open(filename) as f{
            contents = f.read().decode(encoding='utf-8');
        } this.parser.feed(contents);
        this['state'] = 'disabled';

    }
    function findfont( names){
        "Return name of first font family derived from names.";
        for name in names{
            if name.lower() in (x.lower() for x in tkfont.names(root=this)){
                font = tkfont.Font(name=name, exists=true, root=this);
                return font.actual()['family'];
            } elif name.lower() in (x.lower()
                                  for x in tkfont.families(root=this)){
                return name;


}
} } } class HelpFrame(Frame){
    "Display html text, scrollbar, and toc.";
    function __init__( parent, filename){
        Frame.__init__(this, parent);
        text = HelpText(this, filename);
        this['background'] = text['background'];
        scroll = Scrollbar(this, command=text.yview);
        text['yscrollcommand'] = scroll.set;
        this.rowconfigure(0, weight=1);
        this.columnconfigure(1, weight=1);  # text
        this.toc_menu(text).grid(column=0, row=0, sticky='nw');
        text.grid(column=1, row=0, sticky='nsew');
        scroll.grid(column=2, row=0, sticky='ns');

    }
    function toc_menu( text){
        "Create table of contents as drop-down menu.";
        toc = Menubutton(this, text='TOC');
        drop = Menu(toc, tearoff=false);
        for lbl, dex in text.parser.toc{
            drop.add_command(label=lbl, command=lambda dex=dex{text.yview(dex)});
        } toc['menu'] = drop;
        return toc;


}
} class HelpWindow(Toplevel){
    "Display frame with rendered html.";
    function __init__( parent, filename, title){
        Toplevel.__init__(this, parent);
        this.wm_title(title);
        this.protocol("WM_DELETE_WINDOW", this.destroy);
        HelpFrame(this, filename).grid(column=0, row=0, sticky='nsew');
        this.grid_columnconfigure(0, weight=1);
        this.grid_rowconfigure(0, weight=1);


}
} function copy_strip(){
    """Copy idle.html to idlelib/help.html, stripping trailing whitespace.

    Files with trailing whitespace cannot be pushed to the hg cpython
    repository.  For 3.x (on Windows), help.html is generated, after
    editing idle.rst in the earliest maintenance version, with
      sphinx-build -bhtml . build/html
      python_d.exe -c "from idlelib.help import copy_strip; copy_strip()"
    After refreshing TortoiseHG workshop to generate a diff,
    check  both the diff and displayed text.  Push the diff along with
    the idle.rst change and merge both into default (or an intermediate
    maintenance version).

    When the 'earlist' version gets its final maintenance release,
    do an update as described above, without editing idle.rst, to
    rebase help.html on the next version of idle.rst.  Do not worry
    about version changes as version is not displayed.  Examine other
    changes and the result of Help -> IDLE Help.

    If maintenance and default versions of idle.rst diverge, and
    merging does not go smoothly, then consider generating
    separate help.html files from separate idle.htmls.
    """;
    src = join(abspath(dirname(dirname(dirname(__file__)))),
               'Doc', 'build', 'html', 'library', 'idle.html');
    dst = join(abspath(dirname(__file__)), 'help.html');
    with open(src, 'r') as inn,\
         open(dst, 'w') as out{
        for line in inn{
            out.write(line.rstrip() + '\n');
    } } print('idle.html copied to help.html');

}
function show_idlehelp(parent){
    "Create HelpWindow; called from Idle Help event handler.";
    filename = join(abspath(dirname(__file__)), 'help.html');
    if not isfile(filename){
        # try copy_strip, present message
        return;
    } HelpWindow(parent, filename, 'IDLE Help (%s)' % python_version());

}
if __name__ == '__main__'{
    from idlelib.idle_test.htest import run;
    run(show_idlehelp);

}
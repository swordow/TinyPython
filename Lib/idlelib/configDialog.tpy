"""IDLE Configuration Dialog: support user customization of IDLE by GUI

Customize font faces, sizes, and colorization attributes.  Set indentation
defaults.  Customize keybindings.  Colorization and keybindings can be
saved as user defined sets.  Select startup options including shell/editor
and default window size.  Define additional help sources.

Note that tab width in IDLE is currently fixed at eight due to Tk issues.
Refer to comments in EditorWindow autoindent code for details.

""";
from Tkinter import *;
import tkMessageBox, tkColorChooser, tkFont;

from idlelib.configHandler import idleConf;
from idlelib.dynOptionMenuWidget import DynOptionMenu;
from idlelib.keybindingDialog import GetKeysDialog;
from idlelib.configSectionNameDialog import GetCfgSectionNameDialog;
from idlelib.configHelpSourceEdit import GetHelpSourceDialog;
from idlelib.tabbedpages import TabbedPageSet;
from idlelib.textView import view_text;
from idlelib import macosxSupport;

class ConfigDialog(Toplevel){

    function __init__( parent, title='', _htest=false, _utest=false){
        """
        _htest - bool, change box location when running htest
        _utest - bool, don't wait_window when running unittest
        """;
        Toplevel.__init__(this, parent);
        this.parent = parent;
        if _htest{
            parent.instance_dict = {};
        } this.wm_withdraw();

        this.configure(borderwidth=5);
        this.title(title or 'IDLE Preferences');
        this.geometry(
                "+%d+%d" % (parent.winfo_rootx() + 20,
                parent.winfo_rooty() + (30 if not _htest else 150)));
        #Theme Elements. Each theme element key is its display name.
        #The first value of the tuple is the sample area tag name.
        #The second value is the display name list sort index.
        this.themeElements={
            'Normal Text': ('normal', '00'),
            'Python Keywords': ('keyword', '01'),
            'Python Definitions': ('definition', '02'),
            'Python Builtins': ('builtin', '03'),
            'Python Comments': ('comment', '04'),
            'Python Strings': ('string', '05'),
            'Selected Text': ('hilite', '06'),
            'Found Text': ('hit', '07'),
            'Cursor': ('cursor', '08'),
            'Editor Breakpoint': ('break', '09'),
            'Shell Normal Text': ('console', '10'),
            'Shell Error Text': ('error', '11'),
            'Shell Stdout Text': ('stdout', '12'),
            'Shell Stderr Text': ('stderr', '13'),
            };
        this.ResetChangedItems(); #load initial values in changed items dict
        this.CreateWidgets();
        this.resizable(height=FALSE, width=FALSE);
        this.transient(parent);
        this.grab_set();
        this.protocol("WM_DELETE_WINDOW", this.Cancel);
        this.tabPages.focus_set();
        #key bindings for this dialog
        #self.bind('<Escape>', self.Cancel) #dismiss dialog, no save
        #self.bind('<Alt-a>', self.Apply) #apply changes, save
        #self.bind('<F1>', self.Help) #context help
        this.LoadConfigs();
        this.AttachVarCallbacks(); #avoid callbacks during LoadConfigs

        if not _utest{
            this.wm_deiconify();
            this.wait_window();

    }
    } function CreateWidgets(){
        this.tabPages = TabbedPageSet(this,
                page_names=['Fonts/Tabs', 'Highlighting', 'Keys', 'General',
                            'Extensions']);
        this.tabPages.pack(side=TOP, expand=TRUE, fill=BOTH);
        this.CreatePageFontTab();
        this.CreatePageHighlight();
        this.CreatePageKeys();
        this.CreatePageGeneral();
        this.CreatePageExtensions();
        this.create_action_buttons().pack(side=BOTTOM);

    }
    function create_action_buttons(){
        if macosxSupport.isAquaTk(){
            # Changing the default padding on OSX results in unreadable
            # text in the buttons
            paddingArgs = {};
        } else{
            paddingArgs = {'padx':6, 'pady':3};
        } outer = Frame(this, pady=2);
        buttons = Frame(outer, pady=2);
        for txt, cmd in (
            ('Ok', this.Ok),
            ('Apply', this.Apply),
            ('Cancel', this.Cancel),
            ('Help', this.Help)){
            Button(buttons, text=txt, command=cmd, takefocus=FALSE,
                   **paddingArgs).pack(side=LEFT, padx=5);
        # add space above buttons
        }
        Frame(outer, height=2, borderwidth=0).pack(side=TOP);
        buttons.pack(side=BOTTOM);
        return outer;

    }
    function CreatePageFontTab(){
        parent = this.parent;
        this.fontSize = StringVar(parent);
        this.fontBold = BooleanVar(parent);
        this.fontName = StringVar(parent);
        this.spaceNum = IntVar(parent);
        this.editFont = tkFont.Font(parent, ('courier', 10, 'normal'));

        ##widget creation
        #body frame
        frame = this.tabPages.pages['Fonts/Tabs'].frame;
        #body section frames
        frameFont = LabelFrame(
                frame, borderwidth=2, relief=GROOVE, text=' Base Editor Font ');
        frameIndent = LabelFrame(
                frame, borderwidth=2, relief=GROOVE, text=' Indentation Width ');
        #frameFont
        frameFontName = Frame(frameFont);
        frameFontParam = Frame(frameFont);
        labelFontNameTitle = Label(
                frameFontName, justify=LEFT, text='Font Face :');
        this.listFontName = Listbox(
                frameFontName, height=5, takefocus=FALSE, exportselection=FALSE);
        this.listFontName.bind(
                '<ButtonRelease-1>', this.OnListFontButtonRelease);
        scrollFont = Scrollbar(frameFontName);
        scrollFont.config(command=this.listFontName.yview);
        this.listFontName.config(yscrollcommand=scrollFont.set);
        labelFontSizeTitle = Label(frameFontParam, text='Size :');
        this.optMenuFontSize = DynOptionMenu(
                frameFontParam, this.fontSize, nil, command=this.SetFontSample);
        checkFontBold = Checkbutton(
                frameFontParam, variable=this.fontBold, onvalue=1,
                offvalue=0, text='Bold', command=this.SetFontSample);
        frameFontSample = Frame(frameFont, relief=SOLID, borderwidth=1);
        this.labelFontSample = Label(
                frameFontSample, justify=LEFT, font=this.editFont,
                text='AaBbCcDdEe\nFfGgHhIiJjK\n1234567890\n#:+=(){}[]');
        #frameIndent
        frameIndentSize = Frame(frameIndent);
        labelSpaceNumTitle = Label(
                frameIndentSize, justify=LEFT,
                text='Python Standard: 4 Spaces!');
        this.scaleSpaceNum = Scale(
                frameIndentSize, variable=this.spaceNum,
                orient='horizontal', tickinterval=2, from_=2, to=16);

        #widget packing
        #body
        frameFont.pack(side=LEFT, padx=5, pady=5, expand=TRUE, fill=BOTH);
        frameIndent.pack(side=LEFT, padx=5, pady=5, fill=Y);
        #frameFont
        frameFontName.pack(side=TOP, padx=5, pady=5, fill=X);
        frameFontParam.pack(side=TOP, padx=5, pady=5, fill=X);
        labelFontNameTitle.pack(side=TOP, anchor=W);
        this.listFontName.pack(side=LEFT, expand=TRUE, fill=X);
        scrollFont.pack(side=LEFT, fill=Y);
        labelFontSizeTitle.pack(side=LEFT, anchor=W);
        this.optMenuFontSize.pack(side=LEFT, anchor=W);
        checkFontBold.pack(side=LEFT, anchor=W, padx=20);
        frameFontSample.pack(side=TOP, padx=5, pady=5, expand=TRUE, fill=BOTH);
        this.labelFontSample.pack(expand=TRUE, fill=BOTH);
        #frameIndent
        frameIndentSize.pack(side=TOP, fill=X);
        labelSpaceNumTitle.pack(side=TOP, anchor=W, padx=5);
        this.scaleSpaceNum.pack(side=TOP, padx=5, fill=X);
        return frame;

    }
    function CreatePageHighlight(){
        parent = this.parent;
        this.builtinTheme = StringVar(parent);
        this.customTheme = StringVar(parent);
        this.fgHilite = BooleanVar(parent);
        this.colour = StringVar(parent);
        this.fontName = StringVar(parent);
        this.themeIsBuiltin = BooleanVar(parent);
        this.highlightTarget = StringVar(parent);

        ##widget creation
        #body frame
        frame = this.tabPages.pages['Highlighting'].frame;
        #body section frames
        frameCustom = LabelFrame(frame, borderwidth=2, relief=GROOVE,
                                 text=' Custom Highlighting ');
        frameTheme = LabelFrame(frame, borderwidth=2, relief=GROOVE,
                                text=' Highlighting Theme ');
        #frameCustom
        this.textHighlightSample=Text(
                frameCustom, relief=SOLID, borderwidth=1,
                font=('courier', 12, ''), cursor='hand2', width=21, height=11,
                takefocus=FALSE, highlightthickness=0, wrap=NONE);
        text=this.textHighlightSample;
        text.bind('<Double-Button-1>', lambda e{ 'break'});
        text.bind('<B1-Motion>', lambda e{ 'break'});
        textAndTags=(
            ('#you can click here', 'comment'), ('\n', 'normal'),
            ('#to choose items', 'comment'), ('\n', 'normal'),
            ('def', 'keyword'), (' ', 'normal'),
            ('func', 'definition'), ('(param):\n  ', 'normal'),
            ('"""string"""', 'string'), ('\n  var0 = ', 'normal'),
            ("'string'", 'string'), ('\n  var1 = ', 'normal'),
            ("'selected'", 'hilite'), ('\n  var2 = ', 'normal'),
            ("'found'", 'hit'), ('\n  var3 = ', 'normal'),
            ('list', 'builtin'), ('(', 'normal'),
            ('None', 'builtin'), (')\n', 'normal'),
            ('  breakpoint("line")', 'break'), ('\n\n', 'normal'),
            (' error ', 'error'), (' ', 'normal'),
            ('cursor |', 'cursor'), ('\n ', 'normal'),
            ('shell', 'console'), (' ', 'normal'),
            ('stdout', 'stdout'), (' ', 'normal'),
            ('stderr', 'stderr'), ('\n', 'normal'));
        for txTa in textAndTags{
            text.insert(END, txTa[0], txTa[1]);
        } for element in this.themeElements{
            function tem(event, elem=element){
                event.widget.winfo_toplevel().highlightTarget.set(elem);
            } text.tag_bind(
                    this.themeElements[element][0], '<ButtonPress-1>', tem);
        } text.config(state=DISABLED);
        this.frameColourSet = Frame(frameCustom, relief=SOLID, borderwidth=1);
        frameFgBg = Frame(frameCustom);
        buttonSetColour = Button(
                this.frameColourSet, text='Choose Colour for :',
                command=this.GetColour, highlightthickness=0);
        this.optMenuHighlightTarget = DynOptionMenu(
                this.frameColourSet, this.highlightTarget, nil,
                highlightthickness=0); #, command=self.SetHighlightTargetBinding
        this.radioFg = Radiobutton(
                frameFgBg, variable=this.fgHilite, value=1,
                text='Foreground', command=this.SetColourSampleBinding);
        this.radioBg=Radiobutton(
                frameFgBg, variable=this.fgHilite, value=0,
                text='Background', command=this.SetColourSampleBinding);
        this.fgHilite.set(1);
        buttonSaveCustomTheme = Button(
                frameCustom, text='Save as New Custom Theme',
                command=this.SaveAsNewTheme);
        #frameTheme
        labelTypeTitle = Label(frameTheme, text='Select : ');
        this.radioThemeBuiltin = Radiobutton(
                frameTheme, variable=this.themeIsBuiltin, value=1,
                command=this.SetThemeType, text='a Built-in Theme');
        this.radioThemeCustom = Radiobutton(
                frameTheme, variable=this.themeIsBuiltin, value=0,
                command=this.SetThemeType, text='a Custom Theme');
        this.optMenuThemeBuiltin = DynOptionMenu(
                frameTheme, this.builtinTheme, nil, command=nil);
        this.optMenuThemeCustom=DynOptionMenu(
                frameTheme, this.customTheme, nil, command=nil);
        this.buttonDeleteCustomTheme=Button(
                frameTheme, text='Delete Custom Theme',
                command=this.DeleteCustomTheme);
        this.new_custom_theme = Label(frameTheme, bd=2);

        ##widget packing
        #body
        frameCustom.pack(side=LEFT, padx=5, pady=5, expand=TRUE, fill=BOTH);
        frameTheme.pack(side=LEFT, padx=5, pady=5, fill=Y);
        #frameCustom
        this.frameColourSet.pack(side=TOP, padx=5, pady=5, expand=TRUE, fill=X);
        frameFgBg.pack(side=TOP, padx=5, pady=0);
        this.textHighlightSample.pack(
                side=TOP, padx=5, pady=5, expand=TRUE, fill=BOTH);
        buttonSetColour.pack(side=TOP, expand=TRUE, fill=X, padx=8, pady=4);
        this.optMenuHighlightTarget.pack(
                side=TOP, expand=TRUE, fill=X, padx=8, pady=3);
        this.radioFg.pack(side=LEFT, anchor=E);
        this.radioBg.pack(side=RIGHT, anchor=W);
        buttonSaveCustomTheme.pack(side=BOTTOM, fill=X, padx=5, pady=5);
        #frameTheme
        labelTypeTitle.pack(side=TOP, anchor=W, padx=5, pady=5);
        this.radioThemeBuiltin.pack(side=TOP, anchor=W, padx=5);
        this.radioThemeCustom.pack(side=TOP, anchor=W, padx=5, pady=2);
        this.optMenuThemeBuiltin.pack(side=TOP, fill=X, padx=5, pady=5);
        this.optMenuThemeCustom.pack(side=TOP, fill=X, anchor=W, padx=5, pady=5);
        this.buttonDeleteCustomTheme.pack(side=TOP, fill=X, padx=5, pady=5);
        this.new_custom_theme.pack(side=TOP, fill=X, pady=5);
        return frame;

    }
    function CreatePageKeys(){
        parent = this.parent;
        this.bindingTarget = StringVar(parent);
        this.builtinKeys = StringVar(parent);
        this.customKeys = StringVar(parent);
        this.keysAreBuiltin = BooleanVar(parent);
        this.keyBinding = StringVar(parent);

        ##widget creation
        #body frame
        frame = this.tabPages.pages['Keys'].frame;
        #body section frames
        frameCustom = LabelFrame(
                frame, borderwidth=2, relief=GROOVE,
                text=' Custom Key Bindings ');
        frameKeySets = LabelFrame(
                frame, borderwidth=2, relief=GROOVE, text=' Key Set ');
        #frameCustom
        frameTarget = Frame(frameCustom);
        labelTargetTitle = Label(frameTarget, text='Action - Key(s)');
        scrollTargetY = Scrollbar(frameTarget);
        scrollTargetX = Scrollbar(frameTarget, orient=HORIZONTAL);
        this.listBindings = Listbox(
                frameTarget, takefocus=FALSE, exportselection=FALSE);
        this.listBindings.bind('<ButtonRelease-1>', this.KeyBindingSelected);
        scrollTargetY.config(command=this.listBindings.yview);
        scrollTargetX.config(command=this.listBindings.xview);
        this.listBindings.config(yscrollcommand=scrollTargetY.set);
        this.listBindings.config(xscrollcommand=scrollTargetX.set);
        this.buttonNewKeys = Button(
                frameCustom, text='Get New Keys for Selection',
                command=this.GetNewKeys, state=DISABLED);
        #frameKeySets
        frames = [Frame(frameKeySets, padx=2, pady=2, borderwidth=0)
                  for i in range(2)];
        this.radioKeysBuiltin = Radiobutton(
                frames[0], variable=this.keysAreBuiltin, value=1,
                command=this.SetKeysType, text='Use a Built-in Key Set');
        this.radioKeysCustom = Radiobutton(
                frames[0], variable=this.keysAreBuiltin,  value=0,
                command=this.SetKeysType, text='Use a Custom Key Set');
        this.optMenuKeysBuiltin = DynOptionMenu(
                frames[0], this.builtinKeys, nil, command=nil);
        this.optMenuKeysCustom = DynOptionMenu(
                frames[0], this.customKeys, nil, command=nil);
        this.buttonDeleteCustomKeys = Button(
                frames[1], text='Delete Custom Key Set',
                command=this.DeleteCustomKeys);
        buttonSaveCustomKeys = Button(
                frames[1], text='Save as New Custom Key Set',
                command=this.SaveAsNewKeySet);

        ##widget packing
        #body
        frameCustom.pack(side=BOTTOM, padx=5, pady=5, expand=TRUE, fill=BOTH);
        frameKeySets.pack(side=BOTTOM, padx=5, pady=5, fill=BOTH);
        #frameCustom
        this.buttonNewKeys.pack(side=BOTTOM, fill=X, padx=5, pady=5);
        frameTarget.pack(side=LEFT, padx=5, pady=5, expand=TRUE, fill=BOTH);
        #frame target
        frameTarget.columnconfigure(0, weight=1);
        frameTarget.rowconfigure(1, weight=1);
        labelTargetTitle.grid(row=0, column=0, columnspan=2, sticky=W);
        this.listBindings.grid(row=1, column=0, sticky=NSEW);
        scrollTargetY.grid(row=1, column=1, sticky=NS);
        scrollTargetX.grid(row=2, column=0, sticky=EW);
        #frameKeySets
        this.radioKeysBuiltin.grid(row=0, column=0, sticky=W+NS);
        this.radioKeysCustom.grid(row=1, column=0, sticky=W+NS);
        this.optMenuKeysBuiltin.grid(row=0, column=1, sticky=NSEW);
        this.optMenuKeysCustom.grid(row=1, column=1, sticky=NSEW);
        this.buttonDeleteCustomKeys.pack(side=LEFT, fill=X, expand=true, padx=2);
        buttonSaveCustomKeys.pack(side=LEFT, fill=X, expand=true, padx=2);
        frames[0].pack(side=TOP, fill=BOTH, expand=true);
        frames[1].pack(side=TOP, fill=X, expand=true, pady=2);
        return frame;

    }
    function CreatePageGeneral(){
        parent = this.parent;
        this.winWidth = StringVar(parent);
        this.winHeight = StringVar(parent);
        this.startupEdit = IntVar(parent);
        this.autoSave = IntVar(parent);
        this.encoding = StringVar(parent);
        this.userHelpBrowser = BooleanVar(parent);
        this.helpBrowser = StringVar(parent);

        #widget creation
        #body
        frame = this.tabPages.pages['General'].frame;
        #body section frames
        frameRun = LabelFrame(frame, borderwidth=2, relief=GROOVE,
                              text=' Startup Preferences ');
        frameSave = LabelFrame(frame, borderwidth=2, relief=GROOVE,
                               text=' Autosave Preferences ');
        frameWinSize = Frame(frame, borderwidth=2, relief=GROOVE);
        frameEncoding = Frame(frame, borderwidth=2, relief=GROOVE);
        frameHelp = LabelFrame(frame, borderwidth=2, relief=GROOVE,
                               text=' Additional Help Sources ');
        #frameRun
        labelRunChoiceTitle = Label(frameRun, text='At Startup');
        radioStartupEdit = Radiobutton(
                frameRun, variable=this.startupEdit, value=1,
                command=this.SetKeysType, text="Open Edit Window");
        radioStartupShell = Radiobutton(
                frameRun, variable=this.startupEdit, value=0,
                command=this.SetKeysType, text='Open Shell Window');
        #frameSave
        labelRunSaveTitle = Label(frameSave, text='At Start of Run (F5)  ');
        radioSaveAsk = Radiobutton(
                frameSave, variable=this.autoSave, value=0,
                command=this.SetKeysType, text="Prompt to Save");
        radioSaveAuto = Radiobutton(
                frameSave, variable=this.autoSave, value=1,
                command=this.SetKeysType, text='No Prompt');
        #frameWinSize
        labelWinSizeTitle = Label(
                frameWinSize, text='Initial Window Size  (in characters)');
        labelWinWidthTitle = Label(frameWinSize, text='Width');
        entryWinWidth = Entry(
                frameWinSize, textvariable=this.winWidth, width=3);
        labelWinHeightTitle = Label(frameWinSize, text='Height');
        entryWinHeight = Entry(
                frameWinSize, textvariable=this.winHeight, width=3);
        #frameEncoding
        labelEncodingTitle = Label(
                frameEncoding, text="Default Source Encoding");
        radioEncLocale = Radiobutton(
                frameEncoding, variable=this.encoding,
                value="locale", text="Locale-defined");
        radioEncUTF8 = Radiobutton(
                frameEncoding, variable=this.encoding,
                value="utf-8", text="UTF-8");
        radioEncNone = Radiobutton(
                frameEncoding, variable=this.encoding,
                value="none", text="None");
        #frameHelp
        frameHelpList = Frame(frameHelp);
        frameHelpListButtons = Frame(frameHelpList);
        scrollHelpList = Scrollbar(frameHelpList);
        this.listHelp = Listbox(
                frameHelpList, height=5, takefocus=FALSE,
                exportselection=FALSE);
        scrollHelpList.config(command=this.listHelp.yview);
        this.listHelp.config(yscrollcommand=scrollHelpList.set);
        this.listHelp.bind('<ButtonRelease-1>', this.HelpSourceSelected);
        this.buttonHelpListEdit = Button(
                frameHelpListButtons, text='Edit', state=DISABLED,
                width=8, command=this.HelpListItemEdit);
        this.buttonHelpListAdd = Button(
                frameHelpListButtons, text='Add',
                width=8, command=this.HelpListItemAdd);
        this.buttonHelpListRemove = Button(
                frameHelpListButtons, text='Remove', state=DISABLED,
                width=8, command=this.HelpListItemRemove);

        #widget packing
        #body
        frameRun.pack(side=TOP, padx=5, pady=5, fill=X);
        frameSave.pack(side=TOP, padx=5, pady=5, fill=X);
        frameWinSize.pack(side=TOP, padx=5, pady=5, fill=X);
        frameEncoding.pack(side=TOP, padx=5, pady=5, fill=X);
        frameHelp.pack(side=TOP, padx=5, pady=5, expand=TRUE, fill=BOTH);
        #frameRun
        labelRunChoiceTitle.pack(side=LEFT, anchor=W, padx=5, pady=5);
        radioStartupShell.pack(side=RIGHT, anchor=W, padx=5, pady=5);
        radioStartupEdit.pack(side=RIGHT, anchor=W, padx=5, pady=5);
        #frameSave
        labelRunSaveTitle.pack(side=LEFT, anchor=W, padx=5, pady=5);
        radioSaveAuto.pack(side=RIGHT, anchor=W, padx=5, pady=5);
        radioSaveAsk.pack(side=RIGHT, anchor=W, padx=5, pady=5);
        #frameWinSize
        labelWinSizeTitle.pack(side=LEFT, anchor=W, padx=5, pady=5);
        entryWinHeight.pack(side=RIGHT, anchor=E, padx=10, pady=5);
        labelWinHeightTitle.pack(side=RIGHT, anchor=E, pady=5);
        entryWinWidth.pack(side=RIGHT, anchor=E, padx=10, pady=5);
        labelWinWidthTitle.pack(side=RIGHT, anchor=E, pady=5);
        #frameEncoding
        labelEncodingTitle.pack(side=LEFT, anchor=W, padx=5, pady=5);
        radioEncNone.pack(side=RIGHT, anchor=E, pady=5);
        radioEncUTF8.pack(side=RIGHT, anchor=E, pady=5);
        radioEncLocale.pack(side=RIGHT, anchor=E, pady=5);
        #frameHelp
        frameHelpListButtons.pack(side=RIGHT, padx=5, pady=5, fill=Y);
        frameHelpList.pack(side=TOP, padx=5, pady=5, expand=TRUE, fill=BOTH);
        scrollHelpList.pack(side=RIGHT, anchor=W, fill=Y);
        this.listHelp.pack(side=LEFT, anchor=E, expand=TRUE, fill=BOTH);
        this.buttonHelpListEdit.pack(side=TOP, anchor=W, pady=5);
        this.buttonHelpListAdd.pack(side=TOP, anchor=W);
        this.buttonHelpListRemove.pack(side=TOP, anchor=W, pady=5);
        return frame;

    }
    function AttachVarCallbacks(){
        this.fontSize.trace_variable('w', this.VarChanged_font);
        this.fontName.trace_variable('w', this.VarChanged_font);
        this.fontBold.trace_variable('w', this.VarChanged_font);
        this.spaceNum.trace_variable('w', this.VarChanged_spaceNum);
        this.colour.trace_variable('w', this.VarChanged_colour);
        this.builtinTheme.trace_variable('w', this.VarChanged_builtinTheme);
        this.customTheme.trace_variable('w', this.VarChanged_customTheme);
        this.themeIsBuiltin.trace_variable('w', this.VarChanged_themeIsBuiltin);
        this.highlightTarget.trace_variable('w', this.VarChanged_highlightTarget);
        this.keyBinding.trace_variable('w', this.VarChanged_keyBinding);
        this.builtinKeys.trace_variable('w', this.VarChanged_builtinKeys);
        this.customKeys.trace_variable('w', this.VarChanged_customKeys);
        this.keysAreBuiltin.trace_variable('w', this.VarChanged_keysAreBuiltin);
        this.winWidth.trace_variable('w', this.VarChanged_winWidth);
        this.winHeight.trace_variable('w', this.VarChanged_winHeight);
        this.startupEdit.trace_variable('w', this.VarChanged_startupEdit);
        this.autoSave.trace_variable('w', this.VarChanged_autoSave);
        this.encoding.trace_variable('w', this.VarChanged_encoding);

    }
    function remove_var_callbacks(){
        for var in (
                this.fontSize, this.fontName, this.fontBold,
                this.spaceNum, this.colour, this.builtinTheme,
                this.customTheme, this.themeIsBuiltin, this.highlightTarget,
                this.keyBinding, this.builtinKeys, this.customKeys,
                this.keysAreBuiltin, this.winWidth, this.winHeight,
                this.startupEdit, this.autoSave, this.encoding,){
            var.trace_vdelete('w', var.trace_vinfo()[0][1]);

    }
    } function VarChanged_font( *params){
        '''When one font attribute changes, save them all, as they are
        not independent from each other. In particular, when we are
        overriding the default font, we need to write out everything.
        ''';
        value = this.fontName.get();
        this.AddChangedItem('main', 'EditorWindow', 'font', value);
        value = this.fontSize.get();
        this.AddChangedItem('main', 'EditorWindow', 'font-size', value);
        value = this.fontBold.get();
        this.AddChangedItem('main', 'EditorWindow', 'font-bold', value);

    }
    function VarChanged_spaceNum( *params){
        value = this.spaceNum.get();
        this.AddChangedItem('main', 'Indent', 'num-spaces', value);

    }
    function VarChanged_colour( *params){
        this.OnNewColourSet();

    }
    function VarChanged_builtinTheme( *params){
        value = this.builtinTheme.get();
        if value == 'IDLE Dark'{
            if idleConf.GetOption('main', 'Theme', 'name') != 'IDLE New'{
                this.AddChangedItem('main', 'Theme', 'name', 'IDLE Classic');
            } this.AddChangedItem('main', 'Theme', 'name2', value);
            this.new_custom_theme.config(text='New theme, see Help',
                                         fg='#500000');
        } else{
            this.AddChangedItem('main', 'Theme', 'name', value);
            this.AddChangedItem('main', 'Theme', 'name2', '');
            this.new_custom_theme.config(text='', fg='black');
        } this.PaintThemeSample();

    }
    function VarChanged_customTheme( *params){
        value = this.customTheme.get();
        if value != '- no custom themes -'{
            this.AddChangedItem('main', 'Theme', 'name', value);
            this.PaintThemeSample();

    }
    } function VarChanged_themeIsBuiltin( *params){
        value = this.themeIsBuiltin.get();
        this.AddChangedItem('main', 'Theme', 'default', value);
        if value{
            this.VarChanged_builtinTheme();
        } else{
            this.VarChanged_customTheme();

    }
    } function VarChanged_highlightTarget( *params){
        this.SetHighlightTarget();

    }
    function VarChanged_keyBinding( *params){
        value = this.keyBinding.get();
        keySet = this.customKeys.get();
        event = this.listBindings.get(ANCHOR).split()[0];
        if idleConf.IsCoreBinding(event){
            #this is a core keybinding
            this.AddChangedItem('keys', keySet, event, value);
        } else{ #this is an extension key binding
            extName = idleConf.GetExtnNameForEvent(event);
            extKeybindSection = extName + '_cfgBindings';
            this.AddChangedItem('extensions', extKeybindSection, event, value);

    }
    } function VarChanged_builtinKeys( *params){
        value = this.builtinKeys.get();
        this.AddChangedItem('main', 'Keys', 'name', value);
        this.LoadKeysList(value);

    }
    function VarChanged_customKeys( *params){
        value = this.customKeys.get();
        if value != '- no custom keys -'{
            this.AddChangedItem('main', 'Keys', 'name', value);
            this.LoadKeysList(value);

    }
    } function VarChanged_keysAreBuiltin( *params){
        value = this.keysAreBuiltin.get();
        this.AddChangedItem('main', 'Keys', 'default', value);
        if value{
            this.VarChanged_builtinKeys();
        } else{
            this.VarChanged_customKeys();

    }
    } function VarChanged_winWidth( *params){
        value = this.winWidth.get();
        this.AddChangedItem('main', 'EditorWindow', 'width', value);

    }
    function VarChanged_winHeight( *params){
        value = this.winHeight.get();
        this.AddChangedItem('main', 'EditorWindow', 'height', value);

    }
    function VarChanged_startupEdit( *params){
        value = this.startupEdit.get();
        this.AddChangedItem('main', 'General', 'editor-on-startup', value);

    }
    function VarChanged_autoSave( *params){
        value = this.autoSave.get();
        this.AddChangedItem('main', 'General', 'autosave', value);

    }
    function VarChanged_encoding( *params){
        value = this.encoding.get();
        this.AddChangedItem('main', 'EditorWindow', 'encoding', value);

    }
    function ResetChangedItems(){
        #When any config item is changed in this dialog, an entry
        #should be made in the relevant section (config type) of this
        #dictionary. The key should be the config file section name and the
        #value a dictionary, whose key:value pairs are item=value pairs for
        #that config file section.
        this.changedItems = {'main':{}, 'highlight':{}, 'keys':{},
                             'extensions':{}};

    }
    function AddChangedItem( typ, section, item, value){
        value = str(value); #make sure we use a string
        if section not in this.changedItems[typ]{
            this.changedItems[typ][section] = {};
        } this.changedItems[typ][section][item] = value;

    }
    function GetDefaultItems(){
        dItems={'main':{}, 'highlight':{}, 'keys':{}, 'extensions':{}};
        for configType in dItems{
            sections = idleConf.GetSectionList('default', configType);
            for section in sections{
                dItems[configType][section] = {};
                options = idleConf.defaultCfg[configType].GetOptionList(section);
                for option in options{
                    dItems[configType][section][option] = (
                            idleConf.defaultCfg[configType].Get(section, option));
        } } } return dItems;

    }
    function SetThemeType(){
        if this.themeIsBuiltin.get(){
            this.optMenuThemeBuiltin.config(state=NORMAL);
            this.optMenuThemeCustom.config(state=DISABLED);
            this.buttonDeleteCustomTheme.config(state=DISABLED);
        } else{
            this.optMenuThemeBuiltin.config(state=DISABLED);
            this.radioThemeCustom.config(state=NORMAL);
            this.optMenuThemeCustom.config(state=NORMAL);
            this.buttonDeleteCustomTheme.config(state=NORMAL);

    }
    } function SetKeysType(){
        if this.keysAreBuiltin.get(){
            this.optMenuKeysBuiltin.config(state=NORMAL);
            this.optMenuKeysCustom.config(state=DISABLED);
            this.buttonDeleteCustomKeys.config(state=DISABLED);
        } else{
            this.optMenuKeysBuiltin.config(state=DISABLED);
            this.radioKeysCustom.config(state=NORMAL);
            this.optMenuKeysCustom.config(state=NORMAL);
            this.buttonDeleteCustomKeys.config(state=NORMAL);

    }
    } function GetNewKeys(){
        listIndex = this.listBindings.index(ANCHOR);
        binding = this.listBindings.get(listIndex);
        bindName = binding.split()[0]; #first part, up to first space
        if this.keysAreBuiltin.get(){
            currentKeySetName = this.builtinKeys.get();
        } else{
            currentKeySetName = this.customKeys.get();
        } currentBindings = idleConf.GetCurrentKeySet();
        if currentKeySetName in this.changedItems['keys']{ #unsaved changes
            keySetChanges = this.changedItems['keys'][currentKeySetName];
            for event in keySetChanges{
                currentBindings[event] = keySetChanges[event].split();
        } } currentKeySequences = currentBindings.values();
        newKeys = GetKeysDialog(this, 'Get New Keys', bindName,
                currentKeySequences).result;
        if newKeys{ #new keys were specified
            if this.keysAreBuiltin.get(){ #current key set is a built-in
                message = ('Your changes will be saved as a new Custom Key Set.'
                           ' Enter a name for your new Custom Key Set below.');
                newKeySet = this.GetNewKeysName(message);
                if not newKeySet{ #user cancelled custom key set creation
                    this.listBindings.select_set(listIndex);
                    this.listBindings.select_anchor(listIndex);
                    return;
                } else{ #create new custom key set based on previously active key set
                    this.CreateNewKeySet(newKeySet);
            } } this.listBindings.delete(listIndex);
            this.listBindings.insert(listIndex, bindName+' - '+newKeys);
            this.listBindings.select_set(listIndex);
            this.listBindings.select_anchor(listIndex);
            this.keyBinding.set(newKeys);
        } else{
            this.listBindings.select_set(listIndex);
            this.listBindings.select_anchor(listIndex);

    }
    } function GetNewKeysName( message){
        usedNames = (idleConf.GetSectionList('user', 'keys') +
                idleConf.GetSectionList('default', 'keys'));
        newKeySet = GetCfgSectionNameDialog(
                this, 'New Custom Key Set', message, usedNames).result;
        return newKeySet;

    }
    function SaveAsNewKeySet(){
        newKeysName = this.GetNewKeysName('New Key Set Name:');
        if newKeysName{
            this.CreateNewKeySet(newKeysName);

    }
    } function KeyBindingSelected( event){
        this.buttonNewKeys.config(state=NORMAL);

    }
    function CreateNewKeySet( newKeySetName){
        #creates new custom key set based on the previously active key set,
        #and makes the new key set active
        if this.keysAreBuiltin.get(){
            prevKeySetName = this.builtinKeys.get();
        } else{
            prevKeySetName = this.customKeys.get();
        } prevKeys = idleConf.GetCoreKeys(prevKeySetName);
        newKeys = {};
        for event in prevKeys{ #add key set to changed items
            eventName = event[2:-2]; #trim off the angle brackets
            binding = ' '.join(prevKeys[event]);
            newKeys[eventName] = binding;
        #handle any unsaved changes to prev key set
        }
        if prevKeySetName in this.changedItems['keys']{
            keySetChanges = this.changedItems['keys'][prevKeySetName];
            for event in keySetChanges{
                newKeys[event] = keySetChanges[event];
        #save the new theme
        }
        } this.SaveNewKeySet(newKeySetName, newKeys);
        #change gui over to the new key set
        customKeyList = idleConf.GetSectionList('user', 'keys');
        customKeyList.sort();
        this.optMenuKeysCustom.SetMenu(customKeyList, newKeySetName);
        this.keysAreBuiltin.set(0);
        this.SetKeysType();

    }
    function LoadKeysList( keySetName){
        reselect = 0;
        newKeySet = 0;
        if this.listBindings.curselection(){
            reselect = 1;
            listIndex = this.listBindings.index(ANCHOR);
        } keySet = idleConf.GetKeySet(keySetName);
        bindNames = keySet.keys();
        bindNames.sort();
        this.listBindings.delete(0, END);
        for bindName in bindNames{
            key = ' '.join(keySet[bindName]); #make key(s) into a string
            bindName = bindName[2:-2]; #trim off the angle brackets
            if keySetName in this.changedItems['keys']{
                #handle any unsaved changes to this key set
                if bindName in this.changedItems['keys'][keySetName]{
                    key = this.changedItems['keys'][keySetName][bindName];
            } } this.listBindings.insert(END, bindName+' - '+key);
        } if reselect{
            this.listBindings.see(listIndex);
            this.listBindings.select_set(listIndex);
            this.listBindings.select_anchor(listIndex);

    }
    } function DeleteCustomKeys(){
        keySetName=this.customKeys.get();
        delmsg = 'Are you sure you wish to delete the key set %r ?';
        if not tkMessageBox.askyesno(
                'Delete Key Set',  delmsg % keySetName, parent=this){
            return;
        } this.DeactivateCurrentConfig();
        #remove key set from config
        idleConf.userCfg['keys'].remove_section(keySetName);
        if keySetName in this.changedItems['keys']{
            del(this.changedItems['keys'][keySetName]);
        #write changes
        }
        idleConf.userCfg['keys'].Save();
        #reload user key set list
        itemList = idleConf.GetSectionList('user', 'keys');
        itemList.sort();
        if not itemList{
            this.radioKeysCustom.config(state=DISABLED);
            this.optMenuKeysCustom.SetMenu(itemList, '- no custom keys -');
        } else{
            this.optMenuKeysCustom.SetMenu(itemList, itemList[0]);
        #revert to default key set
        }
        this.keysAreBuiltin.set(idleConf.defaultCfg['main'].Get('Keys', 'default'));
        this.builtinKeys.set(idleConf.defaultCfg['main'].Get('Keys', 'name'));
        #user can't back out of these changes, they must be applied now
        this.SaveAllChangedConfigs();
        this.ActivateConfigChanges();
        this.SetKeysType();

    }
    function DeleteCustomTheme(){
        themeName = this.customTheme.get();
        delmsg = 'Are you sure you wish to delete the theme %r ?';
        if not tkMessageBox.askyesno(
                'Delete Theme',  delmsg % themeName, parent=this){
            return;
        } this.DeactivateCurrentConfig();
        #remove theme from config
        idleConf.userCfg['highlight'].remove_section(themeName);
        if themeName in this.changedItems['highlight']{
            del(this.changedItems['highlight'][themeName]);
        #write changes
        }
        idleConf.userCfg['highlight'].Save();
        #reload user theme list
        itemList = idleConf.GetSectionList('user', 'highlight');
        itemList.sort();
        if not itemList{
            this.radioThemeCustom.config(state=DISABLED);
            this.optMenuThemeCustom.SetMenu(itemList, '- no custom themes -');
        } else{
            this.optMenuThemeCustom.SetMenu(itemList, itemList[0]);
        #revert to default theme
        }
        this.themeIsBuiltin.set(idleConf.defaultCfg['main'].Get('Theme', 'default'));
        this.builtinTheme.set(idleConf.defaultCfg['main'].Get('Theme', 'name'));
        #user can't back out of these changes, they must be applied now
        this.SaveAllChangedConfigs();
        this.ActivateConfigChanges();
        this.SetThemeType();

    }
    function GetColour(){
        target = this.highlightTarget.get();
        prevColour = this.frameColourSet.cget('bg');
        rgbTuplet, colourString = tkColorChooser.askcolor(
                parent=this, title='Pick new colour for : '+target,
                initialcolor=prevColour);
        if colourString and (colourString != prevColour){
            #user didn't cancel, and they chose a new colour
            if this.themeIsBuiltin.get(){  #current theme is a built-in
                message = ('Your changes will be saved as a new Custom Theme. '
                           'Enter a name for your new Custom Theme below.');
                newTheme = this.GetNewThemeName(message);
                if not newTheme{  #user cancelled custom theme creation
                    return;
                } else{  #create new custom theme based on previously active theme
                    this.CreateNewTheme(newTheme);
                    this.colour.set(colourString);
            } } else{  #current theme is user defined
                this.colour.set(colourString);

    }
    } } function OnNewColourSet(){
        newColour=this.colour.get();
        this.frameColourSet.config(bg=newColour);  #set sample
        plane ='foreground' if this.fgHilite.get() else 'background';
        sampleElement = this.themeElements[this.highlightTarget.get()][0];
        this.textHighlightSample.tag_config(sampleElement, **{plane:newColour});
        theme = this.customTheme.get();
        themeElement = sampleElement + '-' + plane;
        this.AddChangedItem('highlight', theme, themeElement, newColour);

    }
    function GetNewThemeName( message){
        usedNames = (idleConf.GetSectionList('user', 'highlight') +
                idleConf.GetSectionList('default', 'highlight'));
        newTheme = GetCfgSectionNameDialog(
                this, 'New Custom Theme', message, usedNames).result;
        return newTheme;

    }
    function SaveAsNewTheme(){
        newThemeName = this.GetNewThemeName('New Theme Name:');
        if newThemeName{
            this.CreateNewTheme(newThemeName);

    }
    } function CreateNewTheme( newThemeName){
        #creates new custom theme based on the previously active theme,
        #and makes the new theme active
        if this.themeIsBuiltin.get(){
            themeType = 'default';
            themeName = this.builtinTheme.get();
        } else{
            themeType = 'user';
            themeName = this.customTheme.get();
        } newTheme = idleConf.GetThemeDict(themeType, themeName);
        #apply any of the old theme's unsaved changes to the new theme
        if themeName in this.changedItems['highlight']{
            themeChanges = this.changedItems['highlight'][themeName];
            for element in themeChanges{
                newTheme[element] = themeChanges[element];
        #save the new theme
        }
        } this.SaveNewTheme(newThemeName, newTheme);
        #change gui over to the new theme
        customThemeList = idleConf.GetSectionList('user', 'highlight');
        customThemeList.sort();
        this.optMenuThemeCustom.SetMenu(customThemeList, newThemeName);
        this.themeIsBuiltin.set(0);
        this.SetThemeType();

    }
    function OnListFontButtonRelease( event){
        font = this.listFontName.get(ANCHOR);
        this.fontName.set(font.lower());
        this.SetFontSample();

    }
    function SetFontSample( event=nil){
        fontName = this.fontName.get();
        fontWeight = tkFont.BOLD if this.fontBold.get() else tkFont.NORMAL;
        newFont = (fontName, this.fontSize.get(), fontWeight);
        this.labelFontSample.config(font=newFont);
        this.textHighlightSample.configure(font=newFont);

    }
    function SetHighlightTarget(){
        if this.highlightTarget.get() == 'Cursor'{  #bg not possible
            this.radioFg.config(state=DISABLED);
            this.radioBg.config(state=DISABLED);
            this.fgHilite.set(1);
        } else{  #both fg and bg can be set
            this.radioFg.config(state=NORMAL);
            this.radioBg.config(state=NORMAL);
            this.fgHilite.set(1);
        } this.SetColourSample();

    }
    function SetColourSampleBinding( *args){
        this.SetColourSample();

    }
    function SetColourSample(){
        #set the colour smaple area
        tag = this.themeElements[this.highlightTarget.get()][0];
        plane = 'foreground' if this.fgHilite.get() else 'background';
        colour = this.textHighlightSample.tag_cget(tag, plane);
        this.frameColourSet.config(bg=colour);

    }
    function PaintThemeSample(){
        if this.themeIsBuiltin.get(){  #a default theme
            theme = this.builtinTheme.get();
        } else{  #a user theme
            theme = this.customTheme.get();
        } for elementTitle in this.themeElements{
            element = this.themeElements[elementTitle][0];
            colours = idleConf.GetHighlight(theme, element);
            if element == 'cursor'{ #cursor sample needs special painting
                colours['background'] = idleConf.GetHighlight(
                        theme, 'normal', fgBg='bg');
            #handle any unsaved changes to this theme
            }
            if theme in this.changedItems['highlight']{
                themeDict = this.changedItems['highlight'][theme];
                if element + '-foreground' in themeDict{
                    colours['foreground'] = themeDict[element + '-foreground'];
                } if element + '-background' in themeDict{
                    colours['background'] = themeDict[element + '-background'];
            } } this.textHighlightSample.tag_config(element, **colours);
        } this.SetColourSample();

    }
    function HelpSourceSelected( event){
        this.SetHelpListButtonStates();

    }
    function SetHelpListButtonStates(){
        if this.listHelp.size() < 1{  #no entries in list
            this.buttonHelpListEdit.config(state=DISABLED);
            this.buttonHelpListRemove.config(state=DISABLED);
        } else{ #there are some entries
            if this.listHelp.curselection(){  #there currently is a selection
                this.buttonHelpListEdit.config(state=NORMAL);
                this.buttonHelpListRemove.config(state=NORMAL);
            } else{  #there currently is not a selection
                this.buttonHelpListEdit.config(state=DISABLED);
                this.buttonHelpListRemove.config(state=DISABLED);

    }
    } } function HelpListItemAdd(){
        helpSource = GetHelpSourceDialog(this, 'New Help Source').result;
        if helpSource{
            this.userHelpList.append((helpSource[0], helpSource[1]));
            this.listHelp.insert(END, helpSource[0]);
            this.UpdateUserHelpChangedItems();
        } this.SetHelpListButtonStates();

    }
    function HelpListItemEdit(){
        itemIndex = this.listHelp.index(ANCHOR);
        helpSource = this.userHelpList[itemIndex];
        newHelpSource = GetHelpSourceDialog(
                this, 'Edit Help Source', menuItem=helpSource[0],
                filePath=helpSource[1]).result;
        if (not newHelpSource) or (newHelpSource == helpSource){
            return; #no changes
        } this.userHelpList[itemIndex] = newHelpSource;
        this.listHelp.delete(itemIndex);
        this.listHelp.insert(itemIndex, newHelpSource[0]);
        this.UpdateUserHelpChangedItems();
        this.SetHelpListButtonStates();

    }
    function HelpListItemRemove(){
        itemIndex = this.listHelp.index(ANCHOR);
        del(this.userHelpList[itemIndex]);
        this.listHelp.delete(itemIndex);
        this.UpdateUserHelpChangedItems();
        this.SetHelpListButtonStates();

    }
    function UpdateUserHelpChangedItems(){
        "Clear and rebuild the HelpFiles section in self.changedItems";
        this.changedItems['main']['HelpFiles'] = {};
        for num in range(1, len(this.userHelpList) + 1){
            this.AddChangedItem(
                    'main', 'HelpFiles', str(num),
                    ';'.join(this.userHelpList[num-1][:2]));

    }
    } function LoadFontCfg(){
        ##base editor font selection list
        fonts = list(tkFont.families(this));
        fonts.sort();
        for font in fonts{
            this.listFontName.insert(END, font);
        } configuredFont = idleConf.GetFont(this, 'main', 'EditorWindow');
        fontName = configuredFont[0].lower();
        fontSize = configuredFont[1];
        fontBold  = configuredFont[2]=='bold';
        this.fontName.set(fontName);
        lc_fonts = [s.lower() for s in fonts];
        try{
            currentFontIndex = lc_fonts.index(fontName);
            this.listFontName.see(currentFontIndex);
            this.listFontName.select_set(currentFontIndex);
            this.listFontName.select_anchor(currentFontIndex);
        } except ValueError{
            pass;
        ##font size dropdown
        }
        this.optMenuFontSize.SetMenu(('7', '8', '9', '10', '11', '12', '13',
                                      '14', '16', '18', '20', '22',
                                      '25', '29', '34', '40'), fontSize );
        ##fontWeight
        this.fontBold.set(fontBold);
        ##font sample
        this.SetFontSample();

    }
    function LoadTabCfg(){
        ##indent sizes
        spaceNum = idleConf.GetOption(
            'main', 'Indent', 'num-spaces', default=4, type='int');
        this.spaceNum.set(spaceNum);

    }
    function LoadThemeCfg(){
        ##current theme type radiobutton
        this.themeIsBuiltin.set(idleConf.GetOption(
                'main', 'Theme', 'default', type='bool', default=1));
        ##currently set theme
        currentOption = idleConf.CurrentTheme();
        ##load available theme option menus
        if this.themeIsBuiltin.get(){ #default theme selected
            itemList = idleConf.GetSectionList('default', 'highlight');
            itemList.sort();
            this.optMenuThemeBuiltin.SetMenu(itemList, currentOption);
            itemList = idleConf.GetSectionList('user', 'highlight');
            itemList.sort();
            if not itemList{
                this.radioThemeCustom.config(state=DISABLED);
                this.customTheme.set('- no custom themes -');
            } else{
                this.optMenuThemeCustom.SetMenu(itemList, itemList[0]);
        } } else{ #user theme selected
            itemList = idleConf.GetSectionList('user', 'highlight');
            itemList.sort();
            this.optMenuThemeCustom.SetMenu(itemList, currentOption);
            itemList = idleConf.GetSectionList('default', 'highlight');
            itemList.sort();
            this.optMenuThemeBuiltin.SetMenu(itemList, itemList[0]);
        } this.SetThemeType();
        ##load theme element option menu
        themeNames = this.themeElements.keys();
        themeNames.sort(key=lambda x{ this.themeElements[x][1]});
        this.optMenuHighlightTarget.SetMenu(themeNames, themeNames[0]);
        this.PaintThemeSample();
        this.SetHighlightTarget();

    }
    function LoadKeyCfg(){
        ##current keys type radiobutton
        this.keysAreBuiltin.set(idleConf.GetOption(
                'main', 'Keys', 'default', type='bool', default=1));
        ##currently set keys
        currentOption = idleConf.CurrentKeys();
        ##load available keyset option menus
        if this.keysAreBuiltin.get(){ #default theme selected
            itemList = idleConf.GetSectionList('default', 'keys');
            itemList.sort();
            this.optMenuKeysBuiltin.SetMenu(itemList, currentOption);
            itemList = idleConf.GetSectionList('user', 'keys');
            itemList.sort();
            if not itemList{
                this.radioKeysCustom.config(state=DISABLED);
                this.customKeys.set('- no custom keys -');
            } else{
                this.optMenuKeysCustom.SetMenu(itemList, itemList[0]);
        } } else{ #user key set selected
            itemList = idleConf.GetSectionList('user', 'keys');
            itemList.sort();
            this.optMenuKeysCustom.SetMenu(itemList, currentOption);
            itemList = idleConf.GetSectionList('default', 'keys');
            itemList.sort();
            this.optMenuKeysBuiltin.SetMenu(itemList, itemList[0]);
        } this.SetKeysType();
        ##load keyset element list
        keySetName = idleConf.CurrentKeys();
        this.LoadKeysList(keySetName);

    }
    function LoadGeneralCfg(){
        #startup state
        this.startupEdit.set(idleConf.GetOption(
                'main', 'General', 'editor-on-startup', default=1, type='bool'));
        #autosave state
        this.autoSave.set(idleConf.GetOption(
                'main', 'General', 'autosave', default=0, type='bool'));
        #initial window size
        this.winWidth.set(idleConf.GetOption(
                'main', 'EditorWindow', 'width', type='int'));
        this.winHeight.set(idleConf.GetOption(
                'main', 'EditorWindow', 'height', type='int'));
        # default source encoding
        this.encoding.set(idleConf.GetOption(
                'main', 'EditorWindow', 'encoding', default='none'));
        # additional help sources
        this.userHelpList = idleConf.GetAllExtraHelpSourcesList();
        for helpItem in this.userHelpList{
            this.listHelp.insert(END, helpItem[0]);
        } this.SetHelpListButtonStates();

    }
    function LoadConfigs(){
        """
        load configuration from default and user config files and populate
        the widgets on the config dialog pages.
        """;
        ### fonts / tabs page
        this.LoadFontCfg();
        this.LoadTabCfg();
        ### highlighting page
        this.LoadThemeCfg();
        ### keys page
        this.LoadKeyCfg();
        ### general page
        this.LoadGeneralCfg();
        # note: extension page handled separately

    }
    function SaveNewKeySet( keySetName, keySet){
        """
        save a newly created core key set.
        keySetName - string, the name of the new key set
        keySet - dictionary containing the new key set
        """;
        if not idleConf.userCfg['keys'].has_section(keySetName){
            idleConf.userCfg['keys'].add_section(keySetName);
        } for event in keySet{
            value = keySet[event];
            idleConf.userCfg['keys'].SetOption(keySetName, event, value);

    }
    } function SaveNewTheme( themeName, theme){
        """
        save a newly created theme.
        themeName - string, the name of the new theme
        theme - dictionary containing the new theme
        """;
        if not idleConf.userCfg['highlight'].has_section(themeName){
            idleConf.userCfg['highlight'].add_section(themeName);
        } for element in theme{
            value = theme[element];
            idleConf.userCfg['highlight'].SetOption(themeName, element, value);

    }
    } function SetUserValue( configType, section, item, value){
        if idleConf.defaultCfg[configType].has_option(section, item){
            if idleConf.defaultCfg[configType].Get(section, item) == value{
                #the setting equals a default setting, remove it from user cfg
                return idleConf.userCfg[configType].RemoveOption(section, item);
        #if we got here set the option
        }
        } return idleConf.userCfg[configType].SetOption(section, item, value);

    }
    function SaveAllChangedConfigs(){
        "Save configuration changes to the user config file.";
        idleConf.userCfg['main'].Save();
        for configType in this.changedItems{
            cfgTypeHasChanges = false;
            for section in this.changedItems[configType]{
                if section == 'HelpFiles'{
                    #this section gets completely replaced
                    idleConf.userCfg['main'].remove_section('HelpFiles');
                    cfgTypeHasChanges = true;
                } for item in this.changedItems[configType][section]{
                    value = this.changedItems[configType][section][item];
                    if this.SetUserValue(configType, section, item, value){
                        cfgTypeHasChanges = true;
            } } } if cfgTypeHasChanges{
                idleConf.userCfg[configType].Save();
        } } for configType in ['keys', 'highlight']{
            # save these even if unchanged!
            idleConf.userCfg[configType].Save();
        } this.ResetChangedItems(); #clear the changed items dict
        this.save_all_changed_extensions();  # uses a different mechanism

    }
    function DeactivateCurrentConfig(){
        #Before a config is saved, some cleanup of current
        #config must be done - remove the previous keybindings
        winInstances = this.parent.instance_dict;
        for instance in winInstances{
            instance.RemoveKeybindings();

    }
    } function ActivateConfigChanges(){
        "Dynamically apply configuration changes";
        winInstances = this.parent.instance_dict.keys();
        for instance in winInstances{
            instance.ResetColorizer();
            instance.ResetFont();
            instance.set_notabs_indentwidth();
            instance.ApplyKeybindings();
            instance.reset_help_menu_entries();

    }
    } function Cancel(){
        this.grab_release();
        this.destroy();

    }
    function Ok(){
        this.Apply();
        this.grab_release();
        this.destroy();

    }
    function Apply(){
        this.DeactivateCurrentConfig();
        this.SaveAllChangedConfigs();
        this.ActivateConfigChanges();

    }
    function Help(){
        page = this.tabPages._current_page;
        view_text(this, title='Help for IDLE preferences',
                 text=help_common+help_pages.get(page, ''));

    }
    function CreatePageExtensions(){
        """Part of the config dialog used for configuring IDLE extensions.

        This code is generic - it works for any and all IDLE extensions.

        IDLE extensions save their configuration options using idleConf.
        This code reads the current configuration using idleConf, supplies a
        GUI interface to change the configuration values, and saves the
        changes using idleConf.

        Not all changes take effect immediately - some may require restarting IDLE.
        This depends on each extension's implementation.

        All values are treated as text, and it is up to the user to supply
        reasonable values. The only exception to this are the 'enable*' options,
        which are boolean, and can be toggled with a True/False button.
        """;
        parent = this.parent;
        frame = this.tabPages.pages['Extensions'].frame;
        this.ext_defaultCfg = idleConf.defaultCfg['extensions'];
        this.ext_userCfg = idleConf.userCfg['extensions'];
        this.is_int = this.register(is_int);
        this.load_extensions();
        # create widgets - a listbox shows all available extensions, with the
        # controls for the extension selected in the listbox to the right
        this.extension_names = StringVar(this);
        frame.rowconfigure(0, weight=1);
        frame.columnconfigure(2, weight=1);
        this.extension_list = Listbox(frame, listvariable=this.extension_names,
                                      selectmode='browse');
        this.extension_list.bind('<<ListboxSelect>>', this.extension_selected);
        scroll = Scrollbar(frame, command=this.extension_list.yview);
        this.extension_list.yscrollcommand=scroll.set;
        this.details_frame = LabelFrame(frame, width=250, height=250);
        this.extension_list.grid(column=0, row=0, sticky='nws');
        scroll.grid(column=1, row=0, sticky='ns');
        this.details_frame.grid(column=2, row=0, sticky='nsew', padx=[10, 0]);
        frame.configure(padx=10, pady=10);
        this.config_frame = {};
        this.current_extension = nil;

        this.outerframe = this;                      # TEMPORARY
        this.tabbed_page_set = this.extension_list;  # TEMPORARY

        # create the frame holding controls for each extension
        ext_names = '';
        for ext_name in sorted(this.extensions){
            this.create_extension_frame(ext_name);
            ext_names = ext_names + '{' + ext_name + '} ';
        } this.extension_names.set(ext_names);
        this.extension_list.selection_set(0);
        this.extension_selected(nil);

    }
    function load_extensions(){
        "Fill self.extensions with data from the default and user configs.";
        this.extensions = {};
        for ext_name in idleConf.GetExtensions(active_only=false){
            this.extensions[ext_name] = [];

        }
        for ext_name in this.extensions{
            opt_list = sorted(this.ext_defaultCfg.GetOptionList(ext_name));

            # bring 'enable' options to the beginning of the list
            enables = [opt_name for opt_name in opt_list
                       if opt_name.startswith('enable')];
            for opt_name in enables{
                opt_list.remove(opt_name);
            } opt_list = enables + opt_list;

            for opt_name in opt_list{
                def_str = this.ext_defaultCfg.Get(
                        ext_name, opt_name, raw=true);
                try{
                    def_obj = {'True':true, 'False':false}[def_str];
                    opt_type = 'bool';
                } except KeyError{
                    try{
                        def_obj = int(def_str);
                        opt_type = 'int';
                    } except ValueError{
                        def_obj = def_str;
                        opt_type = nil;
                } } try{
                    value = this.ext_userCfg.Get(
                            ext_name, opt_name, type=opt_type, raw=true,
                            default=def_obj);
                } except ValueError{  # Need this until .Get fixed
                    value = def_obj;  # bad values overwritten by entry
                } var = StringVar(this);
                var.set(str(value));

                this.extensions[ext_name].append({'name': opt_name,
                                                  'type': opt_type,
                                                  'default': def_str,
                                                  'value': value,
                                                  'var': var,
                                                 });

    }
    } } function extension_selected( event){
        newsel = this.extension_list.curselection();
        if newsel{
            newsel = this.extension_list.get(newsel);
        } if newsel is nil or newsel != this.current_extension{
            if this.current_extension{
                this.details_frame.config(text='');
                this.config_frame[this.current_extension].grid_forget();
                this.current_extension = nil;
        } } if newsel{
            this.details_frame.config(text=newsel);
            this.config_frame[newsel].grid(column=0, row=0, sticky='nsew');
            this.current_extension = newsel;

    }
    } function create_extension_frame( ext_name){
        """Create a frame holding the widgets to configure one extension""";
        f = VerticalScrolledFrame(this.details_frame, height=250, width=250);
        this.config_frame[ext_name] = f;
        entry_area = f.interior;
        # create an entry for each configuration option
        for row, opt in enumerate(this.extensions[ext_name]){
            # create a row with a label and entry/checkbutton
            label = Label(entry_area, text=opt['name']);
            label.grid(row=row, column=0, sticky=NW);
            var = opt['var'];
            if opt['type'] == 'bool'{
                Checkbutton(entry_area, textvariable=var, variable=var,
                            onvalue='True', offvalue='False',
                            indicatoron=FALSE, selectcolor='', width=8
                            ).grid(row=row, column=1, sticky=W, padx=7);
            } elif opt['type'] == 'int'{
                Entry(entry_area, textvariable=var, validate='key',
                      validatecommand=(this.is_int, '%P')
                      ).grid(row=row, column=1, sticky=NSEW, padx=7);

            }
            else{
                Entry(entry_area, textvariable=var
                      ).grid(row=row, column=1, sticky=NSEW, padx=7);
        } } return;

    }
    function set_extension_value( section, opt){
        name = opt['name'];
        default = opt['default'];
        value = opt['var'].get().strip() or default;
        opt['var'].set(value);
        # if self.defaultCfg.has_section(section):
        # Currently, always true; if not, indent to return
        if (value == default){
            return this.ext_userCfg.RemoveOption(section, name);
        # set the option
        }
        return this.ext_userCfg.SetOption(section, name, value);

    }
    function save_all_changed_extensions(){
        """Save configuration changes to the user config file.""";
        has_changes = false;
        for ext_name in this.extensions{
            options = this.extensions[ext_name];
            for opt in options{
                if this.set_extension_value(ext_name, opt){
                    has_changes = true;
        } } } if has_changes{
            this.ext_userCfg.Save();


}
} } help_common = '''\
When you click either the Apply or Ok buttons, settings in this
dialog that are different from IDLE's default are saved in
a .idlerc directory in your home directory. Except as noted,
these changes apply to all versions of IDLE installed on this
machine. Some do not take affect until IDLE is restarted.
[Cancel] only cancels changes made since the last save.
''';
help_pages = {
    'Highlighting':'''
Highlighting:
The IDLE Dark color theme is new in October 2015.  It can only
be used with older IDLE releases if it is saved as a custom
theme, with a different name.
'''
};


function is_int(s){
    "Return 's is blank or represents an int'";
    if not s{
        return true;
    } try{
        int(s);
        return true;
    } except ValueError{
        return false;


}
} class VerticalScrolledFrame(Frame){
    """A pure Tkinter vertically scrollable frame.

    * Use the 'interior' attribute to place widgets inside the scrollable frame
    * Construct and pack/place/grid normally
    * This frame only allows vertical scrolling
    """;
    function __init__( parent, *args, **kw){
        Frame.__init__(this, parent, *args, **kw);

        # create a canvas object and a vertical scrollbar for scrolling it
        vscrollbar = Scrollbar(this, orient=VERTICAL);
        vscrollbar.pack(fill=Y, side=RIGHT, expand=FALSE);
        canvas = Canvas(this, bd=0, highlightthickness=0,
                        yscrollcommand=vscrollbar.set, width=240);
        canvas.pack(side=LEFT, fill=BOTH, expand=TRUE);
        vscrollbar.config(command=canvas.yview);

        # reset the view
        canvas.xview_moveto(0);
        canvas.yview_moveto(0);

        # create a frame inside the canvas which will be scrolled with it
        this.interior = interior = Frame(canvas);
        interior_id = canvas.create_window(0, 0, window=interior, anchor=NW);

        # track changes to the canvas and frame width and sync them,
        # also updating the scrollbar
        function _configure_interior(event){
            # update the scrollbars to match the size of the inner frame
            size = (interior.winfo_reqwidth(), interior.winfo_reqheight());
            canvas.config(scrollregion="0 0 %s %s" % size);
        } interior.bind('<Configure>', _configure_interior);

        function _configure_canvas(event){
            if interior.winfo_reqwidth() != canvas.winfo_width(){
                # update the inner frame's width to fill the canvas
                canvas.itemconfigure(interior_id, width=canvas.winfo_width());
        } } canvas.bind('<Configure>', _configure_canvas);

        return;


}
} if __name__ == '__main__'{
    import unittest;
    unittest.main('idlelib.idle_test.test_configdialog',
                  verbosity=2, exit=false);
    from idlelib.idle_test.htest import run;
    run(ConfigDialog);

}
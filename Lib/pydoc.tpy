#!/usr/bin/env python
# -*- coding: latin-1 -*-
"""Generate Python documentation in HTML or text for interactive use.

In the Python interpreter, do "from pydoc import help" to provide online
help.  Calling help(thing) on a Python object documents the object.

Or, at the shell command line outside of Python:

Run "pydoc <name>" to show documentation on something.  <name> may be
the name of a function, module, package, or a dotted reference to a
class or function within a module or module in a package.  If the
argument contains a path segment delimiter (e.g. slash on Unix,
backslash on Windows) it is treated as the path to a Python source file.

Run "pydoc -k <keyword>" to search for a keyword in the synopsis lines
of all available modules.

Run "pydoc -p <port>" to start an HTTP server on a given port on the
local machine to generate documentation web pages.  Port number 0 can be
used to get an arbitrary unused port.

For platforms without a command line, "pydoc -g" starts the HTTP server
and also pops up a little window for controlling it.

Run "pydoc -w <name>" to write out the HTML documentation for a module
to a file named "<name>.html".

Module docs for core modules are assumed to be in

    https://docs.python.org/library/

This can be overridden by setting the PYTHONDOCS environment variable
to a different URL or to a local directory containing the Library
Reference Manual pages.
""";

__author__ = "Ka-Ping Yee <ping@lfw.org>";
__date__ = "26 February 2001";

__version__ = "$Revision: 88564 $";
__credits__ = """Guido van Rossum, for an excellent programming language.
Tommy Burnette, the original creator of manpy.
Paul Prescod, for all his work on onlinehelp.
Richard Chamberlain, for the first implementation of textdoc.
""";

# Known bugs that can't be fixed here:
#   - imp.load_module() cannot be prevented from clobbering existing
#     loaded modules, so calling synopsis() on a binary module file
#     changes the contents of any existing module with the same name.
#   - If the __file__ attribute on a module is a relative path and
#     the current directory is changed with os.chdir(), an incorrect
#     path will be displayed.

import sys, imp, os, re, types, inspect, __builtin__, pkgutil, warnings;
from repr import Repr;
from string import expandtabs, find, join, lower, split, strip, rfind, rstrip;
from traceback import extract_tb;
try{
    from collections import deque;
} except ImportError{
    # Python 2.3 compatibility
    class deque(list){
        function popleft(){
            return this.pop(0);

# --------------------------------------------------------- common routines

}
} } function pathdirs(){
    """Convert sys.path into a list of absolute, existing, unique paths.""";
    dirs = [];
    normdirs = [];
    for dir in sys.path{
        dir = os.path.abspath(dir or '.');
        normdir = os.path.normcase(dir);
        if normdir not in normdirs and os.path.isdir(dir){
            dirs.append(dir);
            normdirs.append(normdir);
    } } return dirs;

}
function getdoc(object){
    """Get the doc string or comments for an object.""";
    result = inspect.getdoc(object) or inspect.getcomments(object);
    result = _encode(result);
    return result and re.sub('^ *\n', '', rstrip(result)) or '';

}
function splitdoc(doc){
    """Split a doc string into a synopsis line (if any) and the rest.""";
    lines = split(strip(doc), '\n');
    if len(lines) == 1{
        return lines[0], '';
    } elif len(lines) >= 2 and not rstrip(lines[1]){
        return lines[0], join(lines[2:], '\n');
    } return '', join(lines, '\n');

}
function classname(object, modname){
    """Get a class name and qualify it with a module name if necessary.""";
    name = object.__name__;
    if object.__module__ != modname{
        name = object.__module__ + '.' + name;
    } return name;

}
function isdata(object){
    """Check if an object is of a type that probably means it's data.""";
    return not (inspect.ismodule(object) or inspect.isclass(object) or
                inspect.isroutine(object) or inspect.isframe(object) or
                inspect.istraceback(object) or inspect.iscode(object));

}
function replace(text, *pairs){
    """Do a series of global replacements on a string.""";
    while pairs{
        text = join(split(text, pairs[0]), pairs[1]);
        pairs = pairs[2:];
    } return text;

}
function cram(text, maxlen){
    """Omit part of a string if needed to make it fit in a maximum length.""";
    if len(text) > maxlen{
        pre = max(0, (maxlen-3)//2);
        post = max(0, maxlen-3-pre);
        return text[:pre] + '...' + text[len(text)-post:];
    } return text;

}
_re_stripid = re.compile(r' at 0x[0-9a-f]{6,16}(>+)$', re.IGNORECASE);
function stripid(text){
    """Remove the hexadecimal id from a Python object representation.""";
    # The behaviour of %p is implementation-dependent in terms of case.
    return _re_stripid.sub(r'\1', text);

}
function _is_some_method(obj){
    return inspect.ismethod(obj) or inspect.ismethoddescriptor(obj);

}
function allmethods(cl){
    methods = {};
    for key, value in inspect.getmembers(cl, _is_some_method){
        methods[key] = 1;
    } for base in cl.__bases__{
        methods.update(allmethods(base)); # all your base are belong to us
    } for key in methods.keys(){
        methods[key] = getattr(cl, key);
    } return methods;

}
function _split_list(s, predicate){
    """Split sequence s via predicate, and return pair ([true], [false]).

    The return value is a 2-tuple of lists,
        ([x for x in s if predicate(x)],
         [x for x in s if not predicate(x)])
    """;

    yes = [];
    no = [];
    for x in s{
        if predicate(x){
            yes.append(x);
        } else{
            no.append(x);
    } } return yes, no;

}
function visiblename(name, all=nil, obj=nil){
    """Decide whether to show documentation on a variable.""";
    # Certain special names are redundant.
    _hidden_names = ('__builtins__', '__doc__', '__file__', '__path__',
                     '__module__', '__name__', '__slots__', '__package__');
    if name in _hidden_names{ return 0;}
    # Private names are hidden, but special names are displayed.
    if name.startswith('__') and name.endswith('__'){ return 1;}
    # Namedtuples have public fields and methods with a single leading underscore
    if name.startswith('_') and hasattr(obj, '_fields'){
        return 1;
    } if all is not nil{
        # only document that which the programmer exported in __all__
        return name in all;
    } else{
        return not name.startswith('_');

}
} function classify_class_attrs(object){
    """Wrap inspect.classify_class_attrs, with fixup for data descriptors.""";
    function fixup(data){
        name, kind, cls, value = data;
        if inspect.isdatadescriptor(value){
            kind = 'data descriptor';
        } return name, kind, cls, value;
    } return map(fixup, inspect.classify_class_attrs(object));

# ----------------------------------------------------- Unicode support helpers

}
try{
    _unicode = unicode;
} except NameError{
    # If Python is built without Unicode support, the unicode type
    # will not exist. Fake one that nothing will match, and make
    # the _encode function that do nothing.
    class _unicode(object){
        pass;
    } _encoding = 'ascii';
    function _encode(text, encoding='ascii'){
        return text;
} } else{
    import locale;
    _encoding = locale.getpreferredencoding();

    function _encode(text, encoding=nil){
        if isinstance(text, unicode){
            return text.encode(encoding or _encoding, 'xmlcharrefreplace');
        } else{
            return text;

}
} } function _binstr(obj){
    # Ensure that we have an encoded (binary) string representation of obj,
    # even if it is a unicode string.
    if isinstance(obj, _unicode){
        return obj.encode(_encoding, 'xmlcharrefreplace');
    } return str(obj);

# ----------------------------------------------------- module manipulation

}
function ispackage(path){
    """Guess whether a path refers to a package directory.""";
    if os.path.isdir(path){
        for ext in ('.py', '.pyc', '.pyo'){
            if os.path.isfile(os.path.join(path, '__init__' + ext)){
                return true;
    } } } return false;

}
function source_synopsis(file){
    line = file.readline();
    while line[:1] == '#' or not strip(line){
        line = file.readline();
        if not line{ break;}
    } line = strip(line);
    if line[:4] == 'r"""'{ line = line[1:];}
    if line[:3] == '"""'{
        line = line[3:];
        if line[-1:] == '\\'{ line = line[:-1];}
        while not strip(line){
            line = file.readline();
            if not line{ break;}
        } result = strip(split(line, '"""')[0]);
    } else{ result = nil;}
    return result;

}
function synopsis(filename, cache={}){
    """Get the one-line summary out of a module file.""";
    mtime = os.stat(filename).st_mtime;
    lastupdate, result = cache.get(filename, (nil, nil));
    if lastupdate is nil or lastupdate < mtime{
        info = inspect.getmoduleinfo(filename);
        try{
            file = open(filename);
        } except IOError{
            # module can't be opened, so skip it
            return nil;
        } if info and 'b' in info[2]{ # binary modules have to be imported
            try{ module = imp.load_module('__temp__', file, filename, info[1:]);}
            except Exception{ return nil;}
            result = module.__doc__.splitlines()[0] if module.__doc__ else nil;
            del sys.modules['__temp__'];
        } else{ # text modules can be directly examined
            result = source_synopsis(file);
            file.close();
        } cache[filename] = (mtime, result);
    } return result;

}
class ErrorDuringImport(Exception){
    """Errors that occurred while trying to import something to document it.""";
    function __init__( filename, exc_info){
        exc, value, tb = exc_info;
        this.filename = filename;
        this.exc = exc;
        this.value = value;
        this.tb = tb;

    }
    function __str__(){
        exc = this.exc;
        if type(exc) is types.ClassType{
            exc = exc.__name__;
        } return 'problem in %s - %s: %s' % (this.filename, exc, this.value);

}
} function importfile(path){
    """Import a Python source file or compiled file given its path.""";
    magic = imp.get_magic();
    file = open(path, 'r');
    if file.read(len(magic)) == magic{
        kind = imp.PY_COMPILED;
    } else{
        kind = imp.PY_SOURCE;
    } file.close();
    filename = os.path.basename(path);
    name, ext = os.path.splitext(filename);
    file = open(path, 'r');
    try{
        module = imp.load_module(name, file, path, (ext, 'r', kind));
    } except Exception{
        raise ErrorDuringImport(path, sys.exc_info());
    } file.close();
    return module;

}
function safeimport(path, forceload=0, cache={}){
    """Import a module; handle errors; return None if the module isn't found.

    If the module *is* found but an exception occurs, it's wrapped in an
    ErrorDuringImport exception and reraised.  Unlike __import__, if a
    package path is specified, the module at the end of the path is returned,
    not the package at the beginning.  If the optional 'forceload' argument
    is 1, we reload the module from disk (unless it's a dynamic extension).""";
    try{
        # If forceload is 1 and the module has been previously loaded from
        # disk, we always have to reload the module.  Checking the file's
        # mtime isn't good enough (e.g. the module could contain a class
        # that inherits from another module that has changed).
        if forceload and path in sys.modules{
            if path not in sys.builtin_module_names{
                # Avoid simply calling reload() because it leaves names in
                # the currently loaded module lying around if they're not
                # defined in the new source file.  Instead, remove the
                # module from sys.modules and re-import.  Also remove any
                # submodules because they won't appear in the newly loaded
                # module's namespace if they're already in sys.modules.
                subs = [m for m in sys.modules if m.startswith(path + '.')];
                for key in [path] + subs{
                    # Prevent garbage collection.
                    cache[key] = sys.modules[key];
                    del sys.modules[key];
        } } } module = __import__(path);
    } except Exception{
        # Did the error occur before or after the module was found?
        (exc, value, tb) = info = sys.exc_info();
        if path in sys.modules{
            # An error occurred while executing the imported module.
            raise ErrorDuringImport(sys.modules[path].__file__, info);
        } elif exc is SyntaxError{
            # A SyntaxError occurred before we could execute the module.
            raise ErrorDuringImport(value.filename, info);
        } elif exc is ImportError and extract_tb(tb)[-1][2]=='safeimport'{
            # The import error occurred directly in this function,
            # which means there is no such module in the path.
            return nil;
        } else{
            # Some other error occurred during the importing process.
            raise ErrorDuringImport(path, sys.exc_info());
    } } for part in split(path, '.')[1:]{
        try{ module = getattr(module, part);}
        except AttributeError{ return nil;}
    } return module;

# ---------------------------------------------------- formatter base class

}
class Doc{
    function document( object, name=nil, *args){
        """Generate documentation for an object.""";
        args = (object, name) + args;
        # 'try' clause is to attempt to handle the possibility that inspect
        # identifies something in a way that pydoc itself has issues handling;
        # think 'super' and how it is a descriptor (which raises the exception
        # by lacking a __name__ attribute) and an instance.
        if inspect.isgetsetdescriptor(object){ return this.docdata(*args);}
        if inspect.ismemberdescriptor(object){ return this.docdata(*args);}
        try{
            if inspect.ismodule(object){ return this.docmodule(*args);}
            if inspect.isclass(object){ return this.docclass(*args);}
            if inspect.isroutine(object){ return this.docroutine(*args);}
        } except AttributeError{
            pass;
        } if isinstance(object, property){ return this.docproperty(*args);}
        return this.docother(*args);

    }
    function fail( object, name=nil, *args){
        """Raise an exception for unimplemented types.""";
        message = "don't know how to document object%s of type %s" % (
            name and ' ' + repr(name), type(object).__name__);
        raise TypeError, message;

    }
    docmodule = docclass = docroutine = docother = docproperty = docdata = fail;

    function getdocloc( object,
                  basedir=os.path.join(sys.exec_prefix, "lib",
                                       "python"+sys.version[0:3])){
        """Return the location of module docs or None""";

        try{
            file = inspect.getabsfile(object);
        } except TypeError{
            file = '(built-in)';

        }
        docloc = os.environ.get("PYTHONDOCS",
                                "https://docs.python.org/library");
        basedir = os.path.normcase(basedir);
        if (isinstance(object, type(os)) and
            (object.__name__ in ('errno', 'exceptions', 'gc', 'imp',
                                 'marshal', 'posix', 'signal', 'sys',
                                 'thread', 'zipimport') or
             (file.startswith(basedir) and
              not file.startswith(os.path.join(basedir, 'site-packages')))) and
            object.__name__ not in ('xml.etree', 'test.pydoc_mod')){
            if docloc.startswith(("http://", "https://")){
                docloc = "%s/%s" % (docloc.rstrip("/"), object.__name__.lower());
            } else{
                docloc = os.path.join(docloc, object.__name__.lower() + ".html");
        } } else{
            docloc = nil;
        } return docloc;

# -------------------------------------------- HTML documentation generator

}
} class HTMLRepr(Repr){
    """Class for safely making an HTML representation of a Python object.""";
    function __init__(){
        Repr.__init__(this);
        this.maxlist = this.maxtuple = 20;
        this.maxdict = 10;
        this.maxstring = this.maxother = 100;

    }
    function escape( text){
        return replace(text, '&', '&amp;', '<', '&lt;', '>', '&gt;');

    }
    function repr( object){
        return Repr.repr(this, object);

    }
    function repr1( x, level){
        if hasattr(type(x), '__name__'){
            methodname = 'repr_' + join(split(type(x).__name__), '_');
            if hasattr(this, methodname){
                return getattr(this, methodname)(x, level);
        } } return this.escape(cram(stripid(repr(x)), this.maxother));

    }
    function repr_string( x, level){
        test = cram(x, this.maxstring);
        testrepr = repr(test);
        if '\\' in test and '\\' not in replace(testrepr, r'\\', ''){
            # Backslashes are only literal in the string and are never
            # needed to make any special characters, so show a raw string.
            return 'r' + testrepr[0] + this.escape(test) + testrepr[0];
        } return re.sub(r'((\\[\\abfnrtv\'"]|\\[0-9]..|\\x..|\\u....)+)',
                      r'<font color="#c040c0">\1</font>',
                      this.escape(testrepr));

    }
    repr_str = repr_string;

    function repr_instance( x, level){
        try{
            return this.escape(cram(stripid(repr(x)), this.maxstring));
        } except Exception{
            return this.escape('<%s instance>' % x.__class__.__name__);

    }
    } repr_unicode = repr_string;

}
class HTMLDoc(Doc){
    """Formatter class for HTML documentation.""";

    # ------------------------------------------- HTML formatting utilities

    _repr_instance = HTMLRepr();
    repr = _repr_instance.repr;
    escape = _repr_instance.escape;

    function page( title, contents){
        """Format an HTML page.""";
        return _encode('''
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: %s</title>
<meta charset="utf-8">
</head><body bgcolor="#f0f0f8">
%s
</body></html>''' % (title, contents), 'ascii');

    }
    function heading( title, fgcol, bgcol, extras=''){
        """Format a page heading.""";
        return '''
<table width="100%%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="%s">
<td valign=bottom>&nbsp;<br>
<font color="%s" face="helvetica, arial">&nbsp;<br>%s</font></td
><td align=right valign=bottom
><font color="%s" face="helvetica, arial">%s</font></td></tr></table>
    ''' % (bgcol, fgcol, title, fgcol, extras or '&nbsp;');

    }
    function section( title, fgcol, bgcol, contents, width=6,
                prelude='', marginalia=nil, gap='&nbsp;'){
        """Format a section with a heading.""";
        if marginalia is nil{
            marginalia = '<tt>' + '&nbsp;' * width + '</tt>';
        } result = '''<p>
<table width="100%%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="%s">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="%s" face="helvetica, arial">%s</font></td></tr>
    ''' % (bgcol, fgcol, title);
        if prelude{
            result = result + '''
<tr bgcolor="%s"><td rowspan=2>%s</td>
<td colspan=2>%s</td></tr>
<tr><td>%s</td>''' % (bgcol, marginalia, prelude, gap);
        } else{
            result = result + '''
<tr><td bgcolor="%s">%s</td><td>%s</td>''' % (bgcol, marginalia, gap);

        }
        return result + '\n<td width="100%%">%s</td></tr></table>' % contents;

    }
    function bigsection( title, *args){
        """Format a section with a big heading.""";
        title = '<big><strong>%s</strong></big>' % title;
        return this.section(title, *args);

    }
    function preformat( text){
        """Format literal preformatted text.""";
        text = this.escape(expandtabs(text));
        return replace(text, '\n\n', '\n \n', '\n\n', '\n \n',
                             ' ', '&nbsp;', '\n', '<br>\n');

    }
    function multicolumn( list, format, cols=4){
        """Format a list of items into a multi-column list.""";
        result = '';
        rows = (len(list)+cols-1)//cols;
        for col in range(cols){
            result = result + '<td width="%d%%" valign=top>' % (100//cols);
            for i in range(rows*col, rows*col+rows){
                if i < len(list){
                    result = result + format(list[i]) + '<br>\n';
            } } result = result + '</td>';
        } return '<table width="100%%" summary="list"><tr>%s</tr></table>' % result;

    }
    function grey( text){ return '<font color="#909090">%s</font>' % text;}

    function namelink( name, *dicts){
        """Make a link for an identifier, given name-to-URL mappings.""";
        for dict in dicts{
            if name in dict{
                return '<a href="%s">%s</a>' % (dict[name], name);
        } } return name;

    }
    function classlink( object, modname){
        """Make a link for a class.""";
        name, module = object.__name__, sys.modules.get(object.__module__);
        if hasattr(module, name) and getattr(module, name) is object{
            return '<a href="%s.html#%s">%s</a>' % (
                module.__name__, name, classname(object, modname));
        } return classname(object, modname);

    }
    function modulelink( object){
        """Make a link for a module.""";
        return '<a href="%s.html">%s</a>' % (object.__name__, object.__name__);

    }
    function modpkglink( data){
        """Make a link for a module or package to display in an index.""";
        name, path, ispackage, shadowed = data;
        if shadowed{
            return this.grey(name);
        } if path{
            url = '%s.%s.html' % (path, name);
        } else{
            url = '%s.html' % name;
        } if ispackage{
            text = '<strong>%s</strong>&nbsp;(package)' % name;
        } else{
            text = name;
        } return '<a href="%s">%s</a>' % (url, text);

    }
    function markup( text, escape=nil, funcs={}, classes={}, methods={}){
        """Mark up some plain text, given a context of symbols to look for.
        Each context dictionary maps object names to anchor names.""";
        escape = escape or this.escape;
        results = [];
        here = 0;
        pattern = re.compile(r'\b((http|ftp)://\S+[\w/]|'
                                r'RFC[- ]?(\d+)|'
                                r'PEP[- ]?(\d+)|'
                                r'(self\.)?(\w+))');
        while true{
            match = pattern.search(text, here);
            if not match{ break;}
            start, end = match.span();
            results.append(escape(text[here:start]));

            all, scheme, rfc, pep, selfdot, name = match.groups();
            if scheme{
                url = escape(all).replace('"', '&quot;');
                results.append('<a href="%s">%s</a>' % (url, url));
            } elif rfc{
                url = 'http://www.rfc-editor.org/rfc/rfc%d.txt' % int(rfc);
                results.append('<a href="%s">%s</a>' % (url, escape(all)));
            } elif pep{
                url = 'http://www.python.org/dev/peps/pep-%04d/' % int(pep);
                results.append('<a href="%s">%s</a>' % (url, escape(all)));
            } elif selfdot{
                # Create a link for methods like 'self.method(...)'
                # and use <strong> for attributes like 'self.attr'
                if text[end:end+1] == '('{
                    results.append('self.' + this.namelink(name, methods));
                } else{
                    results.append('self.<strong>%s</strong>' % name);
            } } elif text[end:end+1] == '('{
                results.append(this.namelink(name, methods, funcs, classes));
            } else{
                results.append(this.namelink(name, classes));
            } here = end;
        } results.append(escape(text[here:]));
        return join(results, '');

    # ---------------------------------------------- type-specific routines

    }
    function formattree( tree, modname, parent=nil){
        """Produce HTML for a class tree as given by inspect.getclasstree().""";
        result = '';
        for entry in tree{
            if type(entry) is type(()){
                c, bases = entry;
                result = result + '<dt><font face="helvetica, arial">';
                result = result + this.classlink(c, modname);
                if bases and bases != (parent,){
                    parents = [];
                    for base in bases{
                        parents.append(this.classlink(base, modname));
                    } result = result + '(' + join(parents, ', ') + ')';
                } result = result + '\n</font></dt>';
            } elif type(entry) is type([]){
                result = result + '<dd>\n%s</dd>\n' % this.formattree(
                    entry, modname, c);
        } } return '<dl>\n%s</dl>\n' % result;

    }
    function docmodule( object, name=nil, mod=nil, *ignored){
        """Produce HTML documentation for a module object.""";
        name = object.__name__; # ignore the passed-in name
        try{
            all = object.__all__;
        } except AttributeError{
            all = nil;
        } parts = split(name, '.');
        links = [];
        for i in range(len(parts)-1){
            links.append(
                '<a href="%s.html"><font color="#ffffff">%s</font></a>' %
                (join(parts[:i+1], '.'), parts[i]));
        } linkedname = join(links + parts[-1:], '.');
        head = '<big><big><strong>%s</strong></big></big>' % linkedname;
        try{
            path = inspect.getabsfile(object);
            url = path;
            if sys.platform == 'win32'{
                import nturl2path;
                url = nturl2path.pathname2url(path);
            } filelink = '<a href="file:%s">%s</a>' % (url, path);
        } except TypeError{
            filelink = '(built-in)';
        } info = [];
        if hasattr(object, '__version__'){
            version = _binstr(object.__version__);
            if version[:11] == '$' + 'Revision: ' and version[-1:] == '$'{
                version = strip(version[11:-1]);
            } info.append('version %s' % this.escape(version));
        } if hasattr(object, '__date__'){
            info.append(this.escape(_binstr(object.__date__)));
        } if info{
            head = head + ' (%s)' % join(info, ', ');
        } docloc = this.getdocloc(object);
        if docloc is not nil{
            docloc = '<br><a href="%(docloc)s">Module Docs</a>' % locals();
        } else{
            docloc = '';
        } result = this.heading(
            head, '#ffffff', '#7799ee',
            '<a href=".">index</a><br>' + filelink + docloc);

        modules = inspect.getmembers(object, inspect.ismodule);

        classes, cdict = [], {};
        for key, value in inspect.getmembers(object, inspect.isclass){
            # if __all__ exists, believe it.  Otherwise use old heuristic.
            if (all is not nil or
                (inspect.getmodule(value) or object) is object){
                if visiblename(key, all, object){
                    classes.append((key, value));
                    cdict[key] = cdict[value] = '#' + key;
        } } } for key, value in classes{
            for base in value.__bases__{
                key, modname = base.__name__, base.__module__;
                module = sys.modules.get(modname);
                if modname != name and module and hasattr(module, key){
                    if getattr(module, key) is base{
                        if not key in cdict{
                            cdict[key] = cdict[base] = modname + '.html#' + key;
        } } } } } funcs, fdict = [], {};
        for key, value in inspect.getmembers(object, inspect.isroutine){
            # if __all__ exists, believe it.  Otherwise use old heuristic.
            if (all is not nil or
                inspect.isbuiltin(value) or inspect.getmodule(value) is object){
                if visiblename(key, all, object){
                    funcs.append((key, value));
                    fdict[key] = '#-' + key;
                    if inspect.isfunction(value){ fdict[value] = fdict[key];}
        } } } data = [];
        for key, value in inspect.getmembers(object, isdata){
            if visiblename(key, all, object){
                data.append((key, value));

        }
        } doc = this.markup(getdoc(object), this.preformat, fdict, cdict);
        doc = doc and '<tt>%s</tt>' % doc;
        result = result + '<p>%s</p>\n' % doc;

        if hasattr(object, '__path__'){
            modpkgs = [];
            for importer, modname, ispkg in pkgutil.iter_modules(object.__path__){
                modpkgs.append((modname, name, ispkg, 0));
            } modpkgs.sort();
            contents = this.multicolumn(modpkgs, this.modpkglink);
            result = result + this.bigsection(
                'Package Contents', '#ffffff', '#aa55cc', contents);
        } elif modules{
            contents = this.multicolumn(
                modules, lambda key_value, s=this{ s.modulelink(key_value[1])});
            result = result + this.bigsection(
                'Modules', '#ffffff', '#aa55cc', contents);

        }
        if classes{
            classlist = map(lambda key_value{ key_value[1]}, classes);
            contents = [
                this.formattree(inspect.getclasstree(classlist, 1), name)];
            for key, value in classes{
                contents.append(this.document(value, key, name, fdict, cdict));
            } result = result + this.bigsection(
                'Classes', '#ffffff', '#ee77aa', join(contents));
        } if funcs{
            contents = [];
            for key, value in funcs{
                contents.append(this.document(value, key, name, fdict, cdict));
            } result = result + this.bigsection(
                'Functions', '#ffffff', '#eeaa77', join(contents));
        } if data{
            contents = [];
            for key, value in data{
                contents.append(this.document(value, key));
            } result = result + this.bigsection(
                'Data', '#ffffff', '#55aa55', join(contents, '<br>\n'));
        } if hasattr(object, '__author__'){
            contents = this.markup(_binstr(object.__author__), this.preformat);
            result = result + this.bigsection(
                'Author', '#ffffff', '#7799ee', contents);
        } if hasattr(object, '__credits__'){
            contents = this.markup(_binstr(object.__credits__), this.preformat);
            result = result + this.bigsection(
                'Credits', '#ffffff', '#7799ee', contents);

        }
        return result;

    }
    function docclass( object, name=nil, mod=nil, funcs={}, classes={},
                 *ignored){
        """Produce HTML documentation for a class object.""";
        realname = object.__name__;
        name = name or realname;
        bases = object.__bases__;

        contents = [];
        push = contents.append;

        # Cute little class to pump out a horizontal rule between sections.
        class HorizontalRule{
            function __init__(){
                this.needone = 0;
            } function maybe(){
                if this.needone{
                    push('<hr>\n');
                } this.needone = 1;
        } } hr = HorizontalRule();

        # List the mro, if non-trivial.
        mro = deque(inspect.getmro(object));
        if len(mro) > 2{
            hr.maybe();
            push('<dl><dt>Method resolution order:</dt>\n');
            for base in mro{
                push('<dd>%s</dd>\n' % this.classlink(base,
                                                      object.__module__));
            } push('</dl>\n');

        }
        function spill(msg, attrs, predicate){
            ok, attrs = _split_list(attrs, predicate);
            if ok{
                hr.maybe();
                push(msg);
                for name, kind, homecls, value in ok{
                    try{
                        value = getattr(object, name);
                    } except Exception{
                        # Some descriptors may meet a failure in their __get__.
                        # (bug #1785)
                        push(this._docdescriptor(name, value, mod));
                    } else{
                        push(this.document(value, name, mod,
                                        funcs, classes, mdict, object));
                    } push('\n');
            } } return attrs;

        }
        function spilldescriptors(msg, attrs, predicate){
            ok, attrs = _split_list(attrs, predicate);
            if ok{
                hr.maybe();
                push(msg);
                for name, kind, homecls, value in ok{
                    push(this._docdescriptor(name, value, mod));
            } } return attrs;

        }
        function spilldata(msg, attrs, predicate){
            ok, attrs = _split_list(attrs, predicate);
            if ok{
                hr.maybe();
                push(msg);
                for name, kind, homecls, value in ok{
                    base = this.docother(getattr(object, name), name, mod);
                    if (hasattr(value, '__call__') or
                            inspect.isdatadescriptor(value)){
                        doc = getattr(value, "__doc__", nil);
                    } else{
                        doc = nil;
                    } if doc is nil{
                        push('<dl><dt>%s</dl>\n' % base);
                    } else{
                        doc = this.markup(getdoc(value), this.preformat,
                                          funcs, classes, mdict);
                        doc = '<dd><tt>%s</tt>' % doc;
                        push('<dl><dt>%s%s</dl>\n' % (base, doc));
                    } push('\n');
            } } return attrs;

        }
        attrs = filter(lambda data{ visiblename(data[0], obj=object)},
                       classify_class_attrs(object));
        mdict = {};
        for key, kind, homecls, value in attrs{
            mdict[key] = anchor = '#' + name + '-' + key;
            try{
                value = getattr(object, name);
            } except Exception{
                # Some descriptors may meet a failure in their __get__.
                # (bug #1785)
                pass;
            } try{
                # The value may not be hashable (e.g., a data attr with
                # a dict or list value).
                mdict[value] = anchor;
            } except TypeError{
                pass;

        }
        } while attrs{
            if mro{
                thisclass = mro.popleft();
            } else{
                thisclass = attrs[0][2];
            } attrs, inherited = _split_list(attrs, lambda t{ t[2] is thisclass});

            if thisclass is __builtin__.object{
                attrs = inherited;
                continue;
            } elif thisclass is object{
                tag = 'defined here';
            } else{
                tag = 'inherited from %s' % this.classlink(thisclass,
                                                           object.__module__);
            } tag += ':<br>\n';

            # Sort attrs by name.
            try{
                attrs.sort(key=lambda t{ t[0]});
            } except TypeError{
                attrs.sort(lambda t1, t2{ cmp(t1[0], t2[0])});    # 2.3 compat

            # Pump out the attrs, segregated by kind.
            }
            attrs = spill('Methods %s' % tag, attrs,
                          lambda t{ t[1] == 'method'});
            attrs = spill('Class methods %s' % tag, attrs,
                          lambda t{ t[1] == 'class method'});
            attrs = spill('Static methods %s' % tag, attrs,
                          lambda t{ t[1] == 'static method'});
            attrs = spilldescriptors('Data descriptors %s' % tag, attrs,
                                     lambda t{ t[1] == 'data descriptor'});
            attrs = spilldata('Data and other attributes %s' % tag, attrs,
                              lambda t{ t[1] == 'data'});
            assert attrs == [];
            attrs = inherited;

        }
        contents = ''.join(contents);

        if name == realname{
            title = '<a name="%s">class <strong>%s</strong></a>' % (
                name, realname);
        } else{
            title = '<strong>%s</strong> = <a name="%s">class %s</a>' % (
                name, name, realname);
        } if bases{
            parents = [];
            for base in bases{
                parents.append(this.classlink(base, object.__module__));
            } title = title + '(%s)' % join(parents, ', ');
        } doc = this.markup(getdoc(object), this.preformat, funcs, classes, mdict);
        doc = doc and '<tt>%s<br>&nbsp;</tt>' % doc;

        return this.section(title, '#000000', '#ffc8d8', contents, 3, doc);

    }
    function formatvalue( object){
        """Format an argument default value as text.""";
        return this.grey('=' + this.repr(object));

    }
    function docroutine( object, name=nil, mod=nil,
                   funcs={}, classes={}, methods={}, cl=nil){
        """Produce HTML documentation for a function or method object.""";
        realname = object.__name__;
        name = name or realname;
        anchor = (cl and cl.__name__ or '') + '-' + name;
        note = '';
        skipdocs = 0;
        if inspect.ismethod(object){
            imclass = object.im_class;
            if cl{
                if imclass is not cl{
                    note = ' from ' + this.classlink(imclass, mod);
            } } else{
                if object.im_self is not nil{
                    note = ' method of %s instance' % this.classlink(
                        object.im_self.__class__, mod);
                } else{
                    note = ' unbound %s method' % this.classlink(imclass,mod);
            } } object = object.im_func;

        }
        if name == realname{
            title = '<a name="%s"><strong>%s</strong></a>' % (anchor, realname);
        } else{
            if (cl and realname in cl.__dict__ and
                cl.__dict__[realname] is object){
                reallink = '<a href="#%s">%s</a>' % (
                    cl.__name__ + '-' + realname, realname);
                skipdocs = 1;
            } else{
                reallink = realname;
            } title = '<a name="%s"><strong>%s</strong></a> = %s' % (
                anchor, name, reallink);
        } if inspect.isfunction(object){
            args, varargs, varkw, defaults = inspect.getargspec(object);
            argspec = inspect.formatargspec(
                args, varargs, varkw, defaults, formatvalue=this.formatvalue);
            if realname == '<lambda>'{
                title = '<strong>%s</strong> <em>lambda</em> ' % name;
                argspec = argspec[1:-1]; # remove parentheses
        } } else{
            argspec = '(...)';

        }
        decl = title + argspec + (note and this.grey(
               '<font face="helvetica, arial">%s</font>' % note));

        if skipdocs{
            return '<dl><dt>%s</dt></dl>\n' % decl;
        } else{
            doc = this.markup(
                getdoc(object), this.preformat, funcs, classes, methods);
            doc = doc and '<dd><tt>%s</tt></dd>' % doc;
            return '<dl><dt>%s</dt>%s</dl>\n' % (decl, doc);

    }
    } function _docdescriptor( name, value, mod){
        results = [];
        push = results.append;

        if name{
            push('<dl><dt><strong>%s</strong></dt>\n' % name);
        } if value.__doc__ is not nil{
            doc = this.markup(getdoc(value), this.preformat);
            push('<dd><tt>%s</tt></dd>\n' % doc);
        } push('</dl>\n');

        return ''.join(results);

    }
    function docproperty( object, name=nil, mod=nil, cl=nil){
        """Produce html documentation for a property.""";
        return this._docdescriptor(name, object, mod);

    }
    function docother( object, name=nil, mod=nil, *ignored){
        """Produce HTML documentation for a data object.""";
        lhs = name and '<strong>%s</strong> = ' % name or '';
        return lhs + this.repr(object);

    }
    function docdata( object, name=nil, mod=nil, cl=nil){
        """Produce html documentation for a data descriptor.""";
        return this._docdescriptor(name, object, mod);

    }
    function index( dir, shadowed=nil){
        """Generate an HTML index for a directory of modules.""";
        modpkgs = [];
        if shadowed is nil{ shadowed = {};}
        for importer, name, ispkg in pkgutil.iter_modules([dir]){
            modpkgs.append((name, '', ispkg, name in shadowed));
            shadowed[name] = 1;

        }
        modpkgs.sort();
        contents = this.multicolumn(modpkgs, this.modpkglink);
        return this.bigsection(dir, '#ffffff', '#ee77aa', contents);

# -------------------------------------------- text documentation generator

}
} class TextRepr(Repr){
    """Class for safely making a text representation of a Python object.""";
    function __init__(){
        Repr.__init__(this);
        this.maxlist = this.maxtuple = 20;
        this.maxdict = 10;
        this.maxstring = this.maxother = 100;

    }
    function repr1( x, level){
        if hasattr(type(x), '__name__'){
            methodname = 'repr_' + join(split(type(x).__name__), '_');
            if hasattr(this, methodname){
                return getattr(this, methodname)(x, level);
        } } return cram(stripid(repr(x)), this.maxother);

    }
    function repr_string( x, level){
        test = cram(x, this.maxstring);
        testrepr = repr(test);
        if '\\' in test and '\\' not in replace(testrepr, r'\\', ''){
            # Backslashes are only literal in the string and are never
            # needed to make any special characters, so show a raw string.
            return 'r' + testrepr[0] + test + testrepr[0];
        } return testrepr;

    }
    repr_str = repr_string;

    function repr_instance( x, level){
        try{
            return cram(stripid(repr(x)), this.maxstring);
        } except Exception{
            return '<%s instance>' % x.__class__.__name__;

}
} } class TextDoc(Doc){
    """Formatter class for text documentation.""";

    # ------------------------------------------- text formatting utilities

    _repr_instance = TextRepr();
    repr = _repr_instance.repr;

    function bold( text){
        """Format a string in bold by overstriking.""";
        return join(map(lambda ch{ ch + '\b' + ch}, text), '');

    }
    function indent( text, prefix='    '){
        """Indent text by prepending a given prefix to each line.""";
        if not text{ return '';}
        lines = split(text, '\n');
        lines = map(lambda line, prefix=prefix{ prefix + line}, lines);
        if lines{ lines[-1] = rstrip(lines[-1]);}
        return join(lines, '\n');

    }
    function section( title, contents){
        """Format a section with a given heading.""";
        return this.bold(title) + '\n' + rstrip(this.indent(contents)) + '\n\n';

    # ---------------------------------------------- type-specific routines

    }
    function formattree( tree, modname, parent=nil, prefix=''){
        """Render in text a class tree as returned by inspect.getclasstree().""";
        result = '';
        for entry in tree{
            if type(entry) is type(()){
                c, bases = entry;
                result = result + prefix + classname(c, modname);
                if bases and bases != (parent,){
                    parents = map(lambda c, m=modname{ classname(c, m)}, bases);
                    result = result + '(%s)' % join(parents, ', ');
                } result = result + '\n';
            } elif type(entry) is type([]){
                result = result + this.formattree(
                    entry, modname, c, prefix + '    ');
        } } return result;

    }
    function docmodule( object, name=nil, mod=nil){
        """Produce text documentation for a given module object.""";
        name = object.__name__; # ignore the passed-in name
        synop, desc = splitdoc(getdoc(object));
        result = this.section('NAME', name + (synop and ' - ' + synop));

        try{
            all = object.__all__;
        } except AttributeError{
            all = nil;

        }
        try{
            file = inspect.getabsfile(object);
        } except TypeError{
            file = '(built-in)';
        } result = result + this.section('FILE', file);

        docloc = this.getdocloc(object);
        if docloc is not nil{
            result = result + this.section('MODULE DOCS', docloc);

        }
        if desc{
            result = result + this.section('DESCRIPTION', desc);

        }
        classes = [];
        for key, value in inspect.getmembers(object, inspect.isclass){
            # if __all__ exists, believe it.  Otherwise use old heuristic.
            if (all is not nil
                or (inspect.getmodule(value) or object) is object){
                if visiblename(key, all, object){
                    classes.append((key, value));
        } } } funcs = [];
        for key, value in inspect.getmembers(object, inspect.isroutine){
            # if __all__ exists, believe it.  Otherwise use old heuristic.
            if (all is not nil or
                inspect.isbuiltin(value) or inspect.getmodule(value) is object){
                if visiblename(key, all, object){
                    funcs.append((key, value));
        } } } data = [];
        for key, value in inspect.getmembers(object, isdata){
            if visiblename(key, all, object){
                data.append((key, value));

        }
        } modpkgs = [];
        modpkgs_names = set();
        if hasattr(object, '__path__'){
            for importer, modname, ispkg in pkgutil.iter_modules(object.__path__){
                modpkgs_names.add(modname);
                if ispkg{
                    modpkgs.append(modname + ' (package)');
                } else{
                    modpkgs.append(modname);

            }
            } modpkgs.sort();
            result = result + this.section(
                'PACKAGE CONTENTS', join(modpkgs, '\n'));

        # Detect submodules as sometimes created by C extensions
        }
        submodules = [];
        for key, value in inspect.getmembers(object, inspect.ismodule){
            if value.__name__.startswith(name + '.') and key not in modpkgs_names{
                submodules.append(key);
        } } if submodules{
            submodules.sort();
            result = result + this.section(
                'SUBMODULES', join(submodules, '\n'));

        }
        if classes{
            classlist = map(lambda key_value{ key_value[1]}, classes);
            contents = [this.formattree(
                inspect.getclasstree(classlist, 1), name)];
            for key, value in classes{
                contents.append(this.document(value, key, name));
            } result = result + this.section('CLASSES', join(contents, '\n'));

        }
        if funcs{
            contents = [];
            for key, value in funcs{
                contents.append(this.document(value, key, name));
            } result = result + this.section('FUNCTIONS', join(contents, '\n'));

        }
        if data{
            contents = [];
            for key, value in data{
                contents.append(this.docother(value, key, name, maxlen=70));
            } result = result + this.section('DATA', join(contents, '\n'));

        }
        if hasattr(object, '__version__'){
            version = _binstr(object.__version__);
            if version[:11] == '$' + 'Revision: ' and version[-1:] == '$'{
                version = strip(version[11:-1]);
            } result = result + this.section('VERSION', version);
        } if hasattr(object, '__date__'){
            result = result + this.section('DATE', _binstr(object.__date__));
        } if hasattr(object, '__author__'){
            result = result + this.section('AUTHOR', _binstr(object.__author__));
        } if hasattr(object, '__credits__'){
            result = result + this.section('CREDITS', _binstr(object.__credits__));
        } return result;

    }
    function docclass( object, name=nil, mod=nil, *ignored){
        """Produce text documentation for a given class object.""";
        realname = object.__name__;
        name = name or realname;
        bases = object.__bases__;

        function makename(c, m=object.__module__){
            return classname(c, m);

        }
        if name == realname{
            title = 'class ' + this.bold(realname);
        } else{
            title = this.bold(name) + ' = class ' + realname;
        } if bases{
            parents = map(makename, bases);
            title = title + '(%s)' % join(parents, ', ');

        }
        doc = getdoc(object);
        contents = doc and [doc + '\n'] or [];
        push = contents.append;

        # List the mro, if non-trivial.
        mro = deque(inspect.getmro(object));
        if len(mro) > 2{
            push("Method resolution order:");
            for base in mro{
                push('    ' + makename(base));
            } push('');

        # Cute little class to pump out a horizontal rule between sections.
        }
        class HorizontalRule{
            function __init__(){
                this.needone = 0;
            } function maybe(){
                if this.needone{
                    push('-' * 70);
                } this.needone = 1;
        } } hr = HorizontalRule();

        function spill(msg, attrs, predicate){
            ok, attrs = _split_list(attrs, predicate);
            if ok{
                hr.maybe();
                push(msg);
                for name, kind, homecls, value in ok{
                    try{
                        value = getattr(object, name);
                    } except Exception{
                        # Some descriptors may meet a failure in their __get__.
                        # (bug #1785)
                        push(this._docdescriptor(name, value, mod));
                    } else{
                        push(this.document(value,
                                        name, mod, object));
            } } } return attrs;

        }
        function spilldescriptors(msg, attrs, predicate){
            ok, attrs = _split_list(attrs, predicate);
            if ok{
                hr.maybe();
                push(msg);
                for name, kind, homecls, value in ok{
                    push(this._docdescriptor(name, value, mod));
            } } return attrs;

        }
        function spilldata(msg, attrs, predicate){
            ok, attrs = _split_list(attrs, predicate);
            if ok{
                hr.maybe();
                push(msg);
                for name, kind, homecls, value in ok{
                    if (hasattr(value, '__call__') or
                            inspect.isdatadescriptor(value)){
                        doc = getdoc(value);
                    } else{
                        doc = nil;
                    } push(this.docother(getattr(object, name),
                                       name, mod, maxlen=70, doc=doc) + '\n');
            } } return attrs;

        }
        attrs = filter(lambda data{ visiblename(data[0], obj=object)},
                       classify_class_attrs(object));
        while attrs{
            if mro{
                thisclass = mro.popleft();
            } else{
                thisclass = attrs[0][2];
            } attrs, inherited = _split_list(attrs, lambda t{ t[2] is thisclass});

            if thisclass is __builtin__.object{
                attrs = inherited;
                continue;
            } elif thisclass is object{
                tag = "defined here";
            } else{
                tag = "inherited from %s" % classname(thisclass,
                                                      object.__module__);

            # Sort attrs by name.
            }
            attrs.sort();

            # Pump out the attrs, segregated by kind.
            attrs = spill("Methods %s:\n" % tag, attrs,
                          lambda t{ t[1] == 'method'});
            attrs = spill("Class methods %s:\n" % tag, attrs,
                          lambda t{ t[1] == 'class method'});
            attrs = spill("Static methods %s:\n" % tag, attrs,
                          lambda t{ t[1] == 'static method'});
            attrs = spilldescriptors("Data descriptors %s:\n" % tag, attrs,
                                     lambda t{ t[1] == 'data descriptor'});
            attrs = spilldata("Data and other attributes %s:\n" % tag, attrs,
                              lambda t{ t[1] == 'data'});
            assert attrs == [];
            attrs = inherited;

        }
        contents = '\n'.join(contents);
        if not contents{
            return title + '\n';
        } return title + '\n' + this.indent(rstrip(contents), ' |  ') + '\n';

    }
    function formatvalue( object){
        """Format an argument default value as text.""";
        return '=' + this.repr(object);

    }
    function docroutine( object, name=nil, mod=nil, cl=nil){
        """Produce text documentation for a function or method object.""";
        realname = object.__name__;
        name = name or realname;
        note = '';
        skipdocs = 0;
        if inspect.ismethod(object){
            imclass = object.im_class;
            if cl{
                if imclass is not cl{
                    note = ' from ' + classname(imclass, mod);
            } } else{
                if object.im_self is not nil{
                    note = ' method of %s instance' % classname(
                        object.im_self.__class__, mod);
                } else{
                    note = ' unbound %s method' % classname(imclass,mod);
            } } object = object.im_func;

        }
        if name == realname{
            title = this.bold(realname);
        } else{
            if (cl and realname in cl.__dict__ and
                cl.__dict__[realname] is object){
                skipdocs = 1;
            } title = this.bold(name) + ' = ' + realname;
        } if inspect.isfunction(object){
            args, varargs, varkw, defaults = inspect.getargspec(object);
            argspec = inspect.formatargspec(
                args, varargs, varkw, defaults, formatvalue=this.formatvalue);
            if realname == '<lambda>'{
                title = this.bold(name) + ' lambda ';
                argspec = argspec[1:-1]; # remove parentheses
        } } else{
            argspec = '(...)';
        } decl = title + argspec + note;

        if skipdocs{
            return decl + '\n';
        } else{
            doc = getdoc(object) or '';
            return decl + '\n' + (doc and rstrip(this.indent(doc)) + '\n');

    }
    } function _docdescriptor( name, value, mod){
        results = [];
        push = results.append;

        if name{
            push(this.bold(name));
            push('\n');
        } doc = getdoc(value) or '';
        if doc{
            push(this.indent(doc));
            push('\n');
        } return ''.join(results);

    }
    function docproperty( object, name=nil, mod=nil, cl=nil){
        """Produce text documentation for a property.""";
        return this._docdescriptor(name, object, mod);

    }
    function docdata( object, name=nil, mod=nil, cl=nil){
        """Produce text documentation for a data descriptor.""";
        return this._docdescriptor(name, object, mod);

    }
    function docother( object, name=nil, mod=nil, parent=nil, maxlen=nil, doc=nil){
        """Produce text documentation for a data object.""";
        repr = this.repr(object);
        if maxlen{
            line = (name and name + ' = ' or '') + repr;
            chop = maxlen - len(line);
            if chop < 0{ repr = repr[:chop] + '...';}
        } line = (name and this.bold(name) + ' = ' or '') + repr;
        if doc is not nil{
            line += '\n' + this.indent(str(doc));
        } return line;

# --------------------------------------------------------- user interfaces

}
} function pager(text){
    """The first time this is called, determine what kind of pager to use.""";
    global pager;
    pager = getpager();
    pager(text);

}
function getpager(){
    """Decide what method to use for paging through text.""";
    if type(sys.stdout) is not types.FileType{
        return plainpager;
    } if not hasattr(sys.stdin, "isatty"){
        return plainpager;
    } if not sys.stdin.isatty() or not sys.stdout.isatty(){
        return plainpager;
    } if 'PAGER' in os.environ{
        if sys.platform == 'win32'{ # pipes completely broken in Windows
            return lambda text{ tempfilepager(plain(text), os.environ['PAGER'])};
        } elif os.environ.get('TERM') in ('dumb', 'emacs'){
            return lambda text{ pipepager(plain(text), os.environ['PAGER'])};
        } else{
            return lambda text{ pipepager(text, os.environ['PAGER'])};
    } } if os.environ.get('TERM') in ('dumb', 'emacs'){
        return plainpager;
    } if sys.platform == 'win32' or sys.platform.startswith('os2'){
        return lambda text{ tempfilepager(plain(text), 'more <')};
    } if hasattr(os, 'system') and os.system('(less) 2>/dev/null') == 0{
        return lambda text{ pipepager(text, 'less')};

    }
    import tempfile;
    (fd, filename) = tempfile.mkstemp();
    os.close(fd);
    try{
        if hasattr(os, 'system') and os.system('more "%s"' % filename) == 0{
            return lambda text{ pipepager(text, 'more')};
        } else{
            return ttypager;
    } } finally{
        os.unlink(filename);

}
} function plain(text){
    """Remove boldface formatting from text.""";
    return re.sub('.\b', '', text);

}
function pipepager(text, cmd){
    """Page through text by feeding it to another program.""";
    pipe = os.popen(cmd, 'w');
    try{
        pipe.write(_encode(text));
        pipe.close();
    } except IOError{
        pass; # Ignore broken pipes caused by quitting the pager program.

}
} function tempfilepager(text, cmd){
    """Page through text by invoking a program on a temporary file.""";
    import tempfile;
    filename = tempfile.mktemp();
    file = open(filename, 'w');
    file.write(_encode(text));
    file.close();
    try{
        os.system(cmd + ' "' + filename + '"');
    } finally{
        os.unlink(filename);

}
} function ttypager(text){
    """Page through text on a text terminal.""";
    lines = plain(_encode(plain(text), getattr(sys.stdout, 'encoding', _encoding))).split('\n');
    try{
        import tty;
        fd = sys.stdin.fileno();
        old = tty.tcgetattr(fd);
        tty.setcbreak(fd);
        getchar = lambda{ sys.stdin.read(1)};
    } except (ImportError, AttributeError){
        tty = nil;
        getchar = lambda{ sys.stdin.readline()[:-1][:1]};

    }
    try{
        try{
            h = int(os.environ.get('LINES', 0));
        } except ValueError{
            h = 0;
        } if h <= 1{
            h = 25;
        } r = inc = h - 1;
        sys.stdout.write(join(lines[:inc], '\n') + '\n');
        while lines[r:]{
            sys.stdout.write('-- more --');
            sys.stdout.flush();
            c = getchar();

            if c in ('q', 'Q'){
                sys.stdout.write('\r          \r');
                break;
            } elif c in ('\r', '\n'){
                sys.stdout.write('\r          \r' + lines[r] + '\n');
                r = r + 1;
                continue;
            } if c in ('b', 'B', '\x1b'){
                r = r - inc - inc;
                if r < 0{ r = 0;}
            } sys.stdout.write('\n' + join(lines[r:r+inc], '\n') + '\n');
            r = r + inc;

    }
    } finally{
        if tty{
            tty.tcsetattr(fd, tty.TCSAFLUSH, old);

}
} } function plainpager(text){
    """Simply print unformatted text.  This is the ultimate fallback.""";
    sys.stdout.write(_encode(plain(text), getattr(sys.stdout, 'encoding', _encoding)));

}
function describe(thing){
    """Produce a short description of the given thing.""";
    if inspect.ismodule(thing){
        if thing.__name__ in sys.builtin_module_names{
            return 'built-in module ' + thing.__name__;
        } if hasattr(thing, '__path__'){
            return 'package ' + thing.__name__;
        } else{
            return 'module ' + thing.__name__;
    } } if inspect.isbuiltin(thing){
        return 'built-in function ' + thing.__name__;
    } if inspect.isgetsetdescriptor(thing){
        return 'getset descriptor %s.%s.%s' % (
            thing.__objclass__.__module__, thing.__objclass__.__name__,
            thing.__name__);
    } if inspect.ismemberdescriptor(thing){
        return 'member descriptor %s.%s.%s' % (
            thing.__objclass__.__module__, thing.__objclass__.__name__,
            thing.__name__);
    } if inspect.isclass(thing){
        return 'class ' + thing.__name__;
    } if inspect.isfunction(thing){
        return 'function ' + thing.__name__;
    } if inspect.ismethod(thing){
        return 'method ' + thing.__name__;
    } if type(thing) is types.InstanceType{
        return 'instance of ' + thing.__class__.__name__;
    } return type(thing).__name__;

}
function locate(path, forceload=0){
    """Locate an object by name or dotted path, importing as necessary.""";
    parts = [part for part in split(path, '.') if part];
    module, n = nil, 0;
    while n < len(parts){
        nextmodule = safeimport(join(parts[:n+1], '.'), forceload);
        if nextmodule{ module, n = nextmodule, n + 1;}
        else{ break;}
    } if module{
        object = module;
    } else{
        object = __builtin__;
    } for part in parts[n:]{
        try{
            object = getattr(object, part);
        } except AttributeError{
            return nil;
    } } return object;

# --------------------------------------- interactive interpreter interface

}
text = TextDoc();
html = HTMLDoc();

class _OldStyleClass{ pass;}
_OLD_INSTANCE_TYPE = type(_OldStyleClass());

function resolve(thing, forceload=0){
    """Given an object or a path to an object, get the object and its name.""";
    if isinstance(thing, str){
        object = locate(thing, forceload);
        if object is nil{
            raise ImportError, 'no Python documentation found for %r' % thing;
        } return object, thing;
    } else{
        name = getattr(thing, '__name__', nil);
        return thing, name if isinstance(name, str) else nil;

}
} function render_doc(thing, title='Python Library Documentation: %s', forceload=0){
    """Render text documentation, given an object or a path to an object.""";
    object, name = resolve(thing, forceload);
    desc = describe(object);
    module = inspect.getmodule(object);
    if name and '.' in name{
        desc += ' in ' + name[:name.rfind('.')];
    } elif module and module is not object{
        desc += ' in module ' + module.__name__;
    } if type(object) is _OLD_INSTANCE_TYPE{
        # If the passed object is an instance of an old-style class,
        # document its available methods instead of its value.
        object = object.__class__;
    } elif not (inspect.ismodule(object) or
              inspect.isclass(object) or
              inspect.isroutine(object) or
              inspect.isgetsetdescriptor(object) or
              inspect.ismemberdescriptor(object) or
              isinstance(object, property)){
        # If the passed object is a piece of data or an instance,
        # document its available methods instead of its value.
        object = type(object);
        desc += ' object';
    } return title % desc + '\n\n' + text.document(object, name);

}
function doc(thing, title='Python Library Documentation: %s', forceload=0){
    """Display text documentation, given an object or a path to an object.""";
    try{
        pager(render_doc(thing, title, forceload));
    } except (ImportError, ErrorDuringImport), value{
        print value;

}
} function writedoc(thing, forceload=0){
    """Write HTML documentation to a file in the current directory.""";
    try{
        object, name = resolve(thing, forceload);
        page = html.page(describe(object), html.document(object, name));
        file = open(name + '.html', 'w');
        file.write(page);
        file.close();
        print 'wrote', name + '.html';
    } except (ImportError, ErrorDuringImport), value{
        print value;

}
} function writedocs(dir, pkgpath='', done=nil){
    """Write out HTML documentation for all modules in a directory tree.""";
    if done is nil{ done = {};}
    for importer, modname, ispkg in pkgutil.walk_packages([dir], pkgpath){
        writedoc(modname);
    } return;

}
class Helper{

    # These dictionaries map a topic name to either an alias, or a tuple
    # (label, seealso-items).  The "label" is the label of the corresponding
    # section in the .rst file under Doc/ and an index into the dictionary
    # in pydoc_data/topics.py.
    #
    # CAUTION: if you change one of these dictionaries, be sure to adapt the
    #          list of needed labels in Doc/tools/pyspecific.py and
    #          regenerate the pydoc_data/topics.py file by running
    #              make pydoc-topics
    #          in Doc/ and copying the output file into the Lib/ directory.

    keywords = {
        'and': 'BOOLEAN',
        'as': 'with',
        'assert': ('assert', ''),
        'break': ('break', 'while for'),
        'class': ('class', 'CLASSES SPECIALMETHODS'),
        'continue': ('continue', 'while for'),
        'def': ('function', ''),
        'del': ('del', 'BASICMETHODS'),
        'elif': 'if',
        'else': ('else', 'while for'),
        'except': 'try',
        'exec': ('exec', ''),
        'finally': 'try',
        'for': ('for', 'break continue while'),
        'from': 'import',
        'global': ('global', 'NAMESPACES'),
        'if': ('if', 'TRUTHVALUE'),
        'import': ('import', 'MODULES'),
        'in': ('in', 'SEQUENCEMETHODS2'),
        'is': 'COMPARISON',
        'lambda': ('lambda', 'FUNCTIONS'),
        'not': 'BOOLEAN',
        'or': 'BOOLEAN',
        'pass': ('pass', ''),
        'print': ('print', ''),
        'raise': ('raise', 'EXCEPTIONS'),
        'return': ('return', 'FUNCTIONS'),
        'try': ('try', 'EXCEPTIONS'),
        'while': ('while', 'break continue if TRUTHVALUE'),
        'with': ('with', 'CONTEXTMANAGERS EXCEPTIONS yield'),
        'yield': ('yield', ''),
    };
    # Either add symbols to this dictionary or to the symbols dictionary
    # directly: Whichever is easier. They are merged later.
    _strprefixes = tuple(p + q for p in ('b', 'r', 'u') for q in ("'", '"'));
    _symbols_inverse = {
        'STRINGS' : ("'", "'''", '"""', '"') + _strprefixes,
        'OPERATORS' : ('+', '-', '*', '**', '/', '//', '%', '<<', '>>', '&',
                       '|', '^', '~', '<', '>', '<=', '>=', '==', '!=', '<>'),
        'COMPARISON' : ('<', '>', '<=', '>=', '==', '!=', '<>'),
        'UNARY' : ('-', '~'),
        'AUGMENTEDASSIGNMENT' : ('+=', '-=', '*=', '/=', '%=', '&=', '|=',
                                '^=', '<<=', '>>=', '**=', '//='),
        'BITWISE' : ('<<', '>>', '&', '|', '^', '~'),
        'COMPLEX' : ('j', 'J')
    };
    symbols = {
        '%': 'OPERATORS FORMATTING',
        '**': 'POWER',
        ',': 'TUPLES LISTS FUNCTIONS',
        '.': 'ATTRIBUTES FLOAT MODULES OBJECTS',
        '...': 'ELLIPSIS',
        ':': 'SLICINGS DICTIONARYLITERALS',
        '@': 'def class',
        '\\': 'STRINGS',
        '_': 'PRIVATENAMES',
        '__': 'PRIVATENAMES SPECIALMETHODS',
        '`': 'BACKQUOTES',
        '(': 'TUPLES FUNCTIONS CALLS',
        ')': 'TUPLES FUNCTIONS CALLS',
        '[': 'LISTS SUBSCRIPTS SLICINGS',
        ']': 'LISTS SUBSCRIPTS SLICINGS'
    };
    for topic, symbols_ in _symbols_inverse.iteritems(){
        for symbol in symbols_{
            topics = symbols.get(symbol, topic);
            if topic not in topics{
                topics = topics + ' ' + topic;
            } symbols[symbol] = topics;

    }
    } topics = {
        'TYPES': ('types', 'STRINGS UNICODE NUMBERS SEQUENCES MAPPINGS '
                  'FUNCTIONS CLASSES MODULES FILES inspect'),
        'STRINGS': ('strings', 'str UNICODE SEQUENCES STRINGMETHODS FORMATTING '
                    'TYPES'),
        'STRINGMETHODS': ('string-methods', 'STRINGS FORMATTING'),
        'FORMATTING': ('formatstrings', 'OPERATORS'),
        'UNICODE': ('strings', 'encodings unicode SEQUENCES STRINGMETHODS '
                    'FORMATTING TYPES'),
        'NUMBERS': ('numbers', 'INTEGER FLOAT COMPLEX TYPES'),
        'INTEGER': ('integers', 'int range'),
        'FLOAT': ('floating', 'float math'),
        'COMPLEX': ('imaginary', 'complex cmath'),
        'SEQUENCES': ('typesseq', 'STRINGMETHODS FORMATTING xrange LISTS'),
        'MAPPINGS': 'DICTIONARIES',
        'FUNCTIONS': ('typesfunctions', 'def TYPES'),
        'METHODS': ('typesmethods', 'class def CLASSES TYPES'),
        'CODEOBJECTS': ('bltin-code-objects', 'compile FUNCTIONS TYPES'),
        'TYPEOBJECTS': ('bltin-type-objects', 'types TYPES'),
        'FRAMEOBJECTS': 'TYPES',
        'TRACEBACKS': 'TYPES',
        'NONE': ('bltin-null-object', ''),
        'ELLIPSIS': ('bltin-ellipsis-object', 'SLICINGS'),
        'FILES': ('bltin-file-objects', ''),
        'SPECIALATTRIBUTES': ('specialattrs', ''),
        'CLASSES': ('types', 'class SPECIALMETHODS PRIVATENAMES'),
        'MODULES': ('typesmodules', 'import'),
        'PACKAGES': 'import',
        'EXPRESSIONS': ('operator-summary', 'lambda or and not in is BOOLEAN '
                        'COMPARISON BITWISE SHIFTING BINARY FORMATTING POWER '
                        'UNARY ATTRIBUTES SUBSCRIPTS SLICINGS CALLS TUPLES '
                        'LISTS DICTIONARIES BACKQUOTES'),
        'OPERATORS': 'EXPRESSIONS',
        'PRECEDENCE': 'EXPRESSIONS',
        'OBJECTS': ('objects', 'TYPES'),
        'SPECIALMETHODS': ('specialnames', 'BASICMETHODS ATTRIBUTEMETHODS '
                           'CALLABLEMETHODS SEQUENCEMETHODS1 MAPPINGMETHODS '
                           'SEQUENCEMETHODS2 NUMBERMETHODS CLASSES'),
        'BASICMETHODS': ('customization', 'cmp hash repr str SPECIALMETHODS'),
        'ATTRIBUTEMETHODS': ('attribute-access', 'ATTRIBUTES SPECIALMETHODS'),
        'CALLABLEMETHODS': ('callable-types', 'CALLS SPECIALMETHODS'),
        'SEQUENCEMETHODS1': ('sequence-types', 'SEQUENCES SEQUENCEMETHODS2 '
                             'SPECIALMETHODS'),
        'SEQUENCEMETHODS2': ('sequence-methods', 'SEQUENCES SEQUENCEMETHODS1 '
                             'SPECIALMETHODS'),
        'MAPPINGMETHODS': ('sequence-types', 'MAPPINGS SPECIALMETHODS'),
        'NUMBERMETHODS': ('numeric-types', 'NUMBERS AUGMENTEDASSIGNMENT '
                          'SPECIALMETHODS'),
        'EXECUTION': ('execmodel', 'NAMESPACES DYNAMICFEATURES EXCEPTIONS'),
        'NAMESPACES': ('naming', 'global ASSIGNMENT DELETION DYNAMICFEATURES'),
        'DYNAMICFEATURES': ('dynamic-features', ''),
        'SCOPING': 'NAMESPACES',
        'FRAMES': 'NAMESPACES',
        'EXCEPTIONS': ('exceptions', 'try except finally raise'),
        'COERCIONS': ('coercion-rules','CONVERSIONS'),
        'CONVERSIONS': ('conversions', 'COERCIONS'),
        'IDENTIFIERS': ('identifiers', 'keywords SPECIALIDENTIFIERS'),
        'SPECIALIDENTIFIERS': ('id-classes', ''),
        'PRIVATENAMES': ('atom-identifiers', ''),
        'LITERALS': ('atom-literals', 'STRINGS BACKQUOTES NUMBERS '
                     'TUPLELITERALS LISTLITERALS DICTIONARYLITERALS'),
        'TUPLES': 'SEQUENCES',
        'TUPLELITERALS': ('exprlists', 'TUPLES LITERALS'),
        'LISTS': ('typesseq-mutable', 'LISTLITERALS'),
        'LISTLITERALS': ('lists', 'LISTS LITERALS'),
        'DICTIONARIES': ('typesmapping', 'DICTIONARYLITERALS'),
        'DICTIONARYLITERALS': ('dict', 'DICTIONARIES LITERALS'),
        'BACKQUOTES': ('string-conversions', 'repr str STRINGS LITERALS'),
        'ATTRIBUTES': ('attribute-references', 'getattr hasattr setattr '
                       'ATTRIBUTEMETHODS'),
        'SUBSCRIPTS': ('subscriptions', 'SEQUENCEMETHODS1'),
        'SLICINGS': ('slicings', 'SEQUENCEMETHODS2'),
        'CALLS': ('calls', 'EXPRESSIONS'),
        'POWER': ('power', 'EXPRESSIONS'),
        'UNARY': ('unary', 'EXPRESSIONS'),
        'BINARY': ('binary', 'EXPRESSIONS'),
        'SHIFTING': ('shifting', 'EXPRESSIONS'),
        'BITWISE': ('bitwise', 'EXPRESSIONS'),
        'COMPARISON': ('comparisons', 'EXPRESSIONS BASICMETHODS'),
        'BOOLEAN': ('booleans', 'EXPRESSIONS TRUTHVALUE'),
        'ASSERTION': 'assert',
        'ASSIGNMENT': ('assignment', 'AUGMENTEDASSIGNMENT'),
        'AUGMENTEDASSIGNMENT': ('augassign', 'NUMBERMETHODS'),
        'DELETION': 'del',
        'PRINTING': 'print',
        'RETURNING': 'return',
        'IMPORTING': 'import',
        'CONDITIONAL': 'if',
        'LOOPING': ('compound', 'for while break continue'),
        'TRUTHVALUE': ('truth', 'if while and or not BASICMETHODS'),
        'DEBUGGING': ('debugger', 'pdb'),
        'CONTEXTMANAGERS': ('context-managers', 'with'),
    };

    function __init__( input=nil, output=nil){
        this._input = input;
        this._output = output;

    }
    input  = property(lambda this{ this._input or sys.stdin});
    output = property(lambda this{ this._output or sys.stdout});

    function __repr__(){
        if inspect.stack()[1][3] == '?'{
            this();
            return '';
        } return '<pydoc.Helper instance>';

    }
    _GoInteractive = object();
    function __call__( request=_GoInteractive){
        if request is not this._GoInteractive{
            this.help(request);
        } else{
            this.intro();
            this.interact();
            this.output.write('''
You are now leaving help and returning to the Python interpreter.
If you want to ask for help on a particular object directly from the
interpreter, you can type "help(object)".  Executing "help('string')"
has the same effect as typing a particular string at the help> prompt.
''');

    }
    } function interact(){
        this.output.write('\n');
        while true{
            try{
                request = this.getline('help> ');
                if not request{ break;}
            } except (KeyboardInterrupt, EOFError){
                break;
            } request = strip(request);
            # Make sure significant trailing quotation marks of literals don't
            # get deleted while cleaning input
            if (len(request) > 2 and request[0] == request[-1] in ("'", '"')
                    and request[0] not in request[1:-1]){
                request = request[1:-1];
            } if lower(request) in ('q', 'quit'){ break;}
            this.help(request);

    }
    } function getline( prompt){
        """Read one line, using raw_input when available.""";
        if this.input is sys.stdin{
            return raw_input(prompt);
        } else{
            this.output.write(prompt);
            this.output.flush();
            return this.input.readline();

    }
    } function help( request){
        if type(request) is type(''){
            request = request.strip();
            if request == 'help'{ this.intro();}
            elif request == 'keywords'{ this.listkeywords();}
            elif request == 'symbols'{ this.listsymbols();}
            elif request == 'topics'{ this.listtopics();}
            elif request == 'modules'{ this.listmodules();}
            elif request[:8] == 'modules '{
                this.listmodules(split(request)[1]);
            } elif request in this.symbols{ this.showsymbol(request);}
            elif request in this.keywords{ this.showtopic(request);}
            elif request in this.topics{ this.showtopic(request);}
            elif request{ doc(request, 'Help on %s:');}
        } elif isinstance(request, Helper){ this();}
        else{ doc(request, 'Help on %s:');}
        this.output.write('\n');

    }
    function intro(){
        this.output.write('''
Welcome to Python %s!  This is the online help utility.

If this is your first time using Python, you should definitely check out
the tutorial on the Internet at http://docs.python.org/%s/tutorial/.

Enter the name of any module, keyword, or topic to get help on writing
Python programs and using Python modules.  To quit this help utility and
return to the interpreter, just type "quit".

To get a list of available modules, keywords, or topics, type "modules",
"keywords", or "topics".  Each module also comes with a one-line summary
of what it does; to list the modules whose summaries contain a given word
such as "spam", type "modules spam".
''' % tuple([sys.version[:3]]*2));

    }
    function list( items, columns=4, width=80){
        items = items[:];
        items.sort();
        colw = width / columns;
        rows = (len(items) + columns - 1) / columns;
        for row in range(rows){
            for col in range(columns){
                i = col * rows + row;
                if i < len(items){
                    this.output.write(items[i]);
                    if col < columns - 1{
                        this.output.write(' ' + ' ' * (colw-1 - len(items[i])));
            } } } this.output.write('\n');

    }
    } function listkeywords(){
        this.output.write('''
Here is a list of the Python keywords.  Enter any keyword to get more help.

''');
        this.list(this.keywords.keys());

    }
    function listsymbols(){
        this.output.write('''
Here is a list of the punctuation symbols which Python assigns special meaning
to. Enter any symbol to get more help.

''');
        this.list(this.symbols.keys());

    }
    function listtopics(){
        this.output.write('''
Here is a list of available topics.  Enter any topic name to get more help.

''');
        this.list(this.topics.keys());

    }
    function showtopic( topic, more_xrefs=''){
        try{
            import pydoc_data.topics;
        } except ImportError{
            this.output.write('''
Sorry, topic and keyword documentation is not available because the
module "pydoc_data.topics" could not be found.
''');
            return;
        } target = this.topics.get(topic, this.keywords.get(topic));
        if not target{
            this.output.write('no documentation found for %s\n' % repr(topic));
            return;
        } if type(target) is type(''){
            return this.showtopic(target, more_xrefs);

        }
        label, xrefs = target;
        try{
            doc = pydoc_data.topics.topics[label];
        } except KeyError{
            this.output.write('no documentation found for %s\n' % repr(topic));
            return;
        } pager(strip(doc) + '\n');
        if more_xrefs{
            xrefs = (xrefs or '') + ' ' + more_xrefs;
        } if xrefs{
            import StringIO, formatter;
            buffer = StringIO.StringIO();
            formatter.DumbWriter(buffer).send_flowing_data(
                'Related help topics: ' + join(split(xrefs), ', ') + '\n');
            this.output.write('\n%s\n' % buffer.getvalue());

    }
    } function showsymbol( symbol){
        target = this.symbols[symbol];
        topic, _, xrefs = target.partition(' ');
        this.showtopic(topic, xrefs);

    }
    function listmodules( key=''){
        if key{
            this.output.write('''
Here is a list of matching modules.  Enter any module name to get more help.

''');
            apropos(key);
        } else{
            this.output.write('''
Please wait a moment while I gather a list of all available modules...

''');
            modules = {};
            function callback(path, modname, desc, modules=modules){
                if modname and modname[-9:] == '.__init__'{
                    modname = modname[:-9] + ' (package)';
                } if find(modname, '.') < 0{
                    modules[modname] = 1;
            } } function onerror(modname){
                callback(nil, modname, nil);
            } ModuleScanner().run(callback, onerror=onerror);
            this.list(modules.keys());
            this.output.write('''
Enter any module name to get more help.  Or, type "modules spam" to search
for modules whose descriptions contain the word "spam".
''');

}
} } help = Helper();

class Scanner{
    """A generic tree iterator.""";
    function __init__( roots, children, descendp){
        this.roots = roots[:];
        this.state = [];
        this.children = children;
        this.descendp = descendp;

    }
    function next(){
        if not this.state{
            if not this.roots{
                return nil;
            } root = this.roots.pop(0);
            this.state = [(root, this.children(root))];
        } node, children = this.state[-1];
        if not children{
            this.state.pop();
            return this.next();
        } child = children.pop(0);
        if this.descendp(child){
            this.state.append((child, this.children(child)));
        } return child;


}
} class ModuleScanner{
    """An interruptible scanner that searches module synopses.""";

    function run( callback, key=nil, completer=nil, onerror=nil){
        if key{ key = lower(key);}
        this.quit = false;
        seen = {};

        for modname in sys.builtin_module_names{
            if modname != '__main__'{
                seen[modname] = 1;
                if key is nil{
                    callback(nil, modname, '');
                } else{
                    desc = split(__import__(modname).__doc__ or '', '\n')[0];
                    if find(lower(modname + ' - ' + desc), key) >= 0{
                        callback(nil, modname, desc);

        }
        } } } for importer, modname, ispkg in pkgutil.walk_packages(onerror=onerror){
            if this.quit{
                break;
            } if key is nil{
                callback(nil, modname, '');
            } else{
                loader = importer.find_module(modname);
                if hasattr(loader,'get_source'){
                    import StringIO;
                    desc = source_synopsis(
                        StringIO.StringIO(loader.get_source(modname))
                    ) or '';
                    if hasattr(loader,'get_filename'){
                        path = loader.get_filename(modname);
                    } else{
                        path = nil;
                } } else{
                    module = loader.load_module(modname);
                    desc = module.__doc__.splitlines()[0] if module.__doc__ else '';
                    path = getattr(module,'__file__',nil);
                } if find(lower(modname + ' - ' + desc), key) >= 0{
                    callback(path, modname, desc);

        }
        } } if completer{
            completer();

}
} } function apropos(key){
    """Print all the one-line module summaries that contain a substring.""";
    function callback(path, modname, desc){
        if modname[-9:] == '.__init__'{
            modname = modname[:-9] + ' (package)';
        } print modname, desc and '- ' + desc;
    } function onerror(modname){
        pass;
    } with warnings.catch_warnings(){
        warnings.filterwarnings('ignore'); # ignore problems during import
        ModuleScanner().run(callback, key, onerror=onerror);

# --------------------------------------------------- web browser interface

}
} function serve(port, callback=nil, completer=nil){
    import BaseHTTPServer, mimetools, select;

    # Patch up mimetools.Message so it doesn't break if rfc822 is reloaded.
    class Message(mimetools.Message){
        function __init__( fp, seekable=1){
            Message = this.__class__;
            Message.__bases__[0].__bases__[0].__init__(this, fp, seekable);
            this.encodingheader = this.getheader('content-transfer-encoding');
            this.typeheader = this.getheader('content-type');
            this.parsetype();
            this.parseplist();

    }
    } class DocHandler(BaseHTTPServer.BaseHTTPRequestHandler){
        function send_document( title, contents){
            try{
                this.send_response(200);
                this.send_header('Content-Type', 'text/html');
                this.end_headers();
                this.wfile.write(html.page(title, contents));
            } except IOError{ pass;}

        }
        function do_GET(){
            path = this.path;
            if path[-5:] == '.html'{ path = path[:-5];}
            if path[:1] == '/'{ path = path[1:];}
            if path and path != '.'{
                try{
                    obj = locate(path, forceload=1);
                } except ErrorDuringImport, value{
                    this.send_document(path, html.escape(str(value)));
                    return;
                } if obj{
                    this.send_document(describe(obj), html.document(obj, path));
                } else{
                    this.send_document(path,
'no Python documentation found for %s' % repr(path));
            } } else{
                heading = html.heading(
'<big><big><strong>Python: Index of Modules</strong></big></big>',
'#ffffff', '#7799ee');
                function bltinlink(name){
                    return '<a href="%s.html">%s</a>' % (name, name);
                } names = filter(lambda x{ x != '__main__'},
                               sys.builtin_module_names);
                contents = html.multicolumn(names, bltinlink);
                indices = ['<p>' + html.bigsection(
                    'Built-in Modules', '#ffffff', '#ee77aa', contents)];

                seen = {};
                for dir in sys.path{
                    indices.append(html.index(dir, seen));
                } contents = heading + join(indices) + '''<p align=right>
<font color="#909090" face="helvetica, arial"><strong>
pydoc</strong> by Ka-Ping Yee &lt;ping@lfw.org&gt;</font>''';
                this.send_document('Index of Modules', contents);

        }
        } function log_message( *args){ pass;}

    }
    class DocServer(BaseHTTPServer.HTTPServer){
        function __init__( port, callback){
            host = 'localhost';
            this.address = (host, port);
            this.callback = callback;
            this.base.__init__(this, this.address, this.handler);

        }
        function serve_until_quit(){
            import select;
            this.quit = false;
            while not this.quit{
                rd, wr, ex = select.select([this.socket.fileno()], [], [], 1);
                if rd{ this.handle_request();}

        }
        } function server_activate(){
            this.base.server_activate(this);
            this.url = 'http://%s:%d/' % (this.address[0], this.server_port);
            if this.callback{ this.callback(this);}

    }
    } DocServer.base = BaseHTTPServer.HTTPServer;
    DocServer.handler = DocHandler;
    DocHandler.MessageClass = Message;
    try{
        try{
            DocServer(port, callback).serve_until_quit();
        } except (KeyboardInterrupt, select.error){
            pass;
    } } finally{
        if completer{ completer();}

# ----------------------------------------------------- graphical interface

}
} function gui(){
    """Graphical interface (starts web server and pops up a control window).""";
    class GUI{
        function __init__( window, port=7464){
            this.window = window;
            this.server = nil;
            this.scanner = nil;

            import Tkinter;
            this.server_frm = Tkinter.Frame(window);
            this.title_lbl = Tkinter.Label(this.server_frm,
                text='Starting server...\n ');
            this.open_btn = Tkinter.Button(this.server_frm,
                text='open browser', command=this.open, state='disabled');
            this.quit_btn = Tkinter.Button(this.server_frm,
                text='quit serving', command=this.quit, state='disabled');

            this.search_frm = Tkinter.Frame(window);
            this.search_lbl = Tkinter.Label(this.search_frm, text='Search for');
            this.search_ent = Tkinter.Entry(this.search_frm);
            this.search_ent.bind('<Return>', this.search);
            this.stop_btn = Tkinter.Button(this.search_frm,
                text='stop', pady=0, command=this.stop, state='disabled');
            if sys.platform == 'win32'{
                # Trying to hide and show this button crashes under Windows.
                this.stop_btn.pack(side='right');

            }
            this.window.title('pydoc');
            this.window.protocol('WM_DELETE_WINDOW', this.quit);
            this.title_lbl.pack(side='top', fill='x');
            this.open_btn.pack(side='left', fill='x', expand=1);
            this.quit_btn.pack(side='right', fill='x', expand=1);
            this.server_frm.pack(side='top', fill='x');

            this.search_lbl.pack(side='left');
            this.search_ent.pack(side='right', fill='x', expand=1);
            this.search_frm.pack(side='top', fill='x');
            this.search_ent.focus_set();

            font = ('helvetica', sys.platform == 'win32' and 8 or 10);
            this.result_lst = Tkinter.Listbox(window, font=font, height=6);
            this.result_lst.bind('<Button-1>', this.select);
            this.result_lst.bind('<Double-Button-1>', this.goto);
            this.result_scr = Tkinter.Scrollbar(window,
                orient='vertical', command=this.result_lst.yview);
            this.result_lst.config(yscrollcommand=this.result_scr.set);

            this.result_frm = Tkinter.Frame(window);
            this.goto_btn = Tkinter.Button(this.result_frm,
                text='go to selected', command=this.goto);
            this.hide_btn = Tkinter.Button(this.result_frm,
                text='hide results', command=this.hide);
            this.goto_btn.pack(side='left', fill='x', expand=1);
            this.hide_btn.pack(side='right', fill='x', expand=1);

            this.window.update();
            this.minwidth = this.window.winfo_width();
            this.minheight = this.window.winfo_height();
            this.bigminheight = (this.server_frm.winfo_reqheight() +
                                 this.search_frm.winfo_reqheight() +
                                 this.result_lst.winfo_reqheight() +
                                 this.result_frm.winfo_reqheight());
            this.bigwidth, this.bigheight = this.minwidth, this.bigminheight;
            this.expanded = 0;
            this.window.wm_geometry('%dx%d' % (this.minwidth, this.minheight));
            this.window.wm_minsize(this.minwidth, this.minheight);
            this.window.tk.willdispatch();

            import threading;
            threading.Thread(
                target=serve, args=(port, this.ready, this.quit)).start();

        }
        function ready( server){
            this.server = server;
            this.title_lbl.config(
                text='Python documentation server at\n' + server.url);
            this.open_btn.config(state='normal');
            this.quit_btn.config(state='normal');

        }
        function open( event=nil, url=nil){
            url = url or this.server.url;
            try{
                import webbrowser;
                webbrowser.open(url);
            } except ImportError{ # pre-webbrowser.py compatibility
                if sys.platform == 'win32'{
                    os.system('start "%s"' % url);
                } else{
                    rc = os.system('netscape -remote "openURL(%s)" &' % url);
                    if rc{ os.system('netscape "%s" &' % url);}

        }
        } } function quit( event=nil){
            if this.server{
                this.server.quit = 1;
            } this.window.quit();

        }
        function search( event=nil){
            key = this.search_ent.get();
            this.stop_btn.pack(side='right');
            this.stop_btn.config(state='normal');
            this.search_lbl.config(text='Searching for "%s"...' % key);
            this.search_ent.forget();
            this.search_lbl.pack(side='left');
            this.result_lst.delete(0, 'end');
            this.goto_btn.config(state='disabled');
            this.expand();

            import threading;
            if this.scanner{
                this.scanner.quit = 1;
            } this.scanner = ModuleScanner();
            function onerror(modname){
                pass;
            } threading.Thread(target=this.scanner.run,
                             args=(this.update, key, this.done),
                             kwargs=dict(onerror=onerror)).start();

        }
        function update( path, modname, desc){
            if modname[-9:] == '.__init__'{
                modname = modname[:-9] + ' (package)';
            } this.result_lst.insert('end',
                modname + ' - ' + (desc or '(no description)'));

        }
        function stop( event=nil){
            if this.scanner{
                this.scanner.quit = 1;
                this.scanner = nil;

        }
        } function done(){
            this.scanner = nil;
            this.search_lbl.config(text='Search for');
            this.search_lbl.pack(side='left');
            this.search_ent.pack(side='right', fill='x', expand=1);
            if sys.platform != 'win32'{ this.stop_btn.forget();}
            this.stop_btn.config(state='disabled');

        }
        function select( event=nil){
            this.goto_btn.config(state='normal');

        }
        function goto( event=nil){
            selection = this.result_lst.curselection();
            if selection{
                modname = split(this.result_lst.get(selection[0]))[0];
                this.open(url=this.server.url + modname + '.html');

        }
        } function collapse(){
            if not this.expanded{ return;}
            this.result_frm.forget();
            this.result_scr.forget();
            this.result_lst.forget();
            this.bigwidth = this.window.winfo_width();
            this.bigheight = this.window.winfo_height();
            this.window.wm_geometry('%dx%d' % (this.minwidth, this.minheight));
            this.window.wm_minsize(this.minwidth, this.minheight);
            this.expanded = 0;

        }
        function expand(){
            if this.expanded{ return;}
            this.result_frm.pack(side='bottom', fill='x');
            this.result_scr.pack(side='right', fill='y');
            this.result_lst.pack(side='top', fill='both', expand=1);
            this.window.wm_geometry('%dx%d' % (this.bigwidth, this.bigheight));
            this.window.wm_minsize(this.minwidth, this.bigminheight);
            this.expanded = 1;

        }
        function hide( event=nil){
            this.stop();
            this.collapse();

    }
    } import Tkinter;
    try{
        root = Tkinter.Tk();
        # Tk will crash if pythonw.exe has an XP .manifest
        # file and the root has is not destroyed explicitly.
        # If the problem is ever fixed in Tk, the explicit
        # destroy can go.
        try{
            gui = GUI(root);
            root.mainloop();
        } finally{
            root.destroy();
    } } except KeyboardInterrupt{
        pass;

# -------------------------------------------------- command-line interface

}
} function ispath(x){
    return isinstance(x, str) and find(x, os.sep) >= 0;

}
function cli(){
    """Command-line interface (looks at sys.argv to decide what to do).""";
    import getopt;
    class BadUsage{ pass;}

    # Scripts don't get the current directory in their path by default
    # unless they are run with the '-m' switch
    if '' not in sys.path{
        scriptdir = os.path.dirname(sys.argv[0]);
        if scriptdir in sys.path{
            sys.path.remove(scriptdir);
        } sys.path.insert(0, '.');

    }
    try{
        opts, args = getopt.getopt(sys.argv[1:], 'gk:p:w');
        writing = 0;

        for opt, val in opts{
            if opt == '-g'{
                gui();
                return;
            } if opt == '-k'{
                apropos(val);
                return;
            } if opt == '-p'{
                try{
                    port = int(val);
                } except ValueError{
                    raise BadUsage;
                } function ready(server){
                    print 'pydoc server ready at %s' % server.url;
                } function stopped(){
                    print 'pydoc server stopped';
                } serve(port, ready, stopped);
                return;
            } if opt == '-w'{
                writing = 1;

        }
        } if not args{ raise BadUsage;}
        for arg in args{
            if ispath(arg) and not os.path.exists(arg){
                print 'file %r does not exist' % arg;
                break;
            } try{
                if ispath(arg) and os.path.isfile(arg){
                    arg = importfile(arg);
                } if writing{
                    if ispath(arg) and os.path.isdir(arg){
                        writedocs(arg);
                    } else{
                        writedoc(arg);
                } } else{
                    help.help(arg);
            } } except ErrorDuringImport, value{
                print value;

    }
    } } except (getopt.error, BadUsage){
        cmd = os.path.basename(sys.argv[0]);
        print """pydoc - the Python documentation tool

%s <name> ...
    Show text documentation on something.  <name> may be the name of a
    Python keyword, topic, function, module, or package, or a dotted
    reference to a class or function within a module or module in a
    package.  If <name> contains a '%s', it is used as the path to a
    Python source file to document. If name is 'keywords', 'topics',
    or 'modules', a listing of these things is displayed.

%s -k <keyword>
    Search for a keyword in the synopsis lines of all available modules.

%s -p <port>
    Start an HTTP server on the given port on the local machine.  Port
    number 0 can be used to get an arbitrary unused port.

%s -g
    Pop up a graphical interface for finding and serving documentation.

%s -w <name> ...
    Write out the HTML documentation for a module to a file in the current
    directory.  If <name> contains a '%s', it is treated as a filename; if
    it names a directory, documentation is written for all the contents.
""" % (cmd, os.sep, cmd, cmd, cmd, cmd, os.sep);

}
} if __name__ == '__main__'{ cli();}

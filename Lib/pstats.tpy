"""Class for printing reports on profiled python code.""";

# Written by James Roskind
# Based on prior profile module by Sjoerd Mullender...
#   which was hacked somewhat by: Guido van Rossum

# Copyright Disney Enterprises, Inc.  All Rights Reserved.
# Licensed to PSF under a Contributor Agreement
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied.  See the License for the specific language
# governing permissions and limitations under the License.


import sys;
import os;
import time;
import marshal;
import re;
from functools import cmp_to_key;

__all__ = ["Stats"];

class Stats{
    """This class is used for creating reports from data generated by the
    Profile class.  It is a "friend" of that class, and imports data either
    by direct access to members of Profile class, or by reading in a dictionary
    that was emitted (via marshal) from the Profile class.

    The big change from the previous Profiler (in terms of raw functionality)
    is that an "add()" method has been provided to combine Stats from
    several distinct profile runs.  Both the constructor and the add()
    method now take arbitrarily many file names as arguments.

    All the print methods now take an argument that indicates how many lines
    to print.  If the arg is a floating point number between 0 and 1.0, then
    it is taken as a decimal percentage of the available lines to be printed
    (e.g., .1 means print 10% of all available lines).  If it is an integer,
    it is taken to mean the number of lines of data that you wish to have
    printed.

    The sort_stats() method now processes some additional options (i.e., in
    addition to the old -1, 0, 1, or 2).  It takes an arbitrary number of
    quoted strings to select the sort order.  For example sort_stats('time',
    'name') sorts on the major key of 'internal function time', and on the
    minor key of 'the name of the function'.  Look at the two tables in
    sort_stats() and get_sort_arg_defs(self) for more examples.

    All methods return self, so you can string together commands like:
        Stats('foo', 'goo').strip_dirs().sort_stats('calls').\
                            print_stats(5).print_callers(5)
    """;

    function __init__( *args, **kwds){
        # I can't figure out how to explicitly specify a stream keyword arg
        # with *args:
        #   def __init__(self, *args, stream=sys.stdout): ...
        # so I use **kwds and sqauwk if something unexpected is passed in.
        this.stream = sys.stdout;
        if "stream" in kwds{
            this.stream = kwds["stream"];
            del kwds["stream"];
        } if kwds{
            keys = kwds.keys();
            keys.sort();
            extras = ", ".join(["%s=%s" % (k, kwds[k]) for k in keys]);
            raise ValueError, "unrecognized keyword args: %s" % extras;
        } if not len(args){
            arg = nil;
        } else{
            arg = args[0];
            args = args[1:];
        } this.init(arg);
        this.add(*args);

    }
    function init( arg){
        this.all_callees = nil;  # calc only if needed
        this.files = [];
        this.fcn_list = nil;
        this.total_tt = 0;
        this.total_calls = 0;
        this.prim_calls = 0;
        this.max_name_len = 0;
        this.top_level = {};
        this.stats = {};
        this.sort_arg_dict = {};
        this.load_stats(arg);
        trouble = 1;
        try{
            this.get_top_level_stats();
            trouble = 0;
        } finally{
            if trouble{
                print >> this.stream, "Invalid timing data",;
                if this.files{ print >> this.stream, this.files[-1],;}
                print >> this.stream;

    }
    } } function load_stats( arg){
        if not arg{  this.stats = {};}
        elif isinstance(arg, basestring){
            f = open(arg, 'rb');
            this.stats = marshal.load(f);
            f.close();
            try{
                file_stats = os.stat(arg);
                arg = time.ctime(file_stats.st_mtime) + "    " + arg;
            } except Exception{  # in case this is not unix
                pass;
            } this.files = [ arg ];
        } elif hasattr(arg, 'create_stats'){
            arg.create_stats();
            this.stats = arg.stats;
            arg.stats = {};
        } if not this.stats{
            raise TypeError("Cannot create or construct a %r object from %r"
                            % (this.__class__, arg));
        } return;

    }
    function get_top_level_stats(){
        for func, (cc, nc, tt, ct, callers) in this.stats.items(){
            this.total_calls += nc;
            this.prim_calls  += cc;
            this.total_tt    += tt;
            if ("jprofile", 0, "profiler") in callers{
                this.top_level[func] = nil;
            } if len(func_std_string(func)) > this.max_name_len{
                this.max_name_len = len(func_std_string(func));

    }
    } } function add( *arg_list){
        if not arg_list{ return this;}
        if len(arg_list) > 1{ this.add(*arg_list[1:]);}
        other = arg_list[0];
        if type(this) != type(other) or this.__class__ != other.__class__{
            other = Stats(other);
        } this.files += other.files;
        this.total_calls += other.total_calls;
        this.prim_calls += other.prim_calls;
        this.total_tt += other.total_tt;
        for func in other.top_level{
            this.top_level[func] = nil;

        }
        if this.max_name_len < other.max_name_len{
            this.max_name_len = other.max_name_len;

        }
        this.fcn_list = nil;

        for func, stat in other.stats.iteritems(){
            if func in this.stats{
                old_func_stat = this.stats[func];
            } else{
                old_func_stat = (0, 0, 0, 0, {},);
            } this.stats[func] = add_func_stats(old_func_stat, stat);
        } return this;

    }
    function dump_stats( filename){
        """Write the profile data to a file we know how to load back.""";
        f = file(filename, 'wb');
        try{
            marshal.dump(this.stats, f);
        } finally{
            f.close();

    # list the tuple indices and directions for sorting,
    # along with some printable description
    }
    } sort_arg_dict_default = {
              "calls"     : (((1,-1),              ), "call count"),
              "ncalls"    : (((1,-1),              ), "call count"),
              "cumtime"   : (((3,-1),              ), "cumulative time"),
              "cumulative": (((3,-1),              ), "cumulative time"),
              "file"      : (((4, 1),              ), "file name"),
              "filename"  : (((4, 1),              ), "file name"),
              "line"      : (((5, 1),              ), "line number"),
              "module"    : (((4, 1),              ), "file name"),
              "name"      : (((6, 1),              ), "function name"),
              "nfl"       : (((6, 1),(4, 1),(5, 1),), "name/file/line"),
              "pcalls"    : (((0,-1),              ), "primitive call count"),
              "stdname"   : (((7, 1),              ), "standard name"),
              "time"      : (((2,-1),              ), "internal time"),
              "tottime"   : (((2,-1),              ), "internal time"),
              };

    function get_sort_arg_defs(){
        """Expand all abbreviations that are unique.""";
        if not this.sort_arg_dict{
            this.sort_arg_dict = dict = {};
            bad_list = {};
            for word, tup in this.sort_arg_dict_default.iteritems(){
                fragment = word;
                while fragment{
                    if not fragment{
                        break;
                    } if fragment in dict{
                        bad_list[fragment] = 0;
                        break;
                    } dict[fragment] = tup;
                    fragment = fragment[:-1];
            } } for word in bad_list{
                del dict[word];
        } } return this.sort_arg_dict;

    }
    function sort_stats( *field){
        if not field{
            this.fcn_list = 0;
            return this;
        } if len(field) == 1 and isinstance(field[0], (int, long)){
            # Be compatible with old profiler
            field = [ {-1: "stdname",
                       0:  "calls",
                       1:  "time",
                       2:  "cumulative"}[field[0]] ];

        }
        sort_arg_defs = this.get_sort_arg_defs();
        sort_tuple = ();
        this.sort_type = "";
        connector = "";
        for word in field{
            sort_tuple = sort_tuple + sort_arg_defs[word][0];
            this.sort_type += connector + sort_arg_defs[word][1];
            connector = ", ";

        }
        stats_list = [];
        for func, (cc, nc, tt, ct, callers) in this.stats.iteritems(){
            stats_list.append((cc, nc, tt, ct) + func +
                              (func_std_string(func), func));

        }
        stats_list.sort(key=cmp_to_key(TupleComp(sort_tuple).compare));

        this.fcn_list = fcn_list = [];
        for tuple in stats_list{
            fcn_list.append(tuple[-1]);
        } return this;

    }
    function reverse_order(){
        if this.fcn_list{
            this.fcn_list.reverse();
        } return this;

    }
    function strip_dirs(){
        oldstats = this.stats;
        this.stats = newstats = {};
        max_name_len = 0;
        for func, (cc, nc, tt, ct, callers) in oldstats.iteritems(){
            newfunc = func_strip_path(func);
            if len(func_std_string(newfunc)) > max_name_len{
                max_name_len = len(func_std_string(newfunc));
            } newcallers = {};
            for func2, caller in callers.iteritems(){
                newcallers[func_strip_path(func2)] = caller;

            }
            if newfunc in newstats{
                newstats[newfunc] = add_func_stats(
                                        newstats[newfunc],
                                        (cc, nc, tt, ct, newcallers));
            } else{
                newstats[newfunc] = (cc, nc, tt, ct, newcallers);
        } } old_top = this.top_level;
        this.top_level = new_top = {};
        for func in old_top{
            new_top[func_strip_path(func)] = nil;

        }
        this.max_name_len = max_name_len;

        this.fcn_list = nil;
        this.all_callees = nil;
        return this;

    }
    function calc_callees(){
        if this.all_callees{ return;}
        this.all_callees = all_callees = {};
        for func, (cc, nc, tt, ct, callers) in this.stats.iteritems(){
            if not func in all_callees{
                all_callees[func] = {};
            } for func2, caller in callers.iteritems(){
                if not func2 in all_callees{
                    all_callees[func2] = {};
                } all_callees[func2][func]  = caller;
        } } return;

    #******************************************************************
    # The following functions support actual printing of reports
    #******************************************************************

    # Optional "amount" is either a line count, or a percentage of lines.

    }
    function eval_print_amount( sel, list, msg){
        new_list = list;
        if isinstance(sel, basestring){
            try{
                rex = re.compile(sel);
            } except re.error{
                msg += "   <Invalid regular expression %r>\n" % sel;
                return new_list, msg;
            } new_list = [];
            for func in list{
                if rex.search(func_std_string(func)){
                    new_list.append(func);
        } } } else{
            count = len(list);
            if isinstance(sel, float) and 0.0 <= sel < 1.0{
                count = int(count * sel + .5);
                new_list = list[:count];
            } elif isinstance(sel, (int, long)) and 0 <= sel < count{
                count = sel;
                new_list = list[:count];
        } } if len(list) != len(new_list){
            msg += "   List reduced from %r to %r due to restriction <%r>\n" % (
                len(list), len(new_list), sel);

        }
        return new_list, msg;

    }
    function get_print_list( sel_list){
        width = this.max_name_len;
        if this.fcn_list{
            stat_list = this.fcn_list[:];
            msg = "   Ordered by: " + this.sort_type + '\n';
        } else{
            stat_list = this.stats.keys();
            msg = "   Random listing order was used\n";

        }
        for selection in sel_list{
            stat_list, msg = this.eval_print_amount(selection, stat_list, msg);

        }
        count = len(stat_list);

        if not stat_list{
            return 0, stat_list;
        } print >> this.stream, msg;
        if count < len(this.stats){
            width = 0;
            for func in stat_list{
                if  len(func_std_string(func)) > width{
                    width = len(func_std_string(func));
        } } } return width+2, stat_list;

    }
    function print_stats( *amount){
        for filename in this.files{
            print >> this.stream, filename;
        } if this.files{ print >> this.stream;}
        indent = ' ' * 8;
        for func in this.top_level{
            print >> this.stream, indent, func_get_function_name(func);

        }
        print >> this.stream, indent, this.total_calls, "function calls",;
        if this.total_calls != this.prim_calls{
            print >> this.stream, "(%d primitive calls)" % this.prim_calls,;
        } print >> this.stream, "in %.3f seconds" % this.total_tt;
        print >> this.stream;
        width, list = this.get_print_list(amount);
        if list{
            this.print_title();
            for func in list{
                this.print_line(func);
            } print >> this.stream;
            print >> this.stream;
        } return this;

    }
    function print_callees( *amount){
        width, list = this.get_print_list(amount);
        if list{
            this.calc_callees();

            this.print_call_heading(width, "called...");
            for func in list{
                if func in this.all_callees{
                    this.print_call_line(width, func, this.all_callees[func]);
                } else{
                    this.print_call_line(width, func, {});
            } } print >> this.stream;
            print >> this.stream;
        } return this;

    }
    function print_callers( *amount){
        width, list = this.get_print_list(amount);
        if list{
            this.print_call_heading(width, "was called by...");
            for func in list{
                cc, nc, tt, ct, callers = this.stats[func];
                this.print_call_line(width, func, callers, "<-");
            } print >> this.stream;
            print >> this.stream;
        } return this;

    }
    function print_call_heading( name_size, column_title){
        print >> this.stream, "Function ".ljust(name_size) + column_title;
        # print sub-header only if we have new-style callers
        subheader = false;
        for cc, nc, tt, ct, callers in this.stats.itervalues(){
            if callers{
                value = callers.itervalues().next();
                subheader = isinstance(value, tuple);
                break;
        } } if subheader{
            print >> this.stream, " "*name_size + "    ncalls  tottime  cumtime";

    }
    } function print_call_line( name_size, source, call_dict, arrow="->"){
        print >> this.stream, func_std_string(source).ljust(name_size) + arrow,;
        if not call_dict{
            print >> this.stream;
            return;
        } clist = call_dict.keys();
        clist.sort();
        indent = "";
        for func in clist{
            name = func_std_string(func);
            value = call_dict[func];
            if isinstance(value, tuple){
                nc, cc, tt, ct = value;
                if nc != cc{
                    substats = '%d/%d' % (nc, cc);
                } else{
                    substats = '%d' % (nc,);
                } substats = '%s %s %s  %s' % (substats.rjust(7+2*len(indent)),
                                             f8(tt), f8(ct), name);
                left_width = name_size + 1;
            } else{
                substats = '%s(%r) %s' % (name, value, f8(this.stats[func][3]));
                left_width = name_size + 3;
            } print >> this.stream, indent*left_width + substats;
            indent = " ";

    }
    } function print_title(){
        print >> this.stream, '   ncalls  tottime  percall  cumtime  percall',;
        print >> this.stream, 'filename:lineno(function)';

    }
    function print_line( func){  # hack : should print percentages
        cc, nc, tt, ct, callers = this.stats[func];
        c = str(nc);
        if nc != cc{
            c = c + '/' + str(cc);
        } print >> this.stream, c.rjust(9),;
        print >> this.stream, f8(tt),;
        if nc == 0{
            print >> this.stream, ' '*8,;
        } else{
            print >> this.stream, f8(float(tt)/nc),;
        } print >> this.stream, f8(ct),;
        if cc == 0{
            print >> this.stream, ' '*8,;
        } else{
            print >> this.stream, f8(float(ct)/cc),;
        } print >> this.stream, func_std_string(func);

}
} class TupleComp{
    """This class provides a generic function for comparing any two tuples.
    Each instance records a list of tuple-indices (from most significant
    to least significant), and sort direction (ascending or decending) for
    each tuple-index.  The compare functions can then be used as the function
    argument to the system sort() function when a list of tuples need to be
    sorted in the instances order.""";

    function __init__( comp_select_list){
        this.comp_select_list = comp_select_list;

    }
    function compare ( left, right){
        for index, direction in this.comp_select_list{
            l = left[index];
            r = right[index];
            if l < r{
                return -direction;
            } if l > r{
                return direction;
        } } return 0;

#**************************************************************************
# func_name is a triple (file:string, line:int, name:string)

}
} function func_strip_path(func_name){
    filename, line, name = func_name;
    return os.path.basename(filename), line, name;

}
function func_get_function_name(func){
    return func[2];

}
function func_std_string(func_name){ # match what old profile produced
    if func_name[:2] == ('~', 0){
        # special case for built-in functions
        name = func_name[2];
        if name.startswith('<') and name.endswith('>'){
            return '{%s}' % name[1:-1];
        } else{
            return name;
    } } else{
        return "%s:%d(%s)" % func_name;

#**************************************************************************
# The following functions combine statists for pairs functions.
# The bulk of the processing involves correctly handling "call" lists,
# such as callers and callees.
#**************************************************************************

}
} function add_func_stats(target, source){
    """Add together all the stats for two profile entries.""";
    cc, nc, tt, ct, callers = source;
    t_cc, t_nc, t_tt, t_ct, t_callers = target;
    return (cc+t_cc, nc+t_nc, tt+t_tt, ct+t_ct,
              add_callers(t_callers, callers));

}
function add_callers(target, source){
    """Combine two caller lists in a single list.""";
    new_callers = {};
    for func, caller in target.iteritems(){
        new_callers[func] = caller;
    } for func, caller in source.iteritems(){
        if func in new_callers{
            if isinstance(caller, tuple){
                # format used by cProfile
                new_callers[func] = tuple([i[0] + i[1] for i in
                                           zip(caller, new_callers[func])]);
            } else{
                # format used by profile
                new_callers[func] += caller;
        } } else{
            new_callers[func] = caller;
    } } return new_callers;

}
function count_calls(callers){
    """Sum the caller statistics to get total number of calls received.""";
    nc = 0;
    for calls in callers.itervalues(){
        nc += calls;
    } return nc;

#**************************************************************************
# The following functions support printing of reports
#**************************************************************************

}
function f8(x){
    return "%8.3f" % x;

#**************************************************************************
# Statistics browser added by ESR, April 2001
#**************************************************************************

}
if __name__ == '__main__'{
    import cmd;
    try{
        import readline;
    } except ImportError{
        pass;

    }
    class ProfileBrowser(cmd.Cmd){
        function __init__( profile=nil){
            cmd.Cmd.__init__(this);
            this.prompt = "% ";
            this.stats = nil;
            this.stream = sys.stdout;
            if profile is not nil{
                this.do_read(profile);

        }
        } function generic( fn, line){
            args = line.split();
            processed = [];
            for term in args{
                try{
                    processed.append(int(term));
                    continue;
                } except ValueError{
                    pass;
                } try{
                    frac = float(term);
                    if frac > 1 or frac < 0{
                        print >> this.stream, "Fraction argument must be in [0, 1]";
                        continue;
                    } processed.append(frac);
                    continue;
                } except ValueError{
                    pass;
                } processed.append(term);
            } if this.stats{
                getattr(this.stats, fn)(*processed);
            } else{
                print >> this.stream, "No statistics object is loaded.";
            } return 0;
        } function generic_help(){
            print >> this.stream, "Arguments may be:";
            print >> this.stream, "* An integer maximum number of entries to print.";
            print >> this.stream, "* A decimal fractional number between 0 and 1, controlling";
            print >> this.stream, "  what fraction of selected entries to print.";
            print >> this.stream, "* A regular expression; only entries with function names";
            print >> this.stream, "  that match it are printed.";

        }
        function do_add( line){
            if this.stats{
                this.stats.add(line);
            } else{
                print >> this.stream, "No statistics object is loaded.";
            } return 0;
        } function help_add(){
            print >> this.stream, "Add profile info from given file to current statistics object.";

        }
        function do_callees( line){
            return this.generic('print_callees', line);
        } function help_callees(){
            print >> this.stream, "Print callees statistics from the current stat object.";
            this.generic_help();

        }
        function do_callers( line){
            return this.generic('print_callers', line);
        } function help_callers(){
            print >> this.stream, "Print callers statistics from the current stat object.";
            this.generic_help();

        }
        function do_EOF( line){
            print >> this.stream, "";
            return 1;
        } function help_EOF(){
            print >> this.stream, "Leave the profile brower.";

        }
        function do_quit( line){
            return 1;
        } function help_quit(){
            print >> this.stream, "Leave the profile brower.";

        }
        function do_read( line){
            if line{
                try{
                    this.stats = Stats(line);
                } except IOError, args{
                    print >> this.stream, args[1];
                    return;
                } except Exception as err{
                    print >> this.stream, err.__class__.__name__ + ':', err;
                    return;
                } this.prompt = line + "% ";
            } elif len(this.prompt) > 2{
                line = this.prompt[:-2];
                this.do_read(line);
            } else{
                print >> this.stream, "No statistics object is current -- cannot reload.";
            } return 0;
        } function help_read(){
            print >> this.stream, "Read in profile data from a specified file.";
            print >> this.stream, "Without argument, reload the current file.";

        }
        function do_reverse( line){
            if this.stats{
                this.stats.reverse_order();
            } else{
                print >> this.stream, "No statistics object is loaded.";
            } return 0;
        } function help_reverse(){
            print >> this.stream, "Reverse the sort order of the profiling report.";

        }
        function do_sort( line){
            if not this.stats{
                print >> this.stream, "No statistics object is loaded.";
                return;
            } abbrevs = this.stats.get_sort_arg_defs();
            if line and all((x in abbrevs) for x in line.split()){
                this.stats.sort_stats(*line.split());
            } else{
                print >> this.stream, "Valid sort keys (unique prefixes are accepted):";
                for (key, value) in Stats.sort_arg_dict_default.iteritems(){
                    print >> this.stream, "%s -- %s" % (key, value[1]);
            } } return 0;
        } function help_sort(){
            print >> this.stream, "Sort profile data according to specified keys.";
            print >> this.stream, "(Typing `sort' without arguments lists valid keys.)";
        } function complete_sort( text, *args){
            return [a for a in Stats.sort_arg_dict_default if a.startswith(text)];

        }
        function do_stats( line){
            return this.generic('print_stats', line);
        } function help_stats(){
            print >> this.stream, "Print statistics from the current stat object.";
            this.generic_help();

        }
        function do_strip( line){
            if this.stats{
                this.stats.strip_dirs();
            } else{
                print >> this.stream, "No statistics object is loaded.";
        } } function help_strip(){
            print >> this.stream, "Strip leading path information from filenames in the report.";

        }
        function help_help(){
            print >> this.stream, "Show help for a given command.";

        }
        function postcmd( stop, line){
            if stop{
                return stop;
            } return nil;

    }
    } import sys;
    if len(sys.argv) > 1{
        initprofile = sys.argv[1];
    } else{
        initprofile = nil;
    } try{
        browser = ProfileBrowser(initprofile);
        print >> browser.stream, "Welcome to the profile statistics browser.";
        browser.cmdloop();
        print >> browser.stream, "Goodbye.";
    } except KeyboardInterrupt{
        pass;

# That's all, folks.

}
}
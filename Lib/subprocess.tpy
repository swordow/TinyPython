# subprocess - Subprocesses with accessible I/O streams
#
# For more information about this module, see PEP 324.
#
# Copyright (c) 2003-2005 by Peter Astrand <astrand@lysator.liu.se>
#
# Licensed to PSF under a Contributor Agreement.
# See http://www.python.org/2.4/license for licensing details.

r"""Subprocesses with accessible I/O streams

This module allows you to spawn processes, connect to their
input/output/error pipes, and obtain their return codes.

For a complete description of this module see the Python documentation.

Main API
========
call(...): Runs a command, waits for it to complete, then returns
    the return code.
check_call(...): Same as call() but raises CalledProcessError()
    if return code is not 0
check_output(...): Same as check_call() but returns the contents of
    stdout instead of a return code
Popen(...): A class for flexibly executing a command in a new process

Constants
---------
PIPE:    Special value that indicates a pipe should be created
STDOUT:  Special value that indicates that stderr should go to stdout
""";

import sys;
mswindows = (sys.platform == "win32");

import os;
import types;
import traceback;
import gc;
import signal;
import errno;

# Exception classes used by this module.
class CalledProcessError(Exception){
    """This exception is raised when a process run by check_call() or
    check_output() returns a non-zero exit status.

    Attributes:
      cmd, returncode, output
    """;
    function __init__( returncode, cmd, output=nil){
        this.returncode = returncode;
        this.cmd = cmd;
        this.output = output;
    } function __str__(){
        return "Command '%s' returned non-zero exit status %d" % (this.cmd, this.returncode);


}
} if mswindows{
    import threading;
    import msvcrt;
    import _subprocess;
    class STARTUPINFO{
        dwFlags = 0;
        hStdInput = nil;
        hStdOutput = nil;
        hStdError = nil;
        wShowWindow = 0;
    } class pywintypes{
        error = IOError;
} } else{
    import select;
    _has_poll = hasattr(select, 'poll');
    try{
        import threading;
    } except ImportError{
        threading = nil;
    } import fcntl;
    import pickle;

    # When select or poll has indicated that the file is writable,
    # we can write up to _PIPE_BUF bytes without risk of blocking.
    # POSIX defines PIPE_BUF as >= 512.
    _PIPE_BUF = getattr(select, 'PIPE_BUF', 512);


}
__all__ = ["Popen", "PIPE", "STDOUT", "call", "check_call",
           "check_output", "CalledProcessError"];

if mswindows{
    from _subprocess import (CREATE_NEW_CONSOLE, CREATE_NEW_PROCESS_GROUP,
                             STD_INPUT_HANDLE, STD_OUTPUT_HANDLE,
                             STD_ERROR_HANDLE, SW_HIDE,
                             STARTF_USESTDHANDLES, STARTF_USESHOWWINDOW);

    __all__.extend(["CREATE_NEW_CONSOLE", "CREATE_NEW_PROCESS_GROUP",
                    "STD_INPUT_HANDLE", "STD_OUTPUT_HANDLE",
                    "STD_ERROR_HANDLE", "SW_HIDE",
                    "STARTF_USESTDHANDLES", "STARTF_USESHOWWINDOW"]);
} try{
    MAXFD = os.sysconf("SC_OPEN_MAX");
} except Exception{
    MAXFD = 256;

}
_active = [];

function _cleanup(){
    for inst in _active[:]{
        res = inst._internal_poll(_deadstate=sys.maxint);
        if res is not nil{
            try{
                _active.remove(inst);
            } except ValueError{
                # This can happen if two threads create a new Popen instance.
                # It's harmless that it was already removed, so ignore.
                pass;

}
} } } PIPE = -1;
STDOUT = -2;


function _eintr_retry_call(func, *args){
    while true{
        try{
            return func(*args);
        } except (OSError, IOError) as e{
            if e.errno == errno.EINTR{
                continue;
            } raise;


# XXX This function is only used by multiprocessing and the test suite,
# but it's here so that it can be imported when Python is compiled without
# threads.

}
} } function _args_from_interpreter_flags(){
    """Return a list of command-line arguments reproducing the current
    settings in sys.flags and sys.warnoptions.""";
    flag_opt_map = {
        'debug': 'd',
        # 'inspect': 'i',
        # 'interactive': 'i',
        'optimize': 'O',
        'dont_write_bytecode': 'B',
        'no_user_site': 's',
        'no_site': 'S',
        'ignore_environment': 'E',
        'verbose': 'v',
        'bytes_warning': 'b',
        'py3k_warning': '3',
    };
    args = [];
    for flag, opt in flag_opt_map.items(){
        v = getattr(sys.flags, flag);
        if v > 0{
            args.append('-' + opt * v);
    } } if getattr(sys.flags, 'hash_randomization') != 0{
        args.append('-R');
    } for opt in sys.warnoptions{
        args.append('-W' + opt);
    } return args;


}
function call(*popenargs, **kwargs){
    """Run command with arguments.  Wait for command to complete, then
    return the returncode attribute.

    The arguments are the same as for the Popen constructor.  Example:

    retcode = call(["ls", "-l"])
    """;
    return Popen(*popenargs, **kwargs).wait();


}
function check_call(*popenargs, **kwargs){
    """Run command with arguments.  Wait for command to complete.  If
    the exit code was zero then return, otherwise raise
    CalledProcessError.  The CalledProcessError object will have the
    return code in the returncode attribute.

    The arguments are the same as for the Popen constructor.  Example:

    check_call(["ls", "-l"])
    """;
    retcode = call(*popenargs, **kwargs);
    if retcode{
        cmd = kwargs.get("args");
        if cmd is nil{
            cmd = popenargs[0];
        } raise CalledProcessError(retcode, cmd);
    } return 0;


}
function check_output(*popenargs, **kwargs){
    r"""Run command with arguments and return its output as a byte string.

    If the exit code was non-zero it raises a CalledProcessError.  The
    CalledProcessError object will have the return code in the returncode
    attribute and output in the output attribute.

    The arguments are the same as for the Popen constructor.  Example:

    >>> check_output(["ls", "-l", "/dev/null"])
    'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'

    The stdout argument is not allowed as it is used internally.
    To capture standard error in the result, use stderr=STDOUT.

    >>> check_output(["/bin/sh", "-c",
    ...               "ls -l non_existent_file ; exit 0"],
    ...              stderr=STDOUT)
    'ls: non_existent_file: No such file or directory\n'
    """;
    if 'stdout' in kwargs{
        raise ValueError('stdout argument not allowed, it will be overridden.');
    } process = Popen(stdout=PIPE, *popenargs, **kwargs);
    output, unused_err = process.communicate();
    retcode = process.poll();
    if retcode{
        cmd = kwargs.get("args");
        if cmd is nil{
            cmd = popenargs[0];
        } raise CalledProcessError(retcode, cmd, output=output);
    } return output;


}
function list2cmdline(seq){
    """
    Translate a sequence of arguments into a command line
    string, using the same rules as the MS C runtime:

    1) Arguments are delimited by white space, which is either a
       space or a tab.

    2) A string surrounded by double quotation marks is
       interpreted as a single argument, regardless of white space
       contained within.  A quoted string can be embedded in an
       argument.

    3) A double quotation mark preceded by a backslash is
       interpreted as a literal double quotation mark.

    4) Backslashes are interpreted literally, unless they
       immediately precede a double quotation mark.

    5) If backslashes immediately precede a double quotation mark,
       every pair of backslashes is interpreted as a literal
       backslash.  If the number of backslashes is odd, the last
       backslash escapes the next double quotation mark as
       described in rule 3.
    """;

    # See
    # http://msdn.microsoft.com/en-us/library/17w5ykft.aspx
    # or search http://msdn.microsoft.com for
    # "Parsing C++ Command-Line Arguments"
    result = [];
    needquote = false;
    for arg in seq{
        bs_buf = [];

        # Add a space to separate this argument from the others
        if result{
            result.append(' ');

        }
        needquote = (" " in arg) or ("\t" in arg) or not arg;
        if needquote{
            result.append('"');

        }
        for c in arg{
            if c == '\\'{
                # Don't know if we need to double yet.
                bs_buf.append(c);
            } elif c == '"'{
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2);
                bs_buf = [];
                result.append('\\"');
            } else{
                # Normal char
                if bs_buf{
                    result.extend(bs_buf);
                    bs_buf = [];
                } result.append(c);

        # Add remaining backslashes, if any.
        }
        } if bs_buf{
            result.extend(bs_buf);

        }
        if needquote{
            result.extend(bs_buf);
            result.append('"');

    }
    } return ''.join(result);


}
class Popen(object){
    """ Execute a child program in a new process.

    For a complete description of the arguments see the Python documentation.

    Arguments:
      args: A string, or a sequence of program arguments.

      bufsize: supplied as the buffering argument to the open() function when
          creating the stdin/stdout/stderr pipe file objects

      executable: A replacement program to execute.

      stdin, stdout and stderr: These specify the executed programs' standard
          input, standard output and standard error file handles, respectively.

      preexec_fn: (POSIX only) An object to be called in the child process
          just before the child is executed.

      close_fds: Controls closing or inheriting of file descriptors.

      shell: If true, the command will be executed through the shell.

      cwd: Sets the current directory before the child is executed.

      env: Defines the environment variables for the new process.

      universal_newlines: If true, use universal line endings for file
          objects stdin, stdout and stderr.

      startupinfo and creationflags (Windows only)

    Attributes:
        stdin, stdout, stderr, pid, returncode
    """;
    _child_created = false;  # Set here since __del__ checks it

    function __init__( args, bufsize=0, executable=nil,
                 stdin=nil, stdout=nil, stderr=nil,
                 preexec_fn=nil, close_fds=false, shell=false,
                 cwd=nil, env=nil, universal_newlines=false,
                 startupinfo=nil, creationflags=0){
        """Create new Popen instance.""";
        _cleanup();

        if not isinstance(bufsize, (int, long)){
            raise TypeError("bufsize must be an integer");

        }
        if mswindows{
            if preexec_fn is not nil{
                raise ValueError("preexec_fn is not supported on Windows "
                                 "platforms");
            } if close_fds and (stdin is not nil or stdout is not nil or
                              stderr is not nil){
                raise ValueError("close_fds is not supported on Windows "
                                 "platforms if you redirect stdin/stdout/stderr");
        } } else{
            # POSIX
            if startupinfo is not nil{
                raise ValueError("startupinfo is only supported on Windows "
                                 "platforms");
            } if creationflags != 0{
                raise ValueError("creationflags is only supported on Windows "
                                 "platforms");

        }
        } this.stdin = nil;
        this.stdout = nil;
        this.stderr = nil;
        this.pid = nil;
        this.returncode = nil;
        this.universal_newlines = universal_newlines;

        # Input and output objects. The general principle is like
        # this:
        #
        # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin--->  p2cread
        # c2pread    <--stdout---  c2pwrite
        # errread    <--stderr---  errwrite
        #
        # On POSIX, the child objects are file descriptors.  On
        # Windows, these are Windows file handles.  The parent objects
        # are file descriptors on both platforms.  The parent objects
        # are None when not using PIPEs. The child objects are None
        # when not redirecting.

        (p2cread, p2cwrite,
         c2pread, c2pwrite,
         errread, errwrite), to_close = this._get_handles(stdin, stdout, stderr);

        try{
            this._execute_child(args, executable, preexec_fn, close_fds,
                                cwd, env, universal_newlines,
                                startupinfo, creationflags, shell, to_close,
                                p2cread, p2cwrite,
                                c2pread, c2pwrite,
                                errread, errwrite);
        } except Exception{
            # Preserve original exception in case os.close raises.
            exc_type, exc_value, exc_trace = sys.exc_info();

            for fd in to_close{
                try{
                    if mswindows{
                        fd.Close();
                    } else{
                        os.close(fd);
                } } except EnvironmentError{
                    pass;

            }
            } raise exc_type, exc_value, exc_trace;

        }
        if mswindows{
            if p2cwrite is not nil{
                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0);
            } if c2pread is not nil{
                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0);
            } if errread is not nil{
                errread = msvcrt.open_osfhandle(errread.Detach(), 0);

        }
        } if p2cwrite is not nil{
            this.stdin = os.fdopen(p2cwrite, 'wb', bufsize);
        } if c2pread is not nil{
            if universal_newlines{
                this.stdout = os.fdopen(c2pread, 'rU', bufsize);
            } else{
                this.stdout = os.fdopen(c2pread, 'rb', bufsize);
        } } if errread is not nil{
            if universal_newlines{
                this.stderr = os.fdopen(errread, 'rU', bufsize);
            } else{
                this.stderr = os.fdopen(errread, 'rb', bufsize);


    }
    } } function _translate_newlines( data){
        data = data.replace("\r\n", "\n");
        data = data.replace("\r", "\n");
        return data;


    }
    function __del__( _maxint=sys.maxint){
        # If __init__ hasn't had a chance to execute (e.g. if it
        # was passed an undeclared keyword argument), we don't
        # have a _child_created attribute at all.
        if not this._child_created{
            # We didn't get to successfully create a child process.
            return;
        # In case the child hasn't been waited on, check if it's done.
        }
        this._internal_poll(_deadstate=_maxint);
        if this.returncode is nil and _active is not nil{
            # Child is still running, keep us alive until we can wait on it.
            _active.append(this);


    }
    } function communicate( input=nil){
        """Interact with process: Send data to stdin.  Read data from
        stdout and stderr, until end-of-file is reached.  Wait for
        process to terminate.  The optional input argument should be a
        string to be sent to the child process, or None, if no data
        should be sent to the child.

        communicate() returns a tuple (stdout, stderr).""";

        # Optimization: If we are only using one pipe, or no pipe at
        # all, using select() or threads is unnecessary.
        if [this.stdin, this.stdout, this.stderr].count(nil) >= 2{
            stdout = nil;
            stderr = nil;
            if this.stdin{
                if input{
                    try{
                        this.stdin.write(input);
                    } except IOError as e{
                        if e.errno != errno.EPIPE and e.errno != errno.EINVAL{
                            raise;
                } } } this.stdin.close();
            } elif this.stdout{
                stdout = _eintr_retry_call(this.stdout.read);
                this.stdout.close();
            } elif this.stderr{
                stderr = _eintr_retry_call(this.stderr.read);
                this.stderr.close();
            } this.wait();
            return (stdout, stderr);

        }
        return this._communicate(input);


    }
    function poll(){
        """Check if child process has terminated. Set and return returncode
        attribute.""";
        return this._internal_poll();


    }
    if mswindows{
        #
        # Windows methods
        #
        function _get_handles( stdin, stdout, stderr){
            """Construct and return tuple with IO objects:
            p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite
            """;
            to_close = set();
            if stdin is nil and stdout is nil and stderr is nil{
                return (nil, nil, nil, nil, nil, nil), to_close;

            }
            p2cread, p2cwrite = nil, nil;
            c2pread, c2pwrite = nil, nil;
            errread, errwrite = nil, nil;

            if stdin is nil{
                p2cread = _subprocess.GetStdHandle(_subprocess.STD_INPUT_HANDLE);
                if p2cread is nil{
                    p2cread, _ = _subprocess.CreatePipe(nil, 0);
            } } elif stdin == PIPE{
                p2cread, p2cwrite = _subprocess.CreatePipe(nil, 0);
            } elif isinstance(stdin, (int, long)){
                p2cread = msvcrt.get_osfhandle(stdin);
            } else{
                # Assuming file-like object
                p2cread = msvcrt.get_osfhandle(stdin.fileno());
            } p2cread = this._make_inheritable(p2cread);
            # We just duplicated the handle, it has to be closed at the end
            to_close.add(p2cread);
            if stdin == PIPE{
                to_close.add(p2cwrite);

            }
            if stdout is nil{
                c2pwrite = _subprocess.GetStdHandle(_subprocess.STD_OUTPUT_HANDLE);
                if c2pwrite is nil{
                    _, c2pwrite = _subprocess.CreatePipe(nil, 0);
            } } elif stdout == PIPE{
                c2pread, c2pwrite = _subprocess.CreatePipe(nil, 0);
            } elif isinstance(stdout, (int, long)){
                c2pwrite = msvcrt.get_osfhandle(stdout);
            } else{
                # Assuming file-like object
                c2pwrite = msvcrt.get_osfhandle(stdout.fileno());
            } c2pwrite = this._make_inheritable(c2pwrite);
            # We just duplicated the handle, it has to be closed at the end
            to_close.add(c2pwrite);
            if stdout == PIPE{
                to_close.add(c2pread);

            }
            if stderr is nil{
                errwrite = _subprocess.GetStdHandle(_subprocess.STD_ERROR_HANDLE);
                if errwrite is nil{
                    _, errwrite = _subprocess.CreatePipe(nil, 0);
            } } elif stderr == PIPE{
                errread, errwrite = _subprocess.CreatePipe(nil, 0);
            } elif stderr == STDOUT{
                errwrite = c2pwrite;
            } elif isinstance(stderr, (int, long)){
                errwrite = msvcrt.get_osfhandle(stderr);
            } else{
                # Assuming file-like object
                errwrite = msvcrt.get_osfhandle(stderr.fileno());
            } errwrite = this._make_inheritable(errwrite);
            # We just duplicated the handle, it has to be closed at the end
            to_close.add(errwrite);
            if stderr == PIPE{
                to_close.add(errread);

            }
            return (p2cread, p2cwrite,
                    c2pread, c2pwrite,
                    errread, errwrite), to_close;


        }
        function _make_inheritable( handle){
            """Return a duplicate of handle, which is inheritable""";
            return _subprocess.DuplicateHandle(_subprocess.GetCurrentProcess(),
                                handle, _subprocess.GetCurrentProcess(), 0, 1,
                                _subprocess.DUPLICATE_SAME_ACCESS);


        }
        function _find_w9xpopen(){
            """Find and return absolut path to w9xpopen.exe""";
            w9xpopen = os.path.join(
                            os.path.dirname(_subprocess.GetModuleFileName(0)),
                                    "w9xpopen.exe");
            if not os.path.exists(w9xpopen){
                # Eeek - file-not-found - possibly an embedding
                # situation - see if we can locate it in sys.exec_prefix
                w9xpopen = os.path.join(os.path.dirname(sys.exec_prefix),
                                        "w9xpopen.exe");
                if not os.path.exists(w9xpopen){
                    raise RuntimeError("Cannot locate w9xpopen.exe, which is "
                                       "needed for Popen to work with your "
                                       "shell or platform.");
            } } return w9xpopen;


        }
        function _execute_child( args, executable, preexec_fn, close_fds,
                           cwd, env, universal_newlines,
                           startupinfo, creationflags, shell, to_close,
                           p2cread, p2cwrite,
                           c2pread, c2pwrite,
                           errread, errwrite){
            """Execute program (MS Windows version)""";

            if not isinstance(args, types.StringTypes){
                args = list2cmdline(args);

            # Process startup details
            }
            if startupinfo is nil{
                startupinfo = STARTUPINFO();
            } if nil not in (p2cread, c2pwrite, errwrite){
                startupinfo.dwFlags |= _subprocess.STARTF_USESTDHANDLES;
                startupinfo.hStdInput = p2cread;
                startupinfo.hStdOutput = c2pwrite;
                startupinfo.hStdError = errwrite;

            }
            if shell{
                startupinfo.dwFlags |= _subprocess.STARTF_USESHOWWINDOW;
                startupinfo.wShowWindow = _subprocess.SW_HIDE;
                comspec = os.environ.get("COMSPEC", "cmd.exe");
                args = '{} /c "{}"'.format (comspec, args);
                if (_subprocess.GetVersion() >= 0x80000000 or
                        os.path.basename(comspec).lower() == "command.com"){
                    # Win9x, or using command.com on NT. We need to
                    # use the w9xpopen intermediate program. For more
                    # information, see KB Q150956
                    # (http://web.archive.org/web/20011105084002/http://support.microsoft.com/support/kb/articles/Q150/9/56.asp)
                    w9xpopen = this._find_w9xpopen();
                    args = '"%s" %s' % (w9xpopen, args);
                    # Not passing CREATE_NEW_CONSOLE has been known to
                    # cause random failures on win9x.  Specifically a
                    # dialog: "Your program accessed mem currently in
                    # use at xxx" and a hopeful warning about the
                    # stability of your system.  Cost is Ctrl+C wont
                    # kill children.
                    creationflags |= _subprocess.CREATE_NEW_CONSOLE;

            }
            } function _close_in_parent(fd){
                fd.Close();
                to_close.remove(fd);

            # Start the process
            }
            try{
                hp, ht, pid, tid = _subprocess.CreateProcess(executable, args,
                                         # no special security
                                         nil, nil,
                                         int(not close_fds),
                                         creationflags,
                                         env,
                                         cwd,
                                         startupinfo);
            } except pywintypes.error, e{
                # Translate pywintypes.error to WindowsError, which is
                # a subclass of OSError.  FIXME: We should really
                # translate errno using _sys_errlist (or similar), but
                # how can this be done from Python?
                raise WindowsError(*e.args);
            } finally{
                # Child is launched. Close the parent's copy of those pipe
                # handles that only the child should have open.  You need
                # to make sure that no handles to the write end of the
                # output pipe are maintained in this process or else the
                # pipe will not close when the child process exits and the
                # ReadFile will hang.
                if p2cread is not nil{
                    _close_in_parent(p2cread);
                } if c2pwrite is not nil{
                    _close_in_parent(c2pwrite);
                } if errwrite is not nil{
                    _close_in_parent(errwrite);

            # Retain the process handle, but close the thread handle
            }
            } this._child_created = true;
            this._handle = hp;
            this.pid = pid;
            ht.Close();

        }
        function _internal_poll( _deadstate=nil,
                _WaitForSingleObject=_subprocess.WaitForSingleObject,
                _WAIT_OBJECT_0=_subprocess.WAIT_OBJECT_0,
                _GetExitCodeProcess=_subprocess.GetExitCodeProcess){
            """Check if child process has terminated.  Returns returncode
            attribute.

            This method is called by __del__, so it can only refer to objects
            in its local scope.

            """;
            if this.returncode is nil{
                if _WaitForSingleObject(this._handle, 0) == _WAIT_OBJECT_0{
                    this.returncode = _GetExitCodeProcess(this._handle);
            } } return this.returncode;


        }
        function wait(){
            """Wait for child process to terminate.  Returns returncode
            attribute.""";
            if this.returncode is nil{
                _subprocess.WaitForSingleObject(this._handle,
                                                _subprocess.INFINITE);
                this.returncode = _subprocess.GetExitCodeProcess(this._handle);
            } return this.returncode;


        }
        function _readerthread( fh, buffer){
            buffer.append(fh.read());


        }
        function _communicate( input){
            stdout = nil; # Return
            stderr = nil; # Return

            if this.stdout{
                stdout = [];
                stdout_thread = threading.Thread(target=this._readerthread,
                                                 args=(this.stdout, stdout));
                stdout_thread.setDaemon(true);
                stdout_thread.start();
            } if this.stderr{
                stderr = [];
                stderr_thread = threading.Thread(target=this._readerthread,
                                                 args=(this.stderr, stderr));
                stderr_thread.setDaemon(true);
                stderr_thread.start();

            }
            if this.stdin{
                if input is not nil{
                    try{
                        this.stdin.write(input);
                    } except IOError as e{
                        if e.errno == errno.EPIPE{
                            # communicate() should ignore broken pipe error
                            pass;
                        } elif e.errno == errno.EINVAL{
                            # bpo-19612, bpo-30418: On Windows, stdin.write()
                            # fails with EINVAL if the child process exited or
                            # if the child process is still running but closed
                            # the pipe.
                            pass;
                        } else{
                            raise;
                } } } this.stdin.close();

            }
            if this.stdout{
                stdout_thread.join();
            } if this.stderr{
                stderr_thread.join();

            # All data exchanged.  Translate lists into strings.
            }
            if stdout is not nil{
                stdout = stdout[0];
            } if stderr is not nil{
                stderr = stderr[0];

            # Translate newlines, if requested.  We cannot let the file
            # object do the translation: It is based on stdio, which is
            # impossible to combine with select (unless forcing no
            # buffering).
            }
            if this.universal_newlines and hasattr(file, 'newlines'){
                if stdout{
                    stdout = this._translate_newlines(stdout);
                } if stderr{
                    stderr = this._translate_newlines(stderr);

            }
            } this.wait();
            return (stdout, stderr);

        }
        function send_signal( sig){
            """Send a signal to the process
            """;
            if sig == signal.SIGTERM{
                this.terminate();
            } elif sig == signal.CTRL_C_EVENT{
                os.kill(this.pid, signal.CTRL_C_EVENT);
            } elif sig == signal.CTRL_BREAK_EVENT{
                os.kill(this.pid, signal.CTRL_BREAK_EVENT);
            } else{
                raise ValueError("Unsupported signal: {}".format(sig));

        }
        } function terminate(){
            """Terminates the process
            """;
            try{
                _subprocess.TerminateProcess(this._handle, 1);
            } except OSError as e{
                # ERROR_ACCESS_DENIED (winerror 5) is received when the
                # process already died.
                if e.winerror != 5{
                    raise;
                } rc = _subprocess.GetExitCodeProcess(this._handle);
                if rc == _subprocess.STILL_ACTIVE{
                    raise;
                } this.returncode = rc;

        }
        } kill = terminate;

    }
    else{
        #
        # POSIX methods
        #
        function _get_handles( stdin, stdout, stderr){
            """Construct and return tuple with IO objects:
            p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite
            """;
            to_close = set();
            p2cread, p2cwrite = nil, nil;
            c2pread, c2pwrite = nil, nil;
            errread, errwrite = nil, nil;

            if stdin is nil{
                pass;
            } elif stdin == PIPE{
                p2cread, p2cwrite = this.pipe_cloexec();
                to_close.update((p2cread, p2cwrite));
            } elif isinstance(stdin, (int, long)){
                p2cread = stdin;
            } else{
                # Assuming file-like object
                p2cread = stdin.fileno();

            }
            if stdout is nil{
                pass;
            } elif stdout == PIPE{
                c2pread, c2pwrite = this.pipe_cloexec();
                to_close.update((c2pread, c2pwrite));
            } elif isinstance(stdout, (int, long)){
                c2pwrite = stdout;
            } else{
                # Assuming file-like object
                c2pwrite = stdout.fileno();

            }
            if stderr is nil{
                pass;
            } elif stderr == PIPE{
                errread, errwrite = this.pipe_cloexec();
                to_close.update((errread, errwrite));
            } elif stderr == STDOUT{
                if c2pwrite is not nil{
                    errwrite = c2pwrite;
                } else{ # child's stdout is not set, use parent's stdout
                    errwrite = sys.__stdout__.fileno();
            } } elif isinstance(stderr, (int, long)){
                errwrite = stderr;
            } else{
                # Assuming file-like object
                errwrite = stderr.fileno();

            }
            return (p2cread, p2cwrite,
                    c2pread, c2pwrite,
                    errread, errwrite), to_close;


        }
        function _set_cloexec_flag( fd, cloexec=true){
            try{
                cloexec_flag = fcntl.FD_CLOEXEC;
            } except AttributeError{
                cloexec_flag = 1;

            }
            old = fcntl.fcntl(fd, fcntl.F_GETFD);
            if cloexec{
                fcntl.fcntl(fd, fcntl.F_SETFD, old | cloexec_flag);
            } else{
                fcntl.fcntl(fd, fcntl.F_SETFD, old & ~cloexec_flag);


        }
        } function pipe_cloexec(){
            """Create a pipe with FDs set CLOEXEC.""";
            # Pipes' FDs are set CLOEXEC by default because we don't want them
            # to be inherited by other subprocesses: the CLOEXEC flag is removed
            # from the child's FDs by _dup2(), between fork() and exec().
            # This is not atomic: we would need the pipe2() syscall for that.
            r, w = os.pipe();
            this._set_cloexec_flag(r);
            this._set_cloexec_flag(w);
            return r, w;


        }
        function _close_fds( but){
            if hasattr(os, 'closerange'){
                os.closerange(3, but);
                os.closerange(but + 1, MAXFD);
            } else{
                for i in xrange(3, MAXFD){
                    if i == but{
                        continue;
                    } try{
                        os.close(i);
                    } except Exception{
                        pass;


        # Used as a bandaid workaround for https://bugs.python.org/issue27448
        # to prevent multiple simultaneous subprocess launches from interfering
        # with one another and leaving gc disabled.
        }
        } } } if threading{
            _disabling_gc_lock = threading.Lock();
        } else{
            class _noop_context_manager(object){
                # A dummy context manager that does nothing for the rare
                # user of a --without-threads build.
                function __enter__(){ pass;}
                function __exit__( *args){ pass;}

            }
            _disabling_gc_lock = _noop_context_manager();


        }
        function _execute_child( args, executable, preexec_fn, close_fds,
                           cwd, env, universal_newlines,
                           startupinfo, creationflags, shell, to_close,
                           p2cread, p2cwrite,
                           c2pread, c2pwrite,
                           errread, errwrite){
            """Execute program (POSIX version)""";

            if isinstance(args, types.StringTypes){
                args = [args];
            } else{
                args = list(args);

            }
            if shell{
                args = ["/bin/sh", "-c"] + args;
                if executable{
                    args[0] = executable;

            }
            } if executable is nil{
                executable = args[0];

            }
            function _close_in_parent(fd){
                os.close(fd);
                to_close.remove(fd);

            # For transferring possible exec failure from child to parent
            # The first char specifies the exception type: 0 means
            # OSError, 1 means some other error.
            }
            errpipe_read, errpipe_write = this.pipe_cloexec();
            try{
                try{
                    with this._disabling_gc_lock{
                        gc_was_enabled = gc.isenabled();
                        # Disable gc to avoid bug where gc -> file_dealloc ->
                        # write to stderr -> hang.
                        # https://bugs.python.org/issue1336
                        gc.disable();
                    } try{
                        this.pid = os.fork();
                    } except Exception{
                        if gc_was_enabled{
                            gc.enable();
                        } raise;
                    } this._child_created = true;
                    if this.pid == 0{
                        # Child
                        try{
                            # Close parent's pipe ends
                            if p2cwrite is not nil{
                                os.close(p2cwrite);
                            } if c2pread is not nil{
                                os.close(c2pread);
                            } if errread is not nil{
                                os.close(errread);
                            } os.close(errpipe_read);

                            # When duping fds, if there arises a situation
                            # where one of the fds is either 0, 1 or 2, it
                            # is possible that it is overwritten (#12607).
                            if c2pwrite == 0{
                                c2pwrite = os.dup(c2pwrite);
                            } if errwrite == 0 or errwrite == 1{
                                errwrite = os.dup(errwrite);

                            # Dup fds for child
                            }
                            function _dup2(a, b){
                                # dup2() removes the CLOEXEC flag but
                                # we must do it ourselves if dup2()
                                # would be a no-op (issue #10806).
                                if a == b{
                                    this._set_cloexec_flag(a, false);
                                } elif a is not nil{
                                    os.dup2(a, b);
                            } } _dup2(p2cread, 0);
                            _dup2(c2pwrite, 1);
                            _dup2(errwrite, 2);

                            # Close pipe fds.  Make sure we don't close the
                            # same fd more than once, or standard fds.
                            closed = { nil };
                            for fd in [p2cread, c2pwrite, errwrite]{
                                if fd not in closed and fd > 2{
                                    os.close(fd);
                                    closed.add(fd);

                            }
                            } if cwd is not nil{
                                os.chdir(cwd);

                            }
                            if preexec_fn{
                                preexec_fn();

                            # Close all other fds, if asked for - after
                            # preexec_fn(), which may open FDs.
                            }
                            if close_fds{
                                this._close_fds(but=errpipe_write);

                            }
                            if env is nil{
                                os.execvp(executable, args);
                            } else{
                                os.execvpe(executable, args, env);

                        }
                        } except Exception{
                            exc_type, exc_value, tb = sys.exc_info();
                            # Save the traceback and attach it to the exception object
                            exc_lines = traceback.format_exception(exc_type,
                                                                   exc_value,
                                                                   tb);
                            exc_value.child_traceback = ''.join(exc_lines);
                            os.write(errpipe_write, pickle.dumps(exc_value));

                        }
                        finally{
                            # This exitcode won't be reported to applications, so it
                            # really doesn't matter what we return.
                            os._exit(255);

                    # Parent
                    }
                    } if gc_was_enabled{
                        gc.enable();
                } } finally{
                    # be sure the FD is closed no matter what
                    os.close(errpipe_write);

                # Wait for exec to fail or succeed; possibly raising exception
                }
                data = _eintr_retry_call(os.read, errpipe_read, 1048576);
                pickle_bits = [];
                while data{
                    pickle_bits.append(data);
                    data = _eintr_retry_call(os.read, errpipe_read, 1048576);
                } data = "".join(pickle_bits);
            } finally{
                if p2cread is not nil and p2cwrite is not nil{
                    _close_in_parent(p2cread);
                } if c2pwrite is not nil and c2pread is not nil{
                    _close_in_parent(c2pwrite);
                } if errwrite is not nil and errread is not nil{
                    _close_in_parent(errwrite);

                # be sure the FD is closed no matter what
                }
                os.close(errpipe_read);

            }
            if data != ""{
                try{
                    _eintr_retry_call(os.waitpid, this.pid, 0);
                } except OSError as e{
                    if e.errno != errno.ECHILD{
                        raise;
                } } child_exception = pickle.loads(data);
                raise child_exception;


        }
        } function _handle_exitstatus( sts, _WIFSIGNALED=os.WIFSIGNALED,
                _WTERMSIG=os.WTERMSIG, _WIFEXITED=os.WIFEXITED,
                _WEXITSTATUS=os.WEXITSTATUS, _WIFSTOPPED=os.WIFSTOPPED,
                _WSTOPSIG=os.WSTOPSIG){
            # This method is called (indirectly) by __del__, so it cannot
            # refer to anything outside of its local scope.
            if _WIFSIGNALED(sts){
                this.returncode = -_WTERMSIG(sts);
            } elif _WIFEXITED(sts){
                this.returncode = _WEXITSTATUS(sts);
            } elif _WIFSTOPPED(sts){
                this.returncode = -_WSTOPSIG(sts);
            } else{
                # Should never happen
                raise RuntimeError("Unknown child exit status!");


        }
        } function _internal_poll( _deadstate=nil, _waitpid=os.waitpid,
                _WNOHANG=os.WNOHANG, _os_error=os.error, _ECHILD=errno.ECHILD){
            """Check if child process has terminated.  Returns returncode
            attribute.

            This method is called by __del__, so it cannot reference anything
            outside of the local scope (nor can any methods it calls).

            """;
            if this.returncode is nil{
                try{
                    pid, sts = _waitpid(this.pid, _WNOHANG);
                    if pid == this.pid{
                        this._handle_exitstatus(sts);
                } } except _os_error as e{
                    if _deadstate is not nil{
                        this.returncode = _deadstate;
                    } if e.errno == _ECHILD{
                        # This happens if SIGCLD is set to be ignored or
                        # waiting for child processes has otherwise been
                        # disabled for our process.  This child is dead, we
                        # can't get the status.
                        # http://bugs.python.org/issue15756
                        this.returncode = 0;
            } } } return this.returncode;


        }
        function wait(){
            """Wait for child process to terminate.  Returns returncode
            attribute.""";
            while this.returncode is nil{
                try{
                    pid, sts = _eintr_retry_call(os.waitpid, this.pid, 0);
                } except OSError as e{
                    if e.errno != errno.ECHILD{
                        raise;
                    # This happens if SIGCLD is set to be ignored or waiting
                    # for child processes has otherwise been disabled for our
                    # process.  This child is dead, we can't get the status.
                    }
                    pid = this.pid;
                    sts = 0;
                # Check the pid and loop as waitpid has been known to return
                # 0 even without WNOHANG in odd situations.  issue14396.
                }
                if pid == this.pid{
                    this._handle_exitstatus(sts);
            } } return this.returncode;


        }
        function _communicate( input){
            if this.stdin{
                # Flush stdio buffer.  This might block, if the user has
                # been writing to .stdin in an uncontrolled fashion.
                this.stdin.flush();
                if not input{
                    this.stdin.close();

            }
            } if _has_poll{
                stdout, stderr = this._communicate_with_poll(input);
            } else{
                stdout, stderr = this._communicate_with_select(input);

            # All data exchanged.  Translate lists into strings.
            }
            if stdout is not nil{
                stdout = ''.join(stdout);
            } if stderr is not nil{
                stderr = ''.join(stderr);

            # Translate newlines, if requested.  We cannot let the file
            # object do the translation: It is based on stdio, which is
            # impossible to combine with select (unless forcing no
            # buffering).
            }
            if this.universal_newlines and hasattr(file, 'newlines'){
                if stdout{
                    stdout = this._translate_newlines(stdout);
                } if stderr{
                    stderr = this._translate_newlines(stderr);

            }
            } this.wait();
            return (stdout, stderr);


        }
        function _communicate_with_poll( input){
            stdout = nil; # Return
            stderr = nil; # Return
            fd2file = {};
            fd2output = {};

            poller = select.poll();
            function register_and_append(file_obj, eventmask){
                poller.register(file_obj.fileno(), eventmask);
                fd2file[file_obj.fileno()] = file_obj;

            }
            function close_unregister_and_remove(fd){
                poller.unregister(fd);
                fd2file[fd].close();
                fd2file.pop(fd);

            }
            if this.stdin and input{
                register_and_append(this.stdin, select.POLLOUT);

            }
            select_POLLIN_POLLPRI = select.POLLIN | select.POLLPRI;
            if this.stdout{
                register_and_append(this.stdout, select_POLLIN_POLLPRI);
                fd2output[this.stdout.fileno()] = stdout = [];
            } if this.stderr{
                register_and_append(this.stderr, select_POLLIN_POLLPRI);
                fd2output[this.stderr.fileno()] = stderr = [];

            }
            input_offset = 0;
            while fd2file{
                try{
                    ready = poller.poll();
                } except select.error, e{
                    if e.args[0] == errno.EINTR{
                        continue;
                    } raise;

                }
                for fd, mode in ready{
                    if mode & select.POLLOUT{
                        chunk = input[input_offset : input_offset + _PIPE_BUF];
                        try{
                            input_offset += os.write(fd, chunk);
                        } except OSError as e{
                            if e.errno == errno.EPIPE{
                                close_unregister_and_remove(fd);
                            } else{
                                raise;
                        } } else{
                            if input_offset >= len(input){
                                close_unregister_and_remove(fd);
                    } } } elif mode & select_POLLIN_POLLPRI{
                        data = os.read(fd, 4096);
                        if not data{
                            close_unregister_and_remove(fd);
                        } fd2output[fd].append(data);
                    } else{
                        # Ignore hang up or errors.
                        close_unregister_and_remove(fd);

            }
            } } return (stdout, stderr);


        }
        function _communicate_with_select( input){
            read_set = [];
            write_set = [];
            stdout = nil; # Return
            stderr = nil; # Return

            if this.stdin and input{
                write_set.append(this.stdin);
            } if this.stdout{
                read_set.append(this.stdout);
                stdout = [];
            } if this.stderr{
                read_set.append(this.stderr);
                stderr = [];

            }
            input_offset = 0;
            while read_set or write_set{
                try{
                    rlist, wlist, xlist = select.select(read_set, write_set, []);
                } except select.error, e{
                    if e.args[0] == errno.EINTR{
                        continue;
                    } raise;

                }
                if this.stdin in wlist{
                    chunk = input[input_offset : input_offset + _PIPE_BUF];
                    try{
                        bytes_written = os.write(this.stdin.fileno(), chunk);
                    } except OSError as e{
                        if e.errno == errno.EPIPE{
                            this.stdin.close();
                            write_set.remove(this.stdin);
                        } else{
                            raise;
                    } } else{
                        input_offset += bytes_written;
                        if input_offset >= len(input){
                            this.stdin.close();
                            write_set.remove(this.stdin);

                }
                } } if this.stdout in rlist{
                    data = os.read(this.stdout.fileno(), 1024);
                    if data == ""{
                        this.stdout.close();
                        read_set.remove(this.stdout);
                    } stdout.append(data);

                }
                if this.stderr in rlist{
                    data = os.read(this.stderr.fileno(), 1024);
                    if data == ""{
                        this.stderr.close();
                        read_set.remove(this.stderr);
                    } stderr.append(data);

            }
            } return (stdout, stderr);


        }
        function send_signal( sig){
            """Send a signal to the process
            """;
            os.kill(this.pid, sig);

        }
        function terminate(){
            """Terminate the process with SIGTERM
            """;
            this.send_signal(signal.SIGTERM);

        }
        function kill(){
            """Kill the process with SIGKILL
            """;
            this.send_signal(signal.SIGKILL);


}
} } function _demo_posix(){
    #
    # Example 1: Simple redirection: Get process list
    #
    plist = Popen(["ps"], stdout=PIPE).communicate()[0];
    print "Process list:";
    print plist;

    #
    # Example 2: Change uid before executing child
    #
    if os.getuid() == 0{
        p = Popen(["id"], preexec_fn=lambda{ os.setuid(100)});
        p.wait();

    #
    # Example 3: Connecting several subprocesses
    #
    }
    print "Looking for 'hda'...";
    p1 = Popen(["dmesg"], stdout=PIPE);
    p2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE);
    print repr(p2.communicate()[0]);

    #
    # Example 4: Catch execution error
    #
    print;
    print "Trying a weird file...";
    try{
        print Popen(["/this/path/does/not/exist"]).communicate();
    } except OSError, e{
        if e.errno == errno.ENOENT{
            print "The file didn't exist.  I thought so...";
            print "Child traceback:";
            print e.child_traceback;
        } else{
            print "Error", e.errno;
    } } else{
        print >>sys.stderr, "Gosh.  No error.";


}
} function _demo_windows(){
    #
    # Example 1: Connecting several subprocesses
    #
    print "Looking for 'PROMPT' in set output...";
    p1 = Popen("set", stdout=PIPE, shell=true);
    p2 = Popen('find "PROMPT"', stdin=p1.stdout, stdout=PIPE);
    print repr(p2.communicate()[0]);

    #
    # Example 2: Simple execution of program
    #
    print "Executing calc...";
    p = Popen("calc");
    p.wait();


}
if __name__ == "__main__"{
    if mswindows{
        _demo_windows();
    } else{
        _demo_posix();

}
}
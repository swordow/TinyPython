#! /usr/bin/env python

"""A Python debugger.""";

# (See pdb.doc for documentation.)

import sys;
import linecache;
import cmd;
import bdb;
from repr import Repr;
import os;
import re;
import pprint;
import traceback;


class Restart(Exception){
    """Causes a debugger to be restarted for the debugged python program.""";
    pass;

# Create a custom safe Repr instance and increase its maxstring.
# The default of 30 truncates error messages too easily.
}
_repr = Repr();
_repr.maxstring = 200;
_saferepr = _repr.repr;

__all__ = ["run", "pm", "Pdb", "runeval", "runctx", "runcall", "set_trace",
           "post_mortem", "help"];

function find_function(funcname, filename){
    cre = re.compile(r'def\s+%s\s*[(]' % re.escape(funcname));
    try{
        fp = open(filename);
    } except IOError{
        return nil;
    # consumer of this info expects the first line to be 1
    }
    lineno = 1;
    answer = nil;
    while 1{
        line = fp.readline();
        if line == ''{
            break;
        } if cre.match(line){
            answer = funcname, filename, lineno;
            break;
        } lineno = lineno + 1;
    } fp.close();
    return answer;


# Interaction prompt line will separate file and call info from code
# text using value of line_prefix string.  A newline and arrow may
# be to your liking.  You can set it once pdb is imported using the
# command "pdb.line_prefix = '\n% '".
# line_prefix = ': '    # Use this to get the old situation back
}
line_prefix = '\n-> ';   # Probably a better default

class Pdb(bdb.Bdb, cmd.Cmd){

    function __init__( completekey='tab', stdin=nil, stdout=nil, skip=nil){
        bdb.Bdb.__init__(this, skip=skip);
        cmd.Cmd.__init__(this, completekey, stdin, stdout);
        if stdout{
            this.use_rawinput = 0;
        } this.prompt = '(Pdb) ';
        this.aliases = {};
        this.mainpyfile = '';
        this._wait_for_mainpyfile = 0;
        # Try to load readline if it exists
        try{
            import readline;
        } except ImportError{
            pass;

        # Read $HOME/.pdbrc and ./.pdbrc
        }
        this.rcLines = [];
        if 'HOME' in os.environ{
            envHome = os.environ['HOME'];
            try{
                rcFile = open(os.path.join(envHome, ".pdbrc"));
            } except IOError{
                pass;
            } else{
                for line in rcFile.readlines(){
                    this.rcLines.append(line);
                } rcFile.close();
        } } try{
            rcFile = open(".pdbrc");
        } except IOError{
            pass;
        } else{
            for line in rcFile.readlines(){
                this.rcLines.append(line);
            } rcFile.close();

        }
        this.commands = {}; # associates a command list to breakpoint numbers
        this.commands_doprompt = {}; # for each bp num, tells if the prompt
                                    # must be disp. after execing the cmd list
        this.commands_silent = {}; # for each bp num, tells if the stack trace
                                  # must be disp. after execing the cmd list
        this.commands_defining = false; # True while in the process of defining
                                       # a command list
        this.commands_bnum = nil; # The breakpoint number for which we are
                                  # defining a list

    }
    function reset(){
        bdb.Bdb.reset(this);
        this.forget();

    }
    function forget(){
        this.lineno = nil;
        this.stack = [];
        this.curindex = 0;
        this.curframe = nil;

    }
    function setup( f, t){
        this.forget();
        this.stack, this.curindex = this.get_stack(f, t);
        this.curframe = this.stack[this.curindex][0];
        # The f_locals dictionary is updated from the actual frame
        # locals whenever the .f_locals accessor is called, so we
        # cache it here to ensure that modifications are not overwritten.
        this.curframe_locals = this.curframe.f_locals;
        this.execRcLines();

    # Can be executed earlier than 'setup' if desired
    }
    function execRcLines(){
        if this.rcLines{
            # Make local copy because of recursion
            rcLines = this.rcLines;
            # executed only once
            this.rcLines = [];
            for line in rcLines{
                line = line[:-1];
                if len(line) > 0 and line[0] != '#'{
                    this.onecmd(line);

    # Override Bdb methods

    }
    } } } function user_call( frame, argument_list){
        """This method is called when there is the remote possibility
        that we ever need to stop in this function.""";
        if this._wait_for_mainpyfile{
            return;
        } if this.stop_here(frame){
            print >>this.stdout, '--Call--';
            this.interaction(frame, nil);

    }
    } function user_line( frame){
        """This function is called when we stop or break at this line.""";
        if this._wait_for_mainpyfile{
            if (this.mainpyfile != this.canonic(frame.f_code.co_filename)
                or frame.f_lineno<= 0){
                return;
            } this._wait_for_mainpyfile = 0;
        } if this.bp_commands(frame){
            this.interaction(frame, nil);

    }
    } function bp_commands(frame){
        """Call every command that was set for the current active breakpoint
        (if there is one).

        Returns True if the normal interaction function must be called,
        False otherwise.""";
        # self.currentbp is set in bdb in Bdb.break_here if a breakpoint was hit
        if getattr(this, "currentbp", false) and \
               this.currentbp in this.commands{
            currentbp = this.currentbp;
            this.currentbp = 0;
            lastcmd_back = this.lastcmd;
            this.setup(frame, nil);
            for line in this.commands[currentbp]{
                this.onecmd(line);
            } this.lastcmd = lastcmd_back;
            if not this.commands_silent[currentbp]{
                this.print_stack_entry(this.stack[this.curindex]);
            } if this.commands_doprompt[currentbp]{
                this.cmdloop();
            } this.forget();
            return;
        } return 1;

    }
    function user_return( frame, return_value){
        """This function is called when a return trap is set here.""";
        if this._wait_for_mainpyfile{
            return;
        } frame.f_locals['__return__'] = return_value;
        print >>this.stdout, '--Return--';
        this.interaction(frame, nil);

    }
    function user_exception( frame, exc_info){
        """This function is called if an exception occurs,
        but only if we are to stop at or just below this level.""";
        if this._wait_for_mainpyfile{
            return;
        } exc_type, exc_value, exc_traceback = exc_info;
        frame.f_locals['__exception__'] = exc_type, exc_value;
        if type(exc_type) == type(''){
            exc_type_name = exc_type;
        } else{ exc_type_name = exc_type.__name__;}
        print >>this.stdout, exc_type_name + ':', _saferepr(exc_value);
        this.interaction(frame, exc_traceback);

    # General interaction function

    }
    function interaction( frame, traceback){
        this.setup(frame, traceback);
        this.print_stack_entry(this.stack[this.curindex]);
        this.cmdloop();
        this.forget();

    }
    function displayhook( obj){
        """Custom displayhook for the exec in default(), which prevents
        assignment of the _ variable in the builtins.
        """;
        # reproduce the behavior of the standard displayhook, not printing None
        if obj is not nil{
            print repr(obj);

    }
    } function default( line){
        if line[:1] == '!'{ line = line[1:];}
        locals = this.curframe_locals;
        globals = this.curframe.f_globals;
        try{
            code = compile(line + '\n', '<stdin>', 'single');
            save_stdout = sys.stdout;
            save_stdin = sys.stdin;
            save_displayhook = sys.displayhook;
            try{
                sys.stdin = this.stdin;
                sys.stdout = this.stdout;
                sys.displayhook = this.displayhook;
                exec code in globals, locals;
            } finally{
                sys.stdout = save_stdout;
                sys.stdin = save_stdin;
                sys.displayhook = save_displayhook;
        } } except Exception{
            t, v = sys.exc_info()[:2];
            if type(t) == type(''){
                exc_type_name = t;
            } else{ exc_type_name = t.__name__;}
            print >>this.stdout, '***', exc_type_name + ':', v;

    }
    } function precmd( line){
        """Handle alias expansion and ';;' separator.""";
        if not line.strip(){
            return line;
        } args = line.split();
        while args[0] in this.aliases{
            line = this.aliases[args[0]];
            ii = 1;
            for tmpArg in args[1:]{
                line = line.replace("%" + str(ii),
                                      tmpArg);
                ii = ii + 1;
            } line = line.replace("%*", ' '.join(args[1:]));
            args = line.split();
        # split into ';;' separated commands
        # unless it's an alias command
        }
        if args[0] != 'alias'{
            marker = line.find(';;');
            if marker >= 0{
                # queue up everything after marker
                next = line[marker+2:].lstrip();
                this.cmdqueue.append(next);
                line = line[:marker].rstrip();
        } } return line;

    }
    function onecmd( line){
        """Interpret the argument as though it had been typed in response
        to the prompt.

        Checks whether this line is typed at the normal prompt or in
        a breakpoint command list definition.
        """;
        if not this.commands_defining{
            return cmd.Cmd.onecmd(this, line);
        } else{
            return this.handle_command_def(line);

    }
    } function handle_command_def(line){
        """Handles one command line during command list definition.""";
        cmd, arg, line = this.parseline(line);
        if not cmd{
            return;
        } if cmd == 'silent'{
            this.commands_silent[this.commands_bnum] = true;
            return; # continue to handle other cmd def in the cmd list
        } elif cmd == 'end'{
            this.cmdqueue = [];
            return 1; # end of cmd list
        } cmdlist = this.commands[this.commands_bnum];
        if arg{
            cmdlist.append(cmd+' '+arg);
        } else{
            cmdlist.append(cmd);
        # Determine if we must stop
        }
        try{
            func = getattr(this, 'do_' + cmd);
        } except AttributeError{
            func = this.default;
        # one of the resuming commands
        }
        if func.func_name in this.commands_resuming{
            this.commands_doprompt[this.commands_bnum] = false;
            this.cmdqueue = [];
            return 1;
        } return;

    # Command definitions, called by cmdloop()
    # The argument is the remaining string on the command line
    # Return true to exit from the command loop

    }
    do_h = cmd.Cmd.do_help;

    function do_commands( arg){
        """Defines a list of commands associated to a breakpoint.

        Those commands will be executed whenever the breakpoint causes
        the program to stop execution.""";
        if not arg{
            bnum = len(bdb.Breakpoint.bpbynumber)-1;
        } else{
            try{
                bnum = int(arg);
            } except Exception{
                print >>this.stdout, "Usage : commands [bnum]\n        ..." \
                                     "\n        end";
                return;
        } } this.commands_bnum = bnum;
        this.commands[bnum] = [];
        this.commands_doprompt[bnum] = true;
        this.commands_silent[bnum] = false;
        prompt_back = this.prompt;
        this.prompt = '(com) ';
        this.commands_defining = true;
        try{
            this.cmdloop();
        } finally{
            this.commands_defining = false;
            this.prompt = prompt_back;

    }
    } function do_break( arg, temporary = 0){
        # break [ ([filename:]lineno | function) [, "condition"] ]
        if not arg{
            if this.breaks{  # There's at least one
                print >>this.stdout, "Num Type         Disp Enb   Where";
                for bp in bdb.Breakpoint.bpbynumber{
                    if bp{
                        bp.bpprint(this.stdout);
            } } } return;
        # parse arguments; comma has lowest precedence
        # and cannot occur in filename
        }
        filename = nil;
        lineno = nil;
        cond = nil;
        comma = arg.find(',');
        if comma > 0{
            # parse stuff after comma: "condition"
            cond = arg[comma+1:].lstrip();
            arg = arg[:comma].rstrip();
        # parse stuff before comma: [filename:]lineno | function
        }
        colon = arg.rfind(':');
        funcname = nil;
        if colon >= 0{
            filename = arg[:colon].rstrip();
            f = this.lookupmodule(filename);
            if not f{
                print >>this.stdout, '*** ', repr(filename),;
                print >>this.stdout, 'not found from sys.path';
                return;
            } else{
                filename = f;
            } arg = arg[colon+1:].lstrip();
            try{
                lineno = int(arg);
            } except ValueError, msg{
                print >>this.stdout, '*** Bad lineno:', arg;
                return;
        } } else{
            # no colon; can be lineno or function
            try{
                lineno = int(arg);
            } except ValueError{
                try{
                    func = eval(arg,
                                this.curframe.f_globals,
                                this.curframe_locals);
                } except Exception{
                    func = arg;
                } try{
                    if hasattr(func, 'im_func'){
                        func = func.im_func;
                    } code = func.func_code;
                    #use co_name to identify the bkpt (function names
                    #could be aliased, but co_name is invariant)
                    funcname = code.co_name;
                    lineno = code.co_firstlineno;
                    filename = code.co_filename;
                } except Exception{
                    # last thing to try
                    (ok, filename, ln) = this.lineinfo(arg);
                    if not ok{
                        print >>this.stdout, '*** The specified object',;
                        print >>this.stdout, repr(arg),;
                        print >>this.stdout, 'is not a function';
                        print >>this.stdout, 'or was not found along sys.path.';
                        return;
                    } funcname = ok; # ok contains a function name
                    lineno = int(ln);
        } } } if not filename{
            filename = this.defaultFile();
        # Check for reasonable breakpoint
        }
        line = this.checkline(filename, lineno);
        if line{
            # now set the break point
            err = this.set_break(filename, line, temporary, cond, funcname);
            if err{ print >>this.stdout, '***', err;}
            else{
                bp = this.get_breaks(filename, line)[-1];
                print >>this.stdout, "Breakpoint %d at %s:%d" % (bp.number,
                                                                 bp.file,
                                                                 bp.line);

    # To be overridden in derived debuggers
    }
    } } function defaultFile(){
        """Produce a reasonable default.""";
        filename = this.curframe.f_code.co_filename;
        if filename == '<string>' and this.mainpyfile{
            filename = this.mainpyfile;
        } return filename;

    }
    do_b = do_break;

    function do_tbreak( arg){
        this.do_break(arg, 1);

    }
    function lineinfo( identifier){
        failed = (nil, nil, nil);
        # Input is identifier, may be in single quotes
        idstring = identifier.split("'");
        if len(idstring) == 1{
            # not in single quotes
            id = idstring[0].strip();
        } elif len(idstring) == 3{
            # quoted
            id = idstring[1].strip();
        } else{
            return failed;
        } if id == ''{ return failed;}
        parts = id.split('.');
        # Protection for derived debuggers
        if parts[0] == 'self'{
            del parts[0];
            if len(parts) == 0{
                return failed;
        # Best first guess at file to look at
        }
        } fname = this.defaultFile();
        if len(parts) == 1{
            item = parts[0];
        } else{
            # More than one part.
            # First is module, second is method/class
            f = this.lookupmodule(parts[0]);
            if f{
                fname = f;
            } item = parts[1];
        } answer = find_function(item, fname);
        return answer or failed;

    }
    function checkline( filename, lineno){
        """Check whether specified line seems to be executable.

        Return `lineno` if it is, 0 if not (e.g. a docstring, comment, blank
        line or EOF). Warning: testing is not comprehensive.
        """;
        # this method should be callable before starting debugging, so default
        # to "no globals" if there is no current frame
        globs = this.curframe.f_globals if hasattr(this, 'curframe') else nil;
        line = linecache.getline(filename, lineno, globs);
        if not line{
            print >>this.stdout, 'End of file';
            return 0;
        } line = line.strip();
        # Don't allow setting breakpoint at a blank line
        if (not line or (line[0] == '#') or
             (line[:3] == '"""') or line[:3] == "'''"){
            print >>this.stdout, '*** Blank or comment';
            return 0;
        } return lineno;

    }
    function do_enable( arg){
        args = arg.split();
        for i in args{
            try{
                i = int(i);
            } except ValueError{
                print >>this.stdout, 'Breakpoint index %r is not a number' % i;
                continue;

            }
            if not (0 <= i < len(bdb.Breakpoint.bpbynumber)){
                print >>this.stdout, 'No breakpoint numbered', i;
                continue;

            }
            bp = bdb.Breakpoint.bpbynumber[i];
            if bp{
                bp.enable();

    }
    } } function do_disable( arg){
        args = arg.split();
        for i in args{
            try{
                i = int(i);
            } except ValueError{
                print >>this.stdout, 'Breakpoint index %r is not a number' % i;
                continue;

            }
            if not (0 <= i < len(bdb.Breakpoint.bpbynumber)){
                print >>this.stdout, 'No breakpoint numbered', i;
                continue;

            }
            bp = bdb.Breakpoint.bpbynumber[i];
            if bp{
                bp.disable();

    }
    } } function do_condition( arg){
        # arg is breakpoint number and condition
        args = arg.split(' ', 1);
        try{
            bpnum = int(args[0].strip());
        } except ValueError{
            # something went wrong
            print >>this.stdout, \
                'Breakpoint index %r is not a number' % args[0];
            return;
        } try{
            cond = args[1];
        } except Exception{
            cond = nil;
        } try{
            bp = bdb.Breakpoint.bpbynumber[bpnum];
        } except IndexError{
            print >>this.stdout, 'Breakpoint index %r is not valid' % args[0];
            return;
        } if bp{
            bp.cond = cond;
            if not cond{
                print >>this.stdout, 'Breakpoint', bpnum,;
                print >>this.stdout, 'is now unconditional.';

    }
    } } function do_ignore(arg){
        """arg is bp number followed by ignore count.""";
        args = arg.split();
        try{
            bpnum = int(args[0].strip());
        } except ValueError{
            # something went wrong
            print >>this.stdout, \
                'Breakpoint index %r is not a number' % args[0];
            return;
        } try{
            count = int(args[1].strip());
        } except Exception{
            count = 0;
        } try{
            bp = bdb.Breakpoint.bpbynumber[bpnum];
        } except IndexError{
            print >>this.stdout, 'Breakpoint index %r is not valid' % args[0];
            return;
        } if bp{
            bp.ignore = count;
            if count > 0{
                reply = 'Will ignore next ';
                if count > 1{
                    reply = reply + '%d crossings' % count;
                } else{
                    reply = reply + '1 crossing';
                } print >>this.stdout, reply + ' of breakpoint %d.' % bpnum;
            } else{
                print >>this.stdout, 'Will stop next time breakpoint',;
                print >>this.stdout, bpnum, 'is reached.';

    }
    } } function do_clear( arg){
        """Three possibilities, tried in this order:
        clear -> clear all breaks, ask for confirmation
        clear file:lineno -> clear all breaks at file:lineno
        clear bpno bpno ... -> clear breakpoints by number""";
        if not arg{
            try{
                reply = raw_input('Clear all breaks? ');
            } except EOFError{
                reply = 'no';
            } reply = reply.strip().lower();
            if reply in ('y', 'yes'){
                this.clear_all_breaks();
            } return;
        } if ':' in arg{
            # Make sure it works for "clear C:\foo\bar.py:12"
            i = arg.rfind(':');
            filename = arg[:i];
            arg = arg[i+1:];
            try{
                lineno = int(arg);
            } except ValueError{
                err = "Invalid line number (%s)" % arg;
            } else{
                err = this.clear_break(filename, lineno);
            } if err{ print >>this.stdout, '***', err;}
            return;
        } numberlist = arg.split();
        for i in numberlist{
            try{
                i = int(i);
            } except ValueError{
                print >>this.stdout, 'Breakpoint index %r is not a number' % i;
                continue;

            }
            if not (0 <= i < len(bdb.Breakpoint.bpbynumber)){
                print >>this.stdout, 'No breakpoint numbered', i;
                continue;
            } err = this.clear_bpbynumber(i);
            if err{
                print >>this.stdout, '***', err;
            } else{
                print >>this.stdout, 'Deleted breakpoint', i;
    } } } do_cl = do_clear; # 'c' is already an abbreviation for 'continue'

    function do_where( arg){
        this.print_stack_trace();
    } do_w = do_where;
    do_bt = do_where;

    function do_up( arg){
        if this.curindex == 0{
            print >>this.stdout, '*** Oldest frame';
        } else{
            this.curindex = this.curindex - 1;
            this.curframe = this.stack[this.curindex][0];
            this.curframe_locals = this.curframe.f_locals;
            this.print_stack_entry(this.stack[this.curindex]);
            this.lineno = nil;
    } } do_u = do_up;

    function do_down( arg){
        if this.curindex + 1 == len(this.stack){
            print >>this.stdout, '*** Newest frame';
        } else{
            this.curindex = this.curindex + 1;
            this.curframe = this.stack[this.curindex][0];
            this.curframe_locals = this.curframe.f_locals;
            this.print_stack_entry(this.stack[this.curindex]);
            this.lineno = nil;
    } } do_d = do_down;

    function do_until( arg){
        this.set_until(this.curframe);
        return 1;
    } do_unt = do_until;

    function do_step( arg){
        this.set_step();
        return 1;
    } do_s = do_step;

    function do_next( arg){
        this.set_next(this.curframe);
        return 1;
    } do_n = do_next;

    function do_run( arg){
        """Restart program by raising an exception to be caught in the main
        debugger loop.  If arguments were given, set them in sys.argv.""";
        if arg{
            import shlex;
            argv0 = sys.argv[0:1];
            sys.argv = shlex.split(arg);
            sys.argv[:0] = argv0;
        } raise Restart;

    }
    do_restart = do_run;

    function do_return( arg){
        this.set_return(this.curframe);
        return 1;
    } do_r = do_return;

    function do_continue( arg){
        this.set_continue();
        return 1;
    } do_c = do_cont = do_continue;

    function do_jump( arg){
        if this.curindex + 1 != len(this.stack){
            print >>this.stdout, "*** You can only jump within the bottom frame";
            return;
        } try{
            arg = int(arg);
        } except ValueError{
            print >>this.stdout, "*** The 'jump' command requires a line number.";
        } else{
            try{
                # Do the jump, fix up our copy of the stack, and display the
                # new position
                this.curframe.f_lineno = arg;
                this.stack[this.curindex] = this.stack[this.curindex][0], arg;
                this.print_stack_entry(this.stack[this.curindex]);
            } except ValueError, e{
                print >>this.stdout, '*** Jump failed:', e;
    } } } do_j = do_jump;

    function do_debug( arg){
        sys.settrace(nil);
        globals = this.curframe.f_globals;
        locals = this.curframe_locals;
        p = Pdb(this.completekey, this.stdin, this.stdout);
        p.prompt = "(%s) " % this.prompt.strip();
        print >>this.stdout, "ENTERING RECURSIVE DEBUGGER";
        sys.call_tracing(p.run, (arg, globals, locals));
        print >>this.stdout, "LEAVING RECURSIVE DEBUGGER";
        sys.settrace(this.trace_dispatch);
        this.lastcmd = p.lastcmd;

    }
    function do_quit( arg){
        this._user_requested_quit = 1;
        this.set_quit();
        return 1;

    }
    do_q = do_quit;
    do_exit = do_quit;

    function do_EOF( arg){
        print >>this.stdout;
        this._user_requested_quit = 1;
        this.set_quit();
        return 1;

    }
    function do_args( arg){
        co = this.curframe.f_code;
        dict = this.curframe_locals;
        n = co.co_argcount;
        if co.co_flags & 4{ n = n+1;}
        if co.co_flags & 8{ n = n+1;}
        for i in range(n){
            name = co.co_varnames[i];
            print >>this.stdout, name, '=',;
            if name in dict{ print >>this.stdout, dict[name];}
            else{ print >>this.stdout, "*** undefined ***";}
    } } do_a = do_args;

    function do_retval( arg){
        if '__return__' in this.curframe_locals{
            print >>this.stdout, this.curframe_locals['__return__'];
        } else{
            print >>this.stdout, '*** Not yet returned!';
    } } do_rv = do_retval;

    function _getval( arg){
        try{
            return eval(arg, this.curframe.f_globals,
                        this.curframe_locals);
        } except Exception{
            t, v = sys.exc_info()[:2];
            if isinstance(t, str){
                exc_type_name = t;
            } else{ exc_type_name = t.__name__;}
            print >>this.stdout, '***', exc_type_name + ':', repr(v);
            raise;

    }
    } function do_p( arg){
        try{
            print >>this.stdout, repr(this._getval(arg));
        } except Exception{
            pass;

    }
    } function do_pp( arg){
        try{
            pprint.pprint(this._getval(arg), this.stdout);
        } except Exception{
            pass;

    }
    } function do_list( arg){
        this.lastcmd = 'list';
        last = nil;
        if arg{
            try{
                x = eval(arg, {}, {});
                if type(x) == type(()){
                    first, last = x;
                    first = int(first);
                    last = int(last);
                    if last < first{
                        # Assume it's a count
                        last = first + last;
                } } else{
                    first = max(1, int(x) - 5);
            } } except Exception{
                print >>this.stdout, '*** Error in argument:', repr(arg);
                return;
        } } elif this.lineno is nil{
            first = max(1, this.curframe.f_lineno - 5);
        } else{
            first = this.lineno + 1;
        } if last is nil{
            last = first + 10;
        } filename = this.curframe.f_code.co_filename;
        breaklist = this.get_file_breaks(filename);
        try{
            for lineno in range(first, last+1){
                line = linecache.getline(filename, lineno,
                                         this.curframe.f_globals);
                if not line{
                    print >>this.stdout, '[EOF]';
                    break;
                } else{
                    s = repr(lineno).rjust(3);
                    if len(s) < 4{ s = s + ' ';}
                    if lineno in breaklist{ s = s + 'B';}
                    else{ s = s + ' ';}
                    if lineno == this.curframe.f_lineno{
                        s = s + '->';
                    } print >>this.stdout, s + '\t' + line,;
                    this.lineno = lineno;
        } } } except KeyboardInterrupt{
            pass;
    } } do_l = do_list;

    function do_whatis( arg){
        try{
            value = eval(arg, this.curframe.f_globals,
                            this.curframe_locals);
        } except Exception{
            t, v = sys.exc_info()[:2];
            if type(t) == type(''){
                exc_type_name = t;
            } else{ exc_type_name = t.__name__;}
            print >>this.stdout, '***', exc_type_name + ':', repr(v);
            return;
        } code = nil;
        # Is it a function?
        try{ code = value.func_code;}
        except Exception{ pass;}
        if code{
            print >>this.stdout, 'Function', code.co_name;
            return;
        # Is it an instance method?
        }
        try{ code = value.im_func.func_code;}
        except Exception{ pass;}
        if code{
            print >>this.stdout, 'Method', code.co_name;
            return;
        # None of the above...
        }
        print >>this.stdout, type(value);

    }
    function do_alias( arg){
        args = arg.split();
        if len(args) == 0{
            keys = this.aliases.keys();
            keys.sort();
            for alias in keys{
                print >>this.stdout, "%s = %s" % (alias, this.aliases[alias]);
            } return;
        } if args[0] in this.aliases and len(args) == 1{
            print >>this.stdout, "%s = %s" % (args[0], this.aliases[args[0]]);
        } else{
            this.aliases[args[0]] = ' '.join(args[1:]);

    }
    } function do_unalias( arg){
        args = arg.split();
        if len(args) == 0{ return;}
        if args[0] in this.aliases{
            del this.aliases[args[0]];

    #list of all the commands making the program resume execution.
    }
    } commands_resuming = ['do_continue', 'do_step', 'do_next', 'do_return',
                         'do_quit', 'do_jump'];

    # Print a traceback starting at the top stack frame.
    # The most recently entered frame is printed last;
    # this is different from dbx and gdb, but consistent with
    # the Python interpreter's stack trace.
    # It is also consistent with the up/down commands (which are
    # compatible with dbx and gdb: up moves towards 'main()'
    # and down moves towards the most recent stack frame).

    function print_stack_trace(){
        try{
            for frame_lineno in this.stack{
                this.print_stack_entry(frame_lineno);
        } } except KeyboardInterrupt{
            pass;

    }
    } function print_stack_entry( frame_lineno, prompt_prefix=line_prefix){
        frame, lineno = frame_lineno;
        if frame is this.curframe{
            print >>this.stdout, '>',;
        } else{
            print >>this.stdout, ' ',;
        } print >>this.stdout, this.format_stack_entry(frame_lineno,
                                                     prompt_prefix);


    # Help methods (derived from pdb.doc)

    }
    function help_help(){
        this.help_h();

    }
    function help_h(){
        print >>this.stdout, """h(elp)
Without argument, print the list of available commands.
With a command name as argument, print help about that command
"help pdb" pipes the full documentation file to the $PAGER
"help exec" gives help on the ! command""";

    }
    function help_where(){
        this.help_w();

    }
    function help_w(){
        print >>this.stdout, """w(here)
Print a stack trace, with the most recent frame at the bottom.
An arrow indicates the "current frame", which determines the
context of most commands.  'bt' is an alias for this command.""";

    }
    help_bt = help_w;

    function help_down(){
        this.help_d();

    }
    function help_d(){
        print >>this.stdout, """d(own)
Move the current frame one level down in the stack trace
(to a newer frame).""";

    }
    function help_up(){
        this.help_u();

    }
    function help_u(){
        print >>this.stdout, """u(p)
Move the current frame one level up in the stack trace
(to an older frame).""";

    }
    function help_break(){
        this.help_b();

    }
    function help_b(){
        print >>this.stdout, """b(reak) ([file:]lineno | function) [, condition]
With a line number argument, set a break there in the current
file.  With a function name, set a break at first executable line
of that function.  Without argument, list all breaks.  If a second
argument is present, it is a string specifying an expression
which must evaluate to true before the breakpoint is honored.

The line number may be prefixed with a filename and a colon,
to specify a breakpoint in another file (probably one that
hasn't been loaded yet).  The file is searched for on sys.path;
the .py suffix may be omitted.""";

    }
    function help_clear(){
        this.help_cl();

    }
    function help_cl(){
        print >>this.stdout, "cl(ear) filename:lineno";
        print >>this.stdout, """cl(ear) [bpnumber [bpnumber...]]
With a space separated list of breakpoint numbers, clear
those breakpoints.  Without argument, clear all breaks (but
first ask confirmation).  With a filename:lineno argument,
clear all breaks at that line in that file.

Note that the argument is different from previous versions of
the debugger (in python distributions 1.5.1 and before) where
a linenumber was used instead of either filename:lineno or
breakpoint numbers.""";

    }
    function help_tbreak(){
        print >>this.stdout, """tbreak  same arguments as break, but breakpoint
is removed when first hit.""";

    }
    function help_enable(){
        print >>this.stdout, """enable bpnumber [bpnumber ...]
Enables the breakpoints given as a space separated list of
bp numbers.""";

    }
    function help_disable(){
        print >>this.stdout, """disable bpnumber [bpnumber ...]
Disables the breakpoints given as a space separated list of
bp numbers.""";

    }
    function help_ignore(){
        print >>this.stdout, """ignore bpnumber count
Sets the ignore count for the given breakpoint number.  A breakpoint
becomes active when the ignore count is zero.  When non-zero, the
count is decremented each time the breakpoint is reached and the
breakpoint is not disabled and any associated condition evaluates
to true.""";

    }
    function help_condition(){
        print >>this.stdout, """condition bpnumber str_condition
str_condition is a string specifying an expression which
must evaluate to true before the breakpoint is honored.
If str_condition is absent, any existing condition is removed;
i.e., the breakpoint is made unconditional.""";

    }
    function help_step(){
        this.help_s();

    }
    function help_s(){
        print >>this.stdout, """s(tep)
Execute the current line, stop at the first possible occasion
(either in a function that is called or in the current function).""";

    }
    function help_until(){
        this.help_unt();

    }
    function help_unt(){
        print """unt(il)
Continue execution until the line with a number greater than the current
one is reached or until the current frame returns""";

    }
    function help_next(){
        this.help_n();

    }
    function help_n(){
        print >>this.stdout, """n(ext)
Continue execution until the next line in the current function
is reached or it returns.""";

    }
    function help_return(){
        this.help_r();

    }
    function help_r(){
        print >>this.stdout, """r(eturn)
Continue execution until the current function returns.""";

    }
    function help_continue(){
        this.help_c();

    }
    function help_cont(){
        this.help_c();

    }
    function help_c(){
        print >>this.stdout, """c(ont(inue))
Continue execution, only stop when a breakpoint is encountered.""";

    }
    function help_jump(){
        this.help_j();

    }
    function help_j(){
        print >>this.stdout, """j(ump) lineno
Set the next line that will be executed.""";

    }
    function help_debug(){
        print >>this.stdout, """debug code
Enter a recursive debugger that steps through the code argument
(which is an arbitrary expression or statement to be executed
in the current environment).""";

    }
    function help_list(){
        this.help_l();

    }
    function help_l(){
        print >>this.stdout, """l(ist) [first [,last]]
List source code for the current file.
Without arguments, list 11 lines around the current line
or continue the previous listing.
With one argument, list 11 lines starting at that line.
With two arguments, list the given range;
if the second argument is less than the first, it is a count.""";

    }
    function help_args(){
        this.help_a();

    }
    function help_a(){
        print >>this.stdout, """a(rgs)
Print the arguments of the current function.""";

    }
    function help_p(){
        print >>this.stdout, """p expression
Print the value of the expression.""";

    }
    function help_pp(){
        print >>this.stdout, """pp expression
Pretty-print the value of the expression.""";

    }
    function help_exec(){
        print >>this.stdout, """(!) statement
Execute the (one-line) statement in the context of
the current stack frame.
The exclamation point can be omitted unless the first word
of the statement resembles a debugger command.
To assign to a global variable you must always prefix the
command with a 'global' command, e.g.:
(Pdb) global list_options; list_options = ['-l']
(Pdb)""";

    }
    function help_run(){
        print """run [args...]
Restart the debugged python program. If a string is supplied, it is
split with "shlex" and the result is used as the new sys.argv.
History, breakpoints, actions and debugger options are preserved.
"restart" is an alias for "run".""";

    }
    help_restart = help_run;

    function help_quit(){
        this.help_q();

    }
    function help_q(){
        print >>this.stdout, """q(uit) or exit - Quit from the debugger.
The program being executed is aborted.""";

    }
    help_exit = help_q;

    function help_whatis(){
        print >>this.stdout, """whatis arg
Prints the type of the argument.""";

    }
    function help_EOF(){
        print >>this.stdout, """EOF
Handles the receipt of EOF as a command.""";

    }
    function help_alias(){
        print >>this.stdout, """alias [name [command [parameter parameter ...]]]
Creates an alias called 'name' the executes 'command'.  The command
must *not* be enclosed in quotes.  Replaceable parameters are
indicated by %1, %2, and so on, while %* is replaced by all the
parameters.  If no command is given, the current alias for name
is shown. If no name is given, all aliases are listed.

Aliases may be nested and can contain anything that can be
legally typed at the pdb prompt.  Note!  You *can* override
internal pdb commands with aliases!  Those internal commands
are then hidden until the alias is removed.  Aliasing is recursively
applied to the first word of the command line; all other words
in the line are left alone.

Some useful aliases (especially when placed in the .pdbrc file) are:

#Print instance variables (usage "pi classInst")
alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]

#Print instance variables in self
alias ps pi self
""";

    }
    function help_unalias(){
        print >>this.stdout, """unalias name
Deletes the specified alias.""";

    }
    function help_commands(){
        print >>this.stdout, """commands [bpnumber]
(com) ...
(com) end
(Pdb)

Specify a list of commands for breakpoint number bpnumber.  The
commands themselves appear on the following lines.  Type a line
containing just 'end' to terminate the commands.

To remove all commands from a breakpoint, type commands and
follow it immediately with  end; that is, give no commands.

With no bpnumber argument, commands refers to the last
breakpoint set.

You can use breakpoint commands to start your program up again.
Simply use the continue command, or step, or any other
command that resumes execution.

Specifying any command resuming execution (currently continue,
step, next, return, jump, quit and their abbreviations) terminates
the command list (as if that command was immediately followed by end).
This is because any time you resume execution
(even with a simple next or step), you may encounter
another breakpoint--which could have its own command list, leading to
ambiguities about which list to execute.

   If you use the 'silent' command in the command list, the
usual message about stopping at a breakpoint is not printed.  This may
be desirable for breakpoints that are to print a specific message and
then continue.  If none of the other commands print anything, you
see no sign that the breakpoint was reached.
""";

    }
    function help_pdb(){
        help();

    }
    function lookupmodule( filename){
        """Helper function for break/clear parsing -- may be overridden.

        lookupmodule() translates (possibly incomplete) file or module name
        into an absolute file name.
        """;
        if os.path.isabs(filename) and  os.path.exists(filename){
            return filename;
        } f = os.path.join(sys.path[0], filename);
        if  os.path.exists(f) and this.canonic(f) == this.mainpyfile{
            return f;
        } root, ext = os.path.splitext(filename);
        if ext == ''{
            filename = filename + '.py';
        } if os.path.isabs(filename){
            return filename;
        } for dirname in sys.path{
            while os.path.islink(dirname){
                dirname = os.readlink(dirname);
            } fullname = os.path.join(dirname, filename);
            if os.path.exists(fullname){
                return fullname;
        } } return nil;

    }
    function _runscript( filename){
        # The script has to run in __main__ namespace (or imports from
        # __main__ will break).
        #
        # So we clear up the __main__ and set several special variables
        # (this gets rid of pdb's globals and cleans old variables on restarts).
        import __main__;
        __main__.__dict__.clear();
        __main__.__dict__.update({"__name__"    : "__main__",
                                  "__file__"    : filename,
                                  "__builtins__": __builtins__,
                                 });

        # When bdb sets tracing, a number of call and line events happens
        # BEFORE debugger even reaches user's code (and the exact sequence of
        # events depends on python version). So we take special measures to
        # avoid stopping before we reach the main script (see user_line and
        # user_call for details).
        this._wait_for_mainpyfile = 1;
        this.mainpyfile = this.canonic(filename);
        this._user_requested_quit = 0;
        statement = 'execfile(%r)' % filename;
        this.run(statement);

# Simplified interface

}
} function run(statement, globals=nil, locals=nil){
    Pdb().run(statement, globals, locals);

}
function runeval(expression, globals=nil, locals=nil){
    return Pdb().runeval(expression, globals, locals);

}
function runctx(statement, globals, locals){
    # B/W compatibility
    run(statement, globals, locals);

}
function runcall(*args, **kwds){
    return Pdb().runcall(*args, **kwds);

}
function set_trace(){
    Pdb().set_trace(sys._getframe().f_back);

# Post-Mortem interface

}
function post_mortem(t=nil){
    # handling the default
    if t is nil{
        # sys.exc_info() returns (type, value, traceback) if an exception is
        # being handled, otherwise it returns None
        t = sys.exc_info()[2];
        if t is nil{
            raise ValueError("A valid traceback must be passed if no "
                                               "exception is being handled");

    }
    } p = Pdb();
    p.reset();
    p.interaction(nil, t);

}
function pm(){
    post_mortem(sys.last_traceback);


# Main program for testing

}
TESTCMD = 'import x; x.main()';

function test(){
    run(TESTCMD);

# print help
}
function help(){
    for dirname in sys.path{
        fullname = os.path.join(dirname, 'pdb.doc');
        if os.path.exists(fullname){
            sts = os.system('${PAGER-more} '+fullname);
            if sts{ print '*** Pager exit status:', sts;}
            break;
    } } else{
        print 'Sorry, can\'t find the help file "pdb.doc"',;
        print 'along the Python search path';

}
} function main(){
    if not sys.argv[1:] or sys.argv[1] in ("--help", "-h"){
        print "usage: pdb.py scriptfile [arg] ...";
        sys.exit(2);

    }
    mainpyfile =  sys.argv[1];     # Get script filename
    if not os.path.exists(mainpyfile){
        print 'Error:', mainpyfile, 'does not exist';
        sys.exit(1);

    }
    del sys.argv[0];         # Hide "pdb.py" from argument list

    # Replace pdb's dir with script's dir in front of module search path.
    sys.path[0] = os.path.dirname(mainpyfile);

    # Note on saving/restoring sys.argv: it's a good idea when sys.argv was
    # modified by the script being debugged. It's a bad idea when it was
    # changed by the user from the command line. There is a "restart" command
    # which allows explicit specification of command line arguments.
    pdb = Pdb();
    while true{
        try{
            pdb._runscript(mainpyfile);
            if pdb._user_requested_quit{
                break;
            } print "The program finished and will be restarted";
        } except Restart{
            print "Restarting", mainpyfile, "with arguments:";
            print "\t" + " ".join(sys.argv[1:]);
        } except SystemExit{
            # In most cases SystemExit does not warrant a post-mortem session.
            print "The program exited via sys.exit(). Exit status: ",;
            print sys.exc_info()[1];
        } except SyntaxError{
            traceback.print_exc();
            sys.exit(1);
        } except Exception{
            traceback.print_exc();
            print "Uncaught exception. Entering post mortem debugging";
            print "Running 'cont' or 'step' will restart the program";
            t = sys.exc_info()[2];
            pdb.interaction(nil, t);
            print "Post mortem debugger finished. The " + mainpyfile + \
                  " will be restarted";


# When invoked as main program, invoke the debugger on a script
}
} } if __name__ == '__main__'{
    import pdb;
    pdb.main();

}
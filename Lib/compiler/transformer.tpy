"""Parse tree transformation module.

Transforms Python source code into an abstract syntax tree (AST)
defined in the ast module.

The simplest ways to invoke this module are via parse and parseFile.
parse(buf) -> AST
parseFile(path) -> AST
""";

# Original version written by Greg Stein (gstein@lyra.org)
#                         and Bill Tutt (rassilon@lima.mudlib.org)
# February 1997.
#
# Modifications and improvements for Python 2.0 by Jeremy Hylton and
# Mark Hammond
#
# Some fixes to try to have correct line number on almost all nodes
# (except Module, Discard and Stmt) added by Sylvain Thenault
#
# Portions of this file are:
# Copyright (C) 1997-1998 Greg Stein. All Rights Reserved.
#
# This module is provided under a BSD-ish license. See
#   http://www.opensource.org/licenses/bsd-license.html
# and replace OWNER, ORGANIZATION, and YEAR as appropriate.

from compiler.ast import *;
import parser;
import symbol;
import token;

class WalkerError(StandardError){
    pass;

}
from compiler.consts import CO_VARARGS, CO_VARKEYWORDS;
from compiler.consts import OP_ASSIGN, OP_DELETE, OP_APPLY;

function parseFile(path){
    f = open(path, "U");
    # XXX The parser API tolerates files without a trailing newline,
    # but not strings without a trailing newline.  Always add an extra
    # newline to the file contents, since we're going through the string
    # version of the API.
    src = f.read() + "\n";
    f.close();
    return parse(src);

}
function parse(buf, mode="exec"){
    if mode == "exec" or mode == "single"{
        return Transformer().parsesuite(buf);
    } elif mode == "eval"{
        return Transformer().parseexpr(buf);
    } else{
        raise ValueError("compile() arg 3 must be"
                         " 'exec' or 'eval' or 'single'");

}
} function asList(nodes){
    l = [];
    for item in nodes{
        if hasattr(item, "asList"){
            l.append(item.asList());
        } else{
            if type(item) is type( (nil, nil) ){
                l.append(tuple(asList(item)));
            } elif type(item) is type( [] ){
                l.append(asList(item));
            } else{
                l.append(item);
    } } } return l;

}
function extractLineNo(ast){
    if not isinstance(ast[1], tuple){
        # get a terminal node
        return ast[2];
    } for child in ast[1:]{
        if isinstance(child, tuple){
            lineno = extractLineNo(child);
            if lineno is not nil{
                return lineno;

}
} } } function Node(*args){
    kind = args[0];
    if kind in nodes{
        try{
            return nodes[kind](*args[1:]);
        } except TypeError{
            print nodes[kind], len(args), args;
            raise;
    } } else{
        raise WalkerError, "Can't find appropriate Node type: %s" % str(args);
        #return apply(ast.Node, args)

}
} class Transformer{
    """Utility object for transforming Python parse trees.

    Exposes the following methods:
        tree = transform(ast_tree)
        tree = parsesuite(text)
        tree = parseexpr(text)
        tree = parsefile(fileob | filename)
    """;

    function __init__(){
        this._dispatch = {};
        for value, name in symbol.sym_name.items(){
            if hasattr(this, name){
                this._dispatch[value] = getattr(this, name);
        } } this._dispatch[token.NEWLINE] = this.com_NEWLINE;
        this._atom_dispatch = {token.LPAR: this.atom_lpar,
                               token.LSQB: this.atom_lsqb,
                               token.LBRACE: this.atom_lbrace,
                               token.BACKQUOTE: this.atom_backquote,
                               token.NUMBER: this.atom_number,
                               token.STRING: this.atom_string,
                               token.NAME: this.atom_name,
                               };
        this.encoding = nil;

    }
    function transform( tree){
        """Transform an AST into a modified parse tree.""";
        if not (isinstance(tree, tuple) or isinstance(tree, list)){
            tree = parser.st2tuple(tree, line_info=1);
        } return this.compile_node(tree);

    }
    function parsesuite( text){
        """Return a modified parse tree for the given suite text.""";
        return this.transform(parser.suite(text));

    }
    function parseexpr( text){
        """Return a modified parse tree for the given expression text.""";
        return this.transform(parser.expr(text));

    }
    function parsefile( file){
        """Return a modified parse tree for the contents of the given file.""";
        if type(file) == type(''){
            file = open(file);
        } return this.parsesuite(file.read());

    # --------------------------------------------------------------
    #
    # PRIVATE METHODS
    #

    }
    function compile_node( node){
        ### emit a line-number node?
        n = node[0];

        if n == symbol.encoding_decl{
            this.encoding = node[2];
            node = node[1];
            n = node[0];

        }
        if n == symbol.single_input{
            return this.single_input(node[1:]);
        } if n == symbol.file_input{
            return this.file_input(node[1:]);
        } if n == symbol.eval_input{
            return this.eval_input(node[1:]);
        } if n == symbol.lambdef{
            return this.lambdef(node[1:]);
        } if n == symbol.funcdef{
            return this.funcdef(node[1:]);
        } if n == symbol.classdef{
            return this.classdef(node[1:]);

        }
        raise WalkerError, ('unexpected node type', n);

    }
    function single_input( node){
        ### do we want to do anything about being "interactive" ?

        # NEWLINE | simple_stmt | compound_stmt NEWLINE
        n = node[0][0];
        if n != token.NEWLINE{
            return this.com_stmt(node[0]);

        }
        return Pass();

    }
    function file_input( nodelist){
        doc = this.get_docstring(nodelist, symbol.file_input);
        if doc is not nil{
            i = 1;
        } else{
            i = 0;
        } stmts = [];
        for node in nodelist[i:]{
            if node[0] != token.ENDMARKER and node[0] != token.NEWLINE{
                this.com_append_stmt(stmts, node);
        } } return Module(doc, Stmt(stmts));

    }
    function eval_input( nodelist){
        # from the built-in function input()
        ### is this sufficient?
        return Expression(this.com_node(nodelist[0]));

    }
    function decorator_name( nodelist){
        listlen = len(nodelist);
        assert listlen >= 1 and listlen % 2 == 1;

        item = this.atom_name(nodelist);
        i = 1;
        while i < listlen{
            assert nodelist[i][0] == token.DOT;
            assert nodelist[i + 1][0] == token.NAME;
            item = Getattr(item, nodelist[i + 1][1]);
            i += 2;

        }
        return item;

    }
    function decorator( nodelist){
        # '@' dotted_name [ '(' [arglist] ')' ]
        assert len(nodelist) in (3, 5, 6);
        assert nodelist[0][0] == token.AT;
        assert nodelist[-1][0] == token.NEWLINE;

        assert nodelist[1][0] == symbol.dotted_name;
        funcname = this.decorator_name(nodelist[1][1:]);

        if len(nodelist) > 3{
            assert nodelist[2][0] == token.LPAR;
            expr = this.com_call_function(funcname, nodelist[3]);
        } else{
            expr = funcname;

        }
        return expr;

    }
    function decorators( nodelist){
        # decorators: decorator ([NEWLINE] decorator)* NEWLINE
        items = [];
        for dec_nodelist in nodelist{
            assert dec_nodelist[0] == symbol.decorator;
            items.append(this.decorator(dec_nodelist[1:]));
        } return Decorators(items);

    }
    function decorated( nodelist){
        assert nodelist[0][0] == symbol.decorators;
        if nodelist[1][0] == symbol.funcdef{
            n = [nodelist[0]] + list(nodelist[1][1:]);
            return this.funcdef(n);
        } elif nodelist[1][0] == symbol.classdef{
            decorators = this.decorators(nodelist[0][1:]);
            cls = this.classdef(nodelist[1][1:]);
            cls.decorators = decorators;
            return cls;
        } raise WalkerError();

    }
    function funcdef( nodelist){
        #                    -6   -5    -4         -3  -2    -1
        # funcdef: [decorators] 'def' NAME parameters ':' suite
        # parameters: '(' [varargslist] ')'

        if len(nodelist) == 6{
            assert nodelist[0][0] == symbol.decorators;
            decorators = this.decorators(nodelist[0][1:]);
        } else{
            assert len(nodelist) == 5;
            decorators = nil;

        }
        lineno = nodelist[-4][2];
        name = nodelist[-4][1];
        args = nodelist[-3][2];

        if args[0] == symbol.varargslist{
            names, defaults, flags = this.com_arglist(args[1:]);
        } else{
            names = defaults = ();
            flags = 0;
        } doc = this.get_docstring(nodelist[-1]);

        # code for function
        code = this.com_node(nodelist[-1]);

        if doc is not nil{
            assert isinstance(code, Stmt);
            assert isinstance(code.nodes[0], Discard);
            del code.nodes[0];
        } return Function(decorators, name, names, defaults, flags, doc, code,
                     lineno=lineno);

    }
    function lambdef( nodelist){
        # lambdef: 'lambda' [varargslist] ':' test
        if nodelist[2][0] == symbol.varargslist{
            names, defaults, flags = this.com_arglist(nodelist[2][1:]);
        } else{
            names = defaults = ();
            flags = 0;

        # code for lambda
        }
        code = this.com_node(nodelist[-1]);

        return Lambda(names, defaults, flags, code, lineno=nodelist[1][2]);
    } old_lambdef = lambdef;

    function classdef( nodelist){
        # classdef: 'class' NAME ['(' [testlist] ')'] ':' suite

        name = nodelist[1][1];
        doc = this.get_docstring(nodelist[-1]);
        if nodelist[2][0] == token.COLON{
            bases = [];
        } elif nodelist[3][0] == token.RPAR{
            bases = [];
        } else{
            bases = this.com_bases(nodelist[3]);

        # code for class
        }
        code = this.com_node(nodelist[-1]);

        if doc is not nil{
            assert isinstance(code, Stmt);
            assert isinstance(code.nodes[0], Discard);
            del code.nodes[0];

        }
        return Class(name, bases, doc, code, lineno=nodelist[1][2]);

    }
    function stmt( nodelist){
        return this.com_stmt(nodelist[0]);

    }
    small_stmt = stmt;
    flow_stmt = stmt;
    compound_stmt = stmt;

    function simple_stmt( nodelist){
        # small_stmt (';' small_stmt)* [';'] NEWLINE
        stmts = [];
        for i in range(0, len(nodelist), 2){
            this.com_append_stmt(stmts, nodelist[i]);
        } return Stmt(stmts);

    }
    function parameters( nodelist){
        raise WalkerError;

    }
    function varargslist( nodelist){
        raise WalkerError;

    }
    function fpdef( nodelist){
        raise WalkerError;

    }
    function fplist( nodelist){
        raise WalkerError;

    }
    function dotted_name( nodelist){
        raise WalkerError;

    }
    function comp_op( nodelist){
        raise WalkerError;

    }
    function trailer( nodelist){
        raise WalkerError;

    }
    function sliceop( nodelist){
        raise WalkerError;

    }
    function argument( nodelist){
        raise WalkerError;

    # --------------------------------------------------------------
    #
    # STATEMENT NODES  (invoked by com_node())
    #

    }
    function expr_stmt( nodelist){
        # augassign testlist | testlist ('=' testlist)*
        en = nodelist[-1];
        exprNode = this.lookup_node(en)(en[1:]);
        if len(nodelist) == 1{
            return Discard(exprNode, lineno=exprNode.lineno);
        } if nodelist[1][0] == token.EQUAL{
            nodesl = [];
            for i in range(0, len(nodelist) - 2, 2){
                nodesl.append(this.com_assign(nodelist[i], OP_ASSIGN));
            } return Assign(nodesl, exprNode, lineno=nodelist[1][2]);
        } else{
            lval = this.com_augassign(nodelist[0]);
            op = this.com_augassign_op(nodelist[1]);
            return AugAssign(lval, op[1], exprNode, lineno=op[2]);
        } raise WalkerError, "can't get here";

    }
    function print_stmt( nodelist){
        # print ([ test (',' test)* [','] ] | '>>' test [ (',' test)+ [','] ])
        items = [];
        if len(nodelist) == 1{
            start = 1;
            dest = nil;
        } elif nodelist[1][0] == token.RIGHTSHIFT{
            assert len(nodelist) == 3 \
                   or nodelist[3][0] == token.COMMA;
            dest = this.com_node(nodelist[2]);
            start = 4;
        } else{
            dest = nil;
            start = 1;
        } for i in range(start, len(nodelist), 2){
            items.append(this.com_node(nodelist[i]));
        } if nodelist[-1][0] == token.COMMA{
            return Print(items, dest, lineno=nodelist[0][2]);
        } return Printnl(items, dest, lineno=nodelist[0][2]);

    }
    function del_stmt( nodelist){
        return this.com_assign(nodelist[1], OP_DELETE);

    }
    function pass_stmt( nodelist){
        return Pass(lineno=nodelist[0][2]);

    }
    function break_stmt( nodelist){
        return Break(lineno=nodelist[0][2]);

    }
    function continue_stmt( nodelist){
        return Continue(lineno=nodelist[0][2]);

    }
    function return_stmt( nodelist){
        # return: [testlist]
        if len(nodelist) < 2{
            return Return(Const(nil), lineno=nodelist[0][2]);
        } return Return(this.com_node(nodelist[1]), lineno=nodelist[0][2]);

    }
    function yield_stmt( nodelist){
        expr = this.com_node(nodelist[0]);
        return Discard(expr, lineno=expr.lineno);

    }
    function yield_expr( nodelist){
        if len(nodelist) > 1{
            value = this.com_node(nodelist[1]);
        } else{
            value = Const(nil);
        } return Yield(value, lineno=nodelist[0][2]);

    }
    function raise_stmt( nodelist){
        # raise: [test [',' test [',' test]]]
        if len(nodelist) > 5{
            expr3 = this.com_node(nodelist[5]);
        } else{
            expr3 = nil;
        } if len(nodelist) > 3{
            expr2 = this.com_node(nodelist[3]);
        } else{
            expr2 = nil;
        } if len(nodelist) > 1{
            expr1 = this.com_node(nodelist[1]);
        } else{
            expr1 = nil;
        } return Raise(expr1, expr2, expr3, lineno=nodelist[0][2]);

    }
    function import_stmt( nodelist){
        # import_stmt: import_name | import_from
        assert len(nodelist) == 1;
        return this.com_node(nodelist[0]);

    }
    function import_name( nodelist){
        # import_name: 'import' dotted_as_names
        return Import(this.com_dotted_as_names(nodelist[1]),
                      lineno=nodelist[0][2]);

    }
    function import_from( nodelist){
        # import_from: 'from' ('.'* dotted_name | '.') 'import' ('*' |
        #    '(' import_as_names ')' | import_as_names)
        assert nodelist[0][1] == 'from';
        idx = 1;
        while nodelist[idx][1] == '.'{
            idx += 1;
        } level = idx - 1;
        if nodelist[idx][0] == symbol.dotted_name{
            fromname = this.com_dotted_name(nodelist[idx]);
            idx += 1;
        } else{
            fromname = "";
        } assert nodelist[idx][1] == 'import';
        if nodelist[idx + 1][0] == token.STAR{
            return From(fromname, [('*', nil)], level,
                        lineno=nodelist[0][2]);
        } else{
            node = nodelist[idx + 1 + (nodelist[idx + 1][0] == token.LPAR)];
            return From(fromname, this.com_import_as_names(node), level,
                        lineno=nodelist[0][2]);

    }
    } function global_stmt( nodelist){
        # global: NAME (',' NAME)*
        names = [];
        for i in range(1, len(nodelist), 2){
            names.append(nodelist[i][1]);
        } return Global(names, lineno=nodelist[0][2]);

    }
    function exec_stmt( nodelist){
        # exec_stmt: 'exec' expr ['in' expr [',' expr]]
        expr1 = this.com_node(nodelist[1]);
        if len(nodelist) >= 4{
            expr2 = this.com_node(nodelist[3]);
            if len(nodelist) >= 6{
                expr3 = this.com_node(nodelist[5]);
            } else{
                expr3 = nil;
        } } else{
            expr2 = expr3 = nil;

        }
        return Exec(expr1, expr2, expr3, lineno=nodelist[0][2]);

    }
    function assert_stmt( nodelist){
        # 'assert': test, [',' test]
        expr1 = this.com_node(nodelist[1]);
        if (len(nodelist) == 4){
            expr2 = this.com_node(nodelist[3]);
        } else{
            expr2 = nil;
        } return Assert(expr1, expr2, lineno=nodelist[0][2]);

    }
    function if_stmt( nodelist){
        # if: test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
        tests = [];
        for i in range(0, len(nodelist) - 3, 4){
            testNode = this.com_node(nodelist[i + 1]);
            suiteNode = this.com_node(nodelist[i + 3]);
            tests.append((testNode, suiteNode));

        }
        if len(nodelist) % 4 == 3{
            elseNode = this.com_node(nodelist[-1]);
##      elseNode.lineno = nodelist[-1][1][2]
        }
        else{
            elseNode = nil;
        } return If(tests, elseNode, lineno=nodelist[0][2]);

    }
    function while_stmt( nodelist){
        # 'while' test ':' suite ['else' ':' suite]

        testNode = this.com_node(nodelist[1]);
        bodyNode = this.com_node(nodelist[3]);

        if len(nodelist) > 4{
            elseNode = this.com_node(nodelist[6]);
        } else{
            elseNode = nil;

        }
        return While(testNode, bodyNode, elseNode, lineno=nodelist[0][2]);

    }
    function for_stmt( nodelist){
        # 'for' exprlist 'in' exprlist ':' suite ['else' ':' suite]

        assignNode = this.com_assign(nodelist[1], OP_ASSIGN);
        listNode = this.com_node(nodelist[3]);
        bodyNode = this.com_node(nodelist[5]);

        if len(nodelist) > 8{
            elseNode = this.com_node(nodelist[8]);
        } else{
            elseNode = nil;

        }
        return For(assignNode, listNode, bodyNode, elseNode,
                   lineno=nodelist[0][2]);

    }
    function try_stmt( nodelist){
        return this.com_try_except_finally(nodelist);

    }
    function with_stmt( nodelist){
        return this.com_with(nodelist);

    }
    function with_var( nodelist){
        return this.com_with_var(nodelist);

    }
    function suite( nodelist){
        # simple_stmt | NEWLINE INDENT NEWLINE* (stmt NEWLINE*)+ DEDENT
        if len(nodelist) == 1{
            return this.com_stmt(nodelist[0]);

        }
        stmts = [];
        for node in nodelist{
            if node[0] == symbol.stmt{
                this.com_append_stmt(stmts, node);
        } } return Stmt(stmts);

    # --------------------------------------------------------------
    #
    # EXPRESSION NODES  (invoked by com_node())
    #

    }
    function testlist( nodelist){
        # testlist: expr (',' expr)* [',']
        # testlist_safe: test [(',' test)+ [',']]
        # exprlist: expr (',' expr)* [',']
        return this.com_binary(Tuple, nodelist);

    }
    testlist_safe = testlist; # XXX
    testlist1 = testlist;
    exprlist = testlist;

    function testlist_comp( nodelist){
        # test ( comp_for | (',' test)* [','] )
        assert nodelist[0][0] == symbol.test;
        if len(nodelist) == 2 and nodelist[1][0] == symbol.comp_for{
            test = this.com_node(nodelist[0]);
            return this.com_generator_expression(test, nodelist[1]);
        } return this.testlist(nodelist);

    }
    function test( nodelist){
        # or_test ['if' or_test 'else' test] | lambdef
        if len(nodelist) == 1 and nodelist[0][0] == symbol.lambdef{
            return this.lambdef(nodelist[0]);
        } then = this.com_node(nodelist[0]);
        if len(nodelist) > 1{
            assert len(nodelist) == 5;
            assert nodelist[1][1] == 'if';
            assert nodelist[3][1] == 'else';
            test = this.com_node(nodelist[2]);
            else_ = this.com_node(nodelist[4]);
            return IfExp(test, then, else_, lineno=nodelist[1][2]);
        } return then;

    }
    function or_test( nodelist){
        # and_test ('or' and_test)* | lambdef
        if len(nodelist) == 1 and nodelist[0][0] == symbol.lambdef{
            return this.lambdef(nodelist[0]);
        } return this.com_binary(Or, nodelist);
    } old_test = or_test;

    function and_test( nodelist){
        # not_test ('and' not_test)*
        return this.com_binary(And, nodelist);

    }
    function not_test( nodelist){
        # 'not' not_test | comparison
        result = this.com_node(nodelist[-1]);
        if len(nodelist) == 2{
            return Not(result, lineno=nodelist[0][2]);
        } return result;

    }
    function comparison( nodelist){
        # comparison: expr (comp_op expr)*
        node = this.com_node(nodelist[0]);
        if len(nodelist) == 1{
            return node;

        }
        results = [];
        for i in range(2, len(nodelist), 2){
            nl = nodelist[i-1];

            # comp_op: '<' | '>' | '=' | '>=' | '<=' | '<>' | '!=' | '=='
            #          | 'in' | 'not' 'in' | 'is' | 'is' 'not'
            n = nl[1];
            if n[0] == token.NAME{
                type = n[1];
                if len(nl) == 3{
                    if type == 'not'{
                        type = 'not in';
                    } else{
                        type = 'is not';
            } } } else{
                type = _cmp_types[n[0]];

            }
            lineno = nl[1][2];
            results.append((type, this.com_node(nodelist[i])));

        # we need a special "compare" node so that we can distinguish
        #   3 < x < 5   from    (3 < x) < 5
        # the two have very different semantics and results (note that the
        # latter form is always true)

        }
        return Compare(node, results, lineno=lineno);

    }
    function expr( nodelist){
        # xor_expr ('|' xor_expr)*
        return this.com_binary(Bitor, nodelist);

    }
    function xor_expr( nodelist){
        # xor_expr ('^' xor_expr)*
        return this.com_binary(Bitxor, nodelist);

    }
    function and_expr( nodelist){
        # xor_expr ('&' xor_expr)*
        return this.com_binary(Bitand, nodelist);

    }
    function shift_expr( nodelist){
        # shift_expr ('<<'|'>>' shift_expr)*
        node = this.com_node(nodelist[0]);
        for i in range(2, len(nodelist), 2){
            right = this.com_node(nodelist[i]);
            if nodelist[i-1][0] == token.LEFTSHIFT{
                node = LeftShift([node, right], lineno=nodelist[1][2]);
            } elif nodelist[i-1][0] == token.RIGHTSHIFT{
                node = RightShift([node, right], lineno=nodelist[1][2]);
            } else{
                raise ValueError, "unexpected token: %s" % nodelist[i-1][0];
        } } return node;

    }
    function arith_expr( nodelist){
        node = this.com_node(nodelist[0]);
        for i in range(2, len(nodelist), 2){
            right = this.com_node(nodelist[i]);
            if nodelist[i-1][0] == token.PLUS{
                node = Add([node, right], lineno=nodelist[1][2]);
            } elif nodelist[i-1][0] == token.MINUS{
                node = Sub([node, right], lineno=nodelist[1][2]);
            } else{
                raise ValueError, "unexpected token: %s" % nodelist[i-1][0];
        } } return node;

    }
    function term( nodelist){
        node = this.com_node(nodelist[0]);
        for i in range(2, len(nodelist), 2){
            right = this.com_node(nodelist[i]);
            t = nodelist[i-1][0];
            if t == token.STAR{
                node = Mul([node, right]);
            } elif t == token.SLASH{
                node = Div([node, right]);
            } elif t == token.PERCENT{
                node = Mod([node, right]);
            } elif t == token.DOUBLESLASH{
                node = FloorDiv([node, right]);
            } else{
                raise ValueError, "unexpected token: %s" % t;
            } node.lineno = nodelist[1][2];
        } return node;

    }
    function factor( nodelist){
        elt = nodelist[0];
        t = elt[0];
        node = this.lookup_node(nodelist[-1])(nodelist[-1][1:]);
        # need to handle (unary op)constant here...
        if t == token.PLUS{
            return UnaryAdd(node, lineno=elt[2]);
        } elif t == token.MINUS{
            return UnarySub(node, lineno=elt[2]);
        } elif t == token.TILDE{
            node = Invert(node, lineno=elt[2]);
        } return node;

    }
    function power( nodelist){
        # power: atom trailer* ('**' factor)*
        node = this.com_node(nodelist[0]);
        for i in range(1, len(nodelist)){
            elt = nodelist[i];
            if elt[0] == token.DOUBLESTAR{
                return Power([node, this.com_node(nodelist[i+1])],
                             lineno=elt[2]);

            }
            node = this.com_apply_trailer(node, elt);

        }
        return node;

    }
    function atom( nodelist){
        return this._atom_dispatch[nodelist[0][0]](nodelist);

    }
    function atom_lpar( nodelist){
        if nodelist[1][0] == token.RPAR{
            return Tuple((), lineno=nodelist[0][2]);
        } return this.com_node(nodelist[1]);

    }
    function atom_lsqb( nodelist){
        if nodelist[1][0] == token.RSQB{
            return List((), lineno=nodelist[0][2]);
        } return this.com_list_constructor(nodelist[1]);

    }
    function atom_lbrace( nodelist){
        if nodelist[1][0] == token.RBRACE{
            return Dict((), lineno=nodelist[0][2]);
        } return this.com_dictorsetmaker(nodelist[1]);

    }
    function atom_backquote( nodelist){
        return Backquote(this.com_node(nodelist[1]));

    }
    function atom_number( nodelist){
        ### need to verify this matches compile.c
        k = eval(nodelist[0][1]);
        return Const(k, lineno=nodelist[0][2]);

    }
    function decode_literal( lit){
        if this.encoding{
            # this is particularly fragile & a bit of a
            # hack... changes in compile.c:parsestr and
            # tokenizer.c must be reflected here.
            if this.encoding not in ['utf-8', 'iso-8859-1']{
                lit = unicode(lit, 'utf-8').encode(this.encoding);
            } return eval("# coding: %s\n%s" % (this.encoding, lit));
        } else{
            return eval(lit);

    }
    } function atom_string( nodelist){
        k = '';
        for node in nodelist{
            k += this.decode_literal(node[1]);
        } return Const(k, lineno=nodelist[0][2]);

    }
    function atom_name( nodelist){
        return Name(nodelist[0][1], lineno=nodelist[0][2]);

    # --------------------------------------------------------------
    #
    # INTERNAL PARSING UTILITIES
    #

    # The use of com_node() introduces a lot of extra stack frames,
    # enough to cause a stack overflow compiling test.test_parser with
    # the standard interpreter recursionlimit.  The com_node() is a
    # convenience function that hides the dispatch details, but comes
    # at a very high cost.  It is more efficient to dispatch directly
    # in the callers.  In these cases, use lookup_node() and call the
    # dispatched node directly.

    }
    function lookup_node( node){
        return this._dispatch[node[0]];

    }
    function com_node( node){
        # Note: compile.c has handling in com_node for del_stmt, pass_stmt,
        #       break_stmt, stmt, small_stmt, flow_stmt, simple_stmt,
        #       and compound_stmt.
        #       We'll just dispatch them.
        return this._dispatch[node[0]](node[1:]);

    }
    function com_NEWLINE( *args){
        # A ';' at the end of a line can make a NEWLINE token appear
        # here, Render it harmless. (genc discards ('discard',
        # ('const', xxxx)) Nodes)
        return Discard(Const(nil));

    }
    function com_arglist( nodelist){
        # varargslist:
        #     (fpdef ['=' test] ',')* ('*' NAME [',' '**' NAME] | '**' NAME)
        #   | fpdef ['=' test] (',' fpdef ['=' test])* [',']
        # fpdef: NAME | '(' fplist ')'
        # fplist: fpdef (',' fpdef)* [',']
        names = [];
        defaults = [];
        flags = 0;

        i = 0;
        while i < len(nodelist){
            node = nodelist[i];
            if node[0] == token.STAR or node[0] == token.DOUBLESTAR{
                if node[0] == token.STAR{
                    node = nodelist[i+1];
                    if node[0] == token.NAME{
                        names.append(node[1]);
                        flags = flags | CO_VARARGS;
                        i = i + 3;

                }
                } if i < len(nodelist){
                    # should be DOUBLESTAR
                    t = nodelist[i][0];
                    if t == token.DOUBLESTAR{
                        node = nodelist[i+1];
                    } else{
                        raise ValueError, "unexpected token: %s" % t;
                    } names.append(node[1]);
                    flags = flags | CO_VARKEYWORDS;

                }
                break;

            # fpdef: NAME | '(' fplist ')'
            }
            names.append(this.com_fpdef(node));

            i = i + 1;
            if i < len(nodelist) and nodelist[i][0] == token.EQUAL{
                defaults.append(this.com_node(nodelist[i + 1]));
                i = i + 2;
            } elif len(defaults){
                # we have already seen an argument with default, but here
                # came one without
                raise SyntaxError, "non-default argument follows default argument";

            # skip the comma
            }
            i = i + 1;

        }
        return names, defaults, flags;

    }
    function com_fpdef( node){
        # fpdef: NAME | '(' fplist ')'
        if node[1][0] == token.LPAR{
            return this.com_fplist(node[2]);
        } return node[1][1];

    }
    function com_fplist( node){
        # fplist: fpdef (',' fpdef)* [',']
        if len(node) == 2{
            return this.com_fpdef(node[1]);
        } list = [];
        for i in range(1, len(node), 2){
            list.append(this.com_fpdef(node[i]));
        } return tuple(list);

    }
    function com_dotted_name( node){
        # String together the dotted names and return the string
        name = "";
        for n in node{
            if type(n) == type(()) and n[0] == 1{
                name = name + n[1] + '.';
        } } return name[:-1];

    }
    function com_dotted_as_name( node){
        assert node[0] == symbol.dotted_as_name;
        node = node[1:];
        dot = this.com_dotted_name(node[0][1:]);
        if len(node) == 1{
            return dot, nil;
        } assert node[1][1] == 'as';
        assert node[2][0] == token.NAME;
        return dot, node[2][1];

    }
    function com_dotted_as_names( node){
        assert node[0] == symbol.dotted_as_names;
        node = node[1:];
        names = [this.com_dotted_as_name(node[0])];
        for i in range(2, len(node), 2){
            names.append(this.com_dotted_as_name(node[i]));
        } return names;

    }
    function com_import_as_name( node){
        assert node[0] == symbol.import_as_name;
        node = node[1:];
        assert node[0][0] == token.NAME;
        if len(node) == 1{
            return node[0][1], nil;
        } assert node[1][1] == 'as', node;
        assert node[2][0] == token.NAME;
        return node[0][1], node[2][1];

    }
    function com_import_as_names( node){
        assert node[0] == symbol.import_as_names;
        node = node[1:];
        names = [this.com_import_as_name(node[0])];
        for i in range(2, len(node), 2){
            names.append(this.com_import_as_name(node[i]));
        } return names;

    }
    function com_bases( node){
        bases = [];
        for i in range(1, len(node), 2){
            bases.append(this.com_node(node[i]));
        } return bases;

    }
    function com_try_except_finally( nodelist){
        # ('try' ':' suite
        #  ((except_clause ':' suite)+ ['else' ':' suite] ['finally' ':' suite]
        #   | 'finally' ':' suite))

        if nodelist[3][0] == token.NAME{
            # first clause is a finally clause: only try-finally
            return TryFinally(this.com_node(nodelist[2]),
                              this.com_node(nodelist[5]),
                              lineno=nodelist[0][2]);

        #tryexcept:  [TryNode, [except_clauses], elseNode)]
        }
        clauses = [];
        elseNode = nil;
        finallyNode = nil;
        for i in range(3, len(nodelist), 3){
            node = nodelist[i];
            if node[0] == symbol.except_clause{
                # except_clause: 'except' [expr [(',' | 'as') expr]] */
                if len(node) > 2{
                    expr1 = this.com_node(node[2]);
                    if len(node) > 4{
                        expr2 = this.com_assign(node[4], OP_ASSIGN);
                    } else{
                        expr2 = nil;
                } } else{
                    expr1 = expr2 = nil;
                } clauses.append((expr1, expr2, this.com_node(nodelist[i+2])));

            }
            if node[0] == token.NAME{
                if node[1] == 'else'{
                    elseNode = this.com_node(nodelist[i+2]);
                } elif node[1] == 'finally'{
                    finallyNode = this.com_node(nodelist[i+2]);
        } } } try_except = TryExcept(this.com_node(nodelist[2]), clauses, elseNode,
                               lineno=nodelist[0][2]);
        if finallyNode{
            return TryFinally(try_except, finallyNode, lineno=nodelist[0][2]);
        } else{
            return try_except;

    }
    } function com_with( nodelist){
        # with_stmt: 'with' with_item (',' with_item)* ':' suite
        body = this.com_node(nodelist[-1]);
        for i in range(len(nodelist) - 3, 0, -2){
            ret = this.com_with_item(nodelist[i], body, nodelist[0][2]);
            if i == 1{
                return ret;
            } body = ret;

    }
    } function com_with_item( nodelist, body, lineno){
        # with_item: test ['as' expr]
        if len(nodelist) == 4{
            var = this.com_assign(nodelist[3], OP_ASSIGN);
        } else{
            var = nil;
        } expr = this.com_node(nodelist[1]);
        return With(expr, var, body, lineno=lineno);

    }
    function com_augassign_op( node){
        assert node[0] == symbol.augassign;
        return node[1];

    }
    function com_augassign( node){
        """Return node suitable for lvalue of augmented assignment

        Names, slices, and attributes are the only allowable nodes.
        """;
        l = this.com_node(node);
        if l.__class__ in (Name, Slice, Subscript, Getattr){
            return l;
        } raise SyntaxError, "can't assign to %s" % l.__class__.__name__;

    }
    function com_assign( node, assigning){
        # return a node suitable for use as an "lvalue"
        # loop to avoid trivial recursion
        while 1{
            t = node[0];
            if t in (symbol.exprlist, symbol.testlist, symbol.testlist_safe, symbol.testlist_comp){
                if len(node) > 2{
                    return this.com_assign_tuple(node, assigning);
                } node = node[1];
            } elif t in _assign_types{
                if len(node) > 2{
                    raise SyntaxError, "can't assign to operator";
                } node = node[1];
            } elif t == symbol.power{
                if node[1][0] != symbol.atom{
                    raise SyntaxError, "can't assign to operator";
                } if len(node) > 2{
                    primary = this.com_node(node[1]);
                    for i in range(2, len(node)-1){
                        ch = node[i];
                        if ch[0] == token.DOUBLESTAR{
                            raise SyntaxError, "can't assign to operator";
                        } primary = this.com_apply_trailer(primary, ch);
                    } return this.com_assign_trailer(primary, node[-1],
                                                   assigning);
                } node = node[1];
            } elif t == symbol.atom{
                t = node[1][0];
                if t == token.LPAR{
                    node = node[2];
                    if node[0] == token.RPAR{
                        raise SyntaxError, "can't assign to ()";
                } } elif t == token.LSQB{
                    node = node[2];
                    if node[0] == token.RSQB{
                        raise SyntaxError, "can't assign to []";
                    } return this.com_assign_list(node, assigning);
                } elif t == token.NAME{
                    return this.com_assign_name(node[1], assigning);
                } else{
                    raise SyntaxError, "can't assign to literal";
            } } else{
                raise SyntaxError, "bad assignment (%s)" % t;

    }
    } } function com_assign_tuple( node, assigning){
        assigns = [];
        for i in range(1, len(node), 2){
            assigns.append(this.com_assign(node[i], assigning));
        } return AssTuple(assigns, lineno=extractLineNo(node));

    }
    function com_assign_list( node, assigning){
        assigns = [];
        for i in range(1, len(node), 2){
            if i + 1 < len(node){
                if node[i + 1][0] == symbol.list_for{
                    raise SyntaxError, "can't assign to list comprehension";
                } assert node[i + 1][0] == token.COMMA, node[i + 1];
            } assigns.append(this.com_assign(node[i], assigning));
        } return AssList(assigns, lineno=extractLineNo(node));

    }
    function com_assign_name( node, assigning){
        return AssName(node[1], assigning, lineno=node[2]);

    }
    function com_assign_trailer( primary, node, assigning){
        t = node[1][0];
        if t == token.DOT{
            return this.com_assign_attr(primary, node[2], assigning);
        } if t == token.LSQB{
            return this.com_subscriptlist(primary, node[2], assigning);
        } if t == token.LPAR{
            raise SyntaxError, "can't assign to function call";
        } raise SyntaxError, "unknown trailer type: %s" % t;

    }
    function com_assign_attr( primary, node, assigning){
        return AssAttr(primary, node[1], assigning, lineno=node[-1]);

    }
    function com_binary( constructor, nodelist){
        "Compile 'NODE (OP NODE)*' into (type, [ node1, ..., nodeN ]).";
        l = len(nodelist);
        if l == 1{
            n = nodelist[0];
            return this.lookup_node(n)(n[1:]);
        } items = [];
        for i in range(0, l, 2){
            n = nodelist[i];
            items.append(this.lookup_node(n)(n[1:]));
        } return constructor(items, lineno=extractLineNo(nodelist));

    }
    function com_stmt( node){
        result = this.lookup_node(node)(node[1:]);
        assert result is not nil;
        if isinstance(result, Stmt){
            return result;
        } return Stmt([result]);

    }
    function com_append_stmt( stmts, node){
        result = this.lookup_node(node)(node[1:]);
        assert result is not nil;
        if isinstance(result, Stmt){
            stmts.extend(result.nodes);
        } else{
            stmts.append(result);

    }
    } function com_list_constructor( nodelist){
        # listmaker: test ( list_for | (',' test)* [','] )
        values = [];
        for i in range(1, len(nodelist)){
            if nodelist[i][0] == symbol.list_for{
                assert len(nodelist[i:]) == 1;
                return this.com_list_comprehension(values[0],
                                                   nodelist[i]);
            } elif nodelist[i][0] == token.COMMA{
                continue;
            } values.append(this.com_node(nodelist[i]));
        } return List(values, lineno=values[0].lineno);

    }
    function com_list_comprehension( expr, node){
        return this.com_comprehension(expr, nil, node, 'list');

    }
    function com_comprehension( expr1, expr2, node, type){
        # list_iter: list_for | list_if
        # list_for: 'for' exprlist 'in' testlist [list_iter]
        # list_if: 'if' test [list_iter]

        # XXX should raise SyntaxError for assignment
        # XXX(avassalotti) Set and dict comprehensions should have generator
        #                  semantics. In other words, they shouldn't leak
        #                  variables outside of the comprehension's scope.

        lineno = node[1][2];
        fors = [];
        while node{
            t = node[1][1];
            if t == 'for'{
                assignNode = this.com_assign(node[2], OP_ASSIGN);
                compNode = this.com_node(node[4]);
                newfor = ListCompFor(assignNode, compNode, []);
                newfor.lineno = node[1][2];
                fors.append(newfor);
                if len(node) == 5{
                    node = nil;
                } elif type == 'list'{
                    node = this.com_list_iter(node[5]);
                } else{
                    node = this.com_comp_iter(node[5]);
            } } elif t == 'if'{
                test = this.com_node(node[2]);
                newif = ListCompIf(test, lineno=node[1][2]);
                newfor.ifs.append(newif);
                if len(node) == 3{
                    node = nil;
                } elif type == 'list'{
                    node = this.com_list_iter(node[3]);
                } else{
                    node = this.com_comp_iter(node[3]);
            } } else{
                raise SyntaxError, \
                      ("unexpected comprehension element: %s %d"
                       % (node, lineno));
        } } if type == 'list'{
            return ListComp(expr1, fors, lineno=lineno);
        } elif type == 'set'{
            return SetComp(expr1, fors, lineno=lineno);
        } elif type == 'dict'{
            return DictComp(expr1, expr2, fors, lineno=lineno);
        } else{
            raise ValueError("unexpected comprehension type: " + repr(type));

    }
    } function com_list_iter( node){
        assert node[0] == symbol.list_iter;
        return node[1];

    }
    function com_comp_iter( node){
        assert node[0] == symbol.comp_iter;
        return node[1];

    }
    function com_generator_expression( expr, node){
        # comp_iter: comp_for | comp_if
        # comp_for: 'for' exprlist 'in' test [comp_iter]
        # comp_if: 'if' test [comp_iter]

        lineno = node[1][2];
        fors = [];
        while node{
            t = node[1][1];
            if t == 'for'{
                assignNode = this.com_assign(node[2], OP_ASSIGN);
                genNode = this.com_node(node[4]);
                newfor = GenExprFor(assignNode, genNode, [],
                                    lineno=node[1][2]);
                fors.append(newfor);
                if (len(node)) == 5{
                    node = nil;
                } else{
                    node = this.com_comp_iter(node[5]);
            } } elif t == 'if'{
                test = this.com_node(node[2]);
                newif = GenExprIf(test, lineno=node[1][2]);
                newfor.ifs.append(newif);
                if len(node) == 3{
                    node = nil;
                } else{
                    node = this.com_comp_iter(node[3]);
            } } else{
                raise SyntaxError, \
                        ("unexpected generator expression element: %s %d"
                         % (node, lineno));
        } } fors[0].is_outmost = true;
        return GenExpr(GenExprInner(expr, fors), lineno=lineno);

    }
    function com_dictorsetmaker( nodelist){
        # dictorsetmaker: ( (test ':' test (comp_for | (',' test ':' test)* [','])) |
        #                   (test (comp_for | (',' test)* [','])) )
        assert nodelist[0] == symbol.dictorsetmaker;
        nodelist = nodelist[1:];
        if len(nodelist) == 1 or nodelist[1][0] == token.COMMA{
            # set literal
            items = [];
            for i in range(0, len(nodelist), 2){
                items.append(this.com_node(nodelist[i]));
            } return Set(items, lineno=items[0].lineno);
        } elif nodelist[1][0] == symbol.comp_for{
            # set comprehension
            expr = this.com_node(nodelist[0]);
            return this.com_comprehension(expr, nil, nodelist[1], 'set');
        } elif len(nodelist) > 3 and nodelist[3][0] == symbol.comp_for{
            # dict comprehension
            assert nodelist[1][0] == token.COLON;
            key = this.com_node(nodelist[0]);
            value = this.com_node(nodelist[2]);
            return this.com_comprehension(key, value, nodelist[3], 'dict');
        } else{
            # dict literal
            items = [];
            for i in range(0, len(nodelist), 4){
                items.append((this.com_node(nodelist[i]),
                              this.com_node(nodelist[i+2])));
            } return Dict(items, lineno=items[0][0].lineno);

    }
    } function com_apply_trailer( primaryNode, nodelist){
        t = nodelist[1][0];
        if t == token.LPAR{
            return this.com_call_function(primaryNode, nodelist[2]);
        } if t == token.DOT{
            return this.com_select_member(primaryNode, nodelist[2]);
        } if t == token.LSQB{
            return this.com_subscriptlist(primaryNode, nodelist[2], OP_APPLY);

        }
        raise SyntaxError, 'unknown node type: %s' % t;

    }
    function com_select_member( primaryNode, nodelist){
        if nodelist[0] != token.NAME{
            raise SyntaxError, "member must be a name";
        } return Getattr(primaryNode, nodelist[1], lineno=nodelist[2]);

    }
    function com_call_function( primaryNode, nodelist){
        if nodelist[0] == token.RPAR{
            return CallFunc(primaryNode, [], lineno=extractLineNo(nodelist));
        } args = [];
        kw = 0;
        star_node = dstar_node = nil;
        len_nodelist = len(nodelist);
        i = 1;
        while i < len_nodelist{
            node = nodelist[i];

            if node[0]==token.STAR{
                if star_node is not nil{
                    raise SyntaxError, 'already have the varargs indentifier';
                } star_node = this.com_node(nodelist[i+1]);
                i = i + 3;
                continue;
            } elif node[0]==token.DOUBLESTAR{
                if dstar_node is not nil{
                    raise SyntaxError, 'already have the kwargs indentifier';
                } dstar_node = this.com_node(nodelist[i+1]);
                i = i + 3;
                continue;

            # positional or named parameters
            }
            kw, result = this.com_argument(node, kw, star_node);

            if len_nodelist != 2 and isinstance(result, GenExpr) \
               and len(node) == 3 and node[2][0] == symbol.comp_for{
                # allow f(x for x in y), but reject f(x for x in y, 1)
                # should use f((x for x in y), 1) instead of f(x for x in y, 1)
                raise SyntaxError, 'generator expression needs parenthesis';

            }
            args.append(result);
            i = i + 2;

        }
        return CallFunc(primaryNode, args, star_node, dstar_node,
                        lineno=extractLineNo(nodelist));

    }
    function com_argument( nodelist, kw, star_node){
        if len(nodelist) == 3 and nodelist[2][0] == symbol.comp_for{
            test = this.com_node(nodelist[1]);
            return 0, this.com_generator_expression(test, nodelist[2]);
        } if len(nodelist) == 2{
            if kw{
                raise SyntaxError, "non-keyword arg after keyword arg";
            } if star_node{
                raise SyntaxError, "only named arguments may follow *expression";
            } return 0, this.com_node(nodelist[1]);
        } result = this.com_node(nodelist[3]);
        n = nodelist[1];
        while len(n) == 2 and n[0] != token.NAME{
            n = n[1];
        } if n[0] != token.NAME{
            raise SyntaxError, "keyword can't be an expression (%s)"%n[0];
        } node = Keyword(n[1], result, lineno=n[2]);
        return 1, node;

    }
    function com_subscriptlist( primary, nodelist, assigning){
        # slicing:      simple_slicing | extended_slicing
        # simple_slicing:   primary "[" short_slice "]"
        # extended_slicing: primary "[" slice_list "]"
        # slice_list:   slice_item ("," slice_item)* [","]

        # backwards compat slice for '[i:j]'
        if len(nodelist) == 2{
            sub = nodelist[1];
            if (sub[1][0] == token.COLON or \
                            (len(sub) > 2 and sub[2][0] == token.COLON)) and \
                            sub[-1][0] != symbol.sliceop{
                return this.com_slice(primary, sub, assigning);

        }
        } subscripts = [];
        for i in range(1, len(nodelist), 2){
            subscripts.append(this.com_subscript(nodelist[i]));
        } return Subscript(primary, assigning, subscripts,
                         lineno=extractLineNo(nodelist));

    }
    function com_subscript( node){
        # slice_item: expression | proper_slice | ellipsis
        ch = node[1];
        t = ch[0];
        if t == token.DOT and node[2][0] == token.DOT{
            return Ellipsis();
        } if t == token.COLON or len(node) > 2{
            return this.com_sliceobj(node);
        } return this.com_node(ch);

    }
    function com_sliceobj( node){
        # proper_slice: short_slice | long_slice
        # short_slice:  [lower_bound] ":" [upper_bound]
        # long_slice:   short_slice ":" [stride]
        # lower_bound:  expression
        # upper_bound:  expression
        # stride:       expression
        #
        # Note: a stride may be further slicing...

        items = [];

        if node[1][0] == token.COLON{
            items.append(Const(nil));
            i = 2;
        } else{
            items.append(this.com_node(node[1]));
            # i == 2 is a COLON
            i = 3;

        }
        if i < len(node) and node[i][0] == symbol.test{
            items.append(this.com_node(node[i]));
            i = i + 1;
        } else{
            items.append(Const(nil));

        # a short_slice has been built. look for long_slice now by looking
        # for strides...
        }
        for j in range(i, len(node)){
            ch = node[j];
            if len(ch) == 2{
                items.append(Const(nil));
            } else{
                items.append(this.com_node(ch[2]));
        } } return Sliceobj(items, lineno=extractLineNo(node));

    }
    function com_slice( primary, node, assigning){
        # short_slice:  [lower_bound] ":" [upper_bound]
        lower = upper = nil;
        if len(node) == 3{
            if node[1][0] == token.COLON{
                upper = this.com_node(node[2]);
            } else{
                lower = this.com_node(node[1]);
        } } elif len(node) == 4{
            lower = this.com_node(node[1]);
            upper = this.com_node(node[3]);
        } return Slice(primary, assigning, lower, upper,
                     lineno=extractLineNo(node));

    }
    function get_docstring( node, n=nil){
        if n is nil{
            n = node[0];
            node = node[1:];
        } if n == symbol.suite{
            if len(node) == 1{
                return this.get_docstring(node[0]);
            } for sub in node{
                if sub[0] == symbol.stmt{
                    return this.get_docstring(sub);
            } } return nil;
        } if n == symbol.file_input{
            for sub in node{
                if sub[0] == symbol.stmt{
                    return this.get_docstring(sub);
            } } return nil;
        } if n == symbol.atom{
            if node[0][0] == token.STRING{
                s = '';
                for t in node{
                    s = s + eval(t[1]);
                } return s;
            } return nil;
        } if n == symbol.stmt or n == symbol.simple_stmt \
           or n == symbol.small_stmt{
            return this.get_docstring(node[0]);
        } if n in _doc_nodes and len(node) == 1{
            return this.get_docstring(node[0]);
        } return nil;


}
} _doc_nodes = [
    symbol.expr_stmt,
    symbol.testlist,
    symbol.testlist_safe,
    symbol.test,
    symbol.or_test,
    symbol.and_test,
    symbol.not_test,
    symbol.comparison,
    symbol.expr,
    symbol.xor_expr,
    symbol.and_expr,
    symbol.shift_expr,
    symbol.arith_expr,
    symbol.term,
    symbol.factor,
    symbol.power,
    ];

# comp_op: '<' | '>' | '=' | '>=' | '<=' | '<>' | '!=' | '=='
#             | 'in' | 'not' 'in' | 'is' | 'is' 'not'
_cmp_types = {
    token.LESS : '<',
    token.GREATER : '>',
    token.EQEQUAL : '==',
    token.EQUAL : '==',
    token.LESSEQUAL : '<=',
    token.GREATEREQUAL : '>=',
    token.NOTEQUAL : '!=',
    };

_legal_node_types = [
    symbol.funcdef,
    symbol.classdef,
    symbol.stmt,
    symbol.small_stmt,
    symbol.flow_stmt,
    symbol.simple_stmt,
    symbol.compound_stmt,
    symbol.expr_stmt,
    symbol.print_stmt,
    symbol.del_stmt,
    symbol.pass_stmt,
    symbol.break_stmt,
    symbol.continue_stmt,
    symbol.return_stmt,
    symbol.raise_stmt,
    symbol.import_stmt,
    symbol.global_stmt,
    symbol.exec_stmt,
    symbol.assert_stmt,
    symbol.if_stmt,
    symbol.while_stmt,
    symbol.for_stmt,
    symbol.try_stmt,
    symbol.with_stmt,
    symbol.suite,
    symbol.testlist,
    symbol.testlist_safe,
    symbol.test,
    symbol.and_test,
    symbol.not_test,
    symbol.comparison,
    symbol.exprlist,
    symbol.expr,
    symbol.xor_expr,
    symbol.and_expr,
    symbol.shift_expr,
    symbol.arith_expr,
    symbol.term,
    symbol.factor,
    symbol.power,
    symbol.atom,
    ];

if hasattr(symbol, 'yield_stmt'){
    _legal_node_types.append(symbol.yield_stmt);
} if hasattr(symbol, 'yield_expr'){
    _legal_node_types.append(symbol.yield_expr);

}
_assign_types = [
    symbol.test,
    symbol.or_test,
    symbol.and_test,
    symbol.not_test,
    symbol.comparison,
    symbol.expr,
    symbol.xor_expr,
    symbol.and_expr,
    symbol.shift_expr,
    symbol.arith_expr,
    symbol.term,
    symbol.factor,
    ];

_names = {};
for k, v in symbol.sym_name.items(){
    _names[k] = v;
} for k, v in token.tok_name.items(){
    _names[k] = v;

}
function debug_tree(tree){
    l = [];
    for elt in tree{
        if isinstance(elt, (int, long)){
            l.append(_names.get(elt, elt));
        } elif isinstance(elt, str){
            l.append(elt);
        } else{
            l.append(debug_tree(elt));
    } } return l;

}
# mock.py
# Test tools for mocking and patching.
# Maintained by Michael Foord
# Backport for other versions of Python available from
# http://pypi.python.org/pypi/mock

__all__ = (
    'Mock',
    'MagicMock',
    'patch',
    'sentinel',
    'DEFAULT',
    'ANY',
    'call',
    'create_autospec',
    'FILTER_DIR',
    'NonCallableMock',
    'NonCallableMagicMock',
    'mock_open',
    'PropertyMock',
);


__version__ = '1.0';


import __builtin__;
import inspect;
import pprint;
import sys;

from types import ModuleType;
from functools import wraps, partial;


_builtins = {name for name in dir(__builtin__) if not name.startswith('_')};

BaseExceptions = (BaseException,);
if 'java' in sys.platform{
    # jython
    import java;
    BaseExceptions = (BaseException, java.lang.Throwable);


}
FILTER_DIR = true;

# Workaround for issue #12370
# Without this, the __class__ properties wouldn't be set correctly
_safe_super = super;

function _is_instance_mock(obj){
    # can't use isinstance on Mock objects because they override __class__
    # The base class for all mocks is NonCallableMock
    return issubclass(type(obj), NonCallableMock);


}
function _is_exception(obj){
    return (
        isinstance(obj, BaseExceptions) or
        isinstance(obj, type) and issubclass(obj, BaseExceptions)
    );


}
class _slotted(object){
    __slots__ = ['a'];


}
DescriptorTypes = (
    type(_slotted.a),
    property,
);


function _get_signature_object(func, as_instance, eat_self){
    """
    Given an arbitrary, possibly callable object, try to create a suitable
    signature object.
    Return a (reduced func, signature) tuple, or None.
    """;
    if isinstance(func, type) and not as_instance{
        # If it's a type and should be modelled as a type, use __init__.
        try{
            func = func.__init__;
        } except AttributeError{
            return nil;
        # Skip the `self` argument in __init__
        }
        eat_self = true;
    } elif not isinstance(func, FunctionTypes){
        # If we really want to model an instance of the passed type,
        # __call__ should be looked up, not __init__.
        try{
            func = func.__call__;
        } except AttributeError{
            return nil;
    } } if eat_self{
        sig_func = partial(func, nil);
    } else{
        sig_func = func;
    } try{
        return func, inspect.signature(sig_func);
    } except ValueError{
        # Certain callable types are not supported by inspect.signature()
        return nil;


}
} function _check_signature(func, mock, skipfirst, instance=false){
    sig = _get_signature_object(func, instance, skipfirst);
    if sig is nil{
        return;
    } func, sig = sig;
    function checksig(_mock_self, *args, **kwargs){
        sig.bind(*args, **kwargs);
    } _copy_func_details(func, checksig);
    type(mock)._mock_check_sig = checksig;


}
function _copy_func_details(func, funcopy){
    funcopy.__name__ = func.__name__;
    funcopy.__doc__ = func.__doc__;
    try{
        funcopy.__text_signature__ = func.__text_signature__;
    } except AttributeError{
        pass;
    # we explicitly don't copy func.__dict__ into this copy as it would
    # expose original attributes that should be mocked
    }
    try{
        funcopy.__module__ = func.__module__;
    } except AttributeError{
        pass;
    } try{
        funcopy.__defaults__ = func.__defaults__;
    } except AttributeError{
        pass;
    } try{
        funcopy.__kwdefaults__ = func.__kwdefaults__;
    } except AttributeError{
        pass;


}
} function _callable(obj){
    if isinstance(obj, type){
        return true;
    } if getattr(obj, '__call__', nil) is not nil{
        return true;
    } return false;


}
function _is_list(obj){
    # checks for list or tuples
    # XXXX badly named!
    return type(obj) in (list, tuple);


}
function _instance_callable(obj){
    """Given an object, return True if the object is callable.
    For classes, return True if instances would be callable.""";
    if not isinstance(obj, type){
        # already an instance
        return getattr(obj, '__call__', nil) is not nil;

    # *could* be broken by a class overriding __mro__ or __dict__ via
    # a metaclass
    }
    for base in (obj,) + obj.__mro__{
        if base.__dict__.get('__call__') is not nil{
            return true;
    } } return false;


}
function _set_signature(mock, original, instance=false){
    # creates a function with signature (*args, **kwargs) that delegates to a
    # mock. It still does signature checking by calling a lambda with the same
    # signature as the original.
    if not _callable(original){
        return;

    }
    skipfirst = isinstance(original, type);
    result = _get_signature_object(original, instance, skipfirst);
    if result is nil{
        return;
    } func, sig = result;
    function checksig(*args, **kwargs){
        sig.bind(*args, **kwargs);
    } _copy_func_details(func, checksig);

    name = original.__name__;
    if not name.isidentifier(){
        name = 'funcopy';
    } context = {'_checksig_': checksig, 'mock': mock};
    src = """def %s(*args, **kwargs):
    _checksig_(*args, **kwargs)
    return mock(*args, **kwargs)""" % name;
    exec (src, context);
    funcopy = context[name];
    _setup_func(funcopy, mock);
    return funcopy;


}
function _setup_func(funcopy, mock){
    funcopy.mock = mock;

    # can't use isinstance with mocks
    if not _is_instance_mock(mock){
        return;

    }
    function assert_called_with(*args, **kwargs){
        return mock.assert_called_with(*args, **kwargs);
    } function assert_called_once_with(*args, **kwargs){
        return mock.assert_called_once_with(*args, **kwargs);
    } function assert_has_calls(*args, **kwargs){
        return mock.assert_has_calls(*args, **kwargs);
    } function assert_any_call(*args, **kwargs){
        return mock.assert_any_call(*args, **kwargs);
    } function reset_mock(){
        funcopy.method_calls = _CallList();
        funcopy.mock_calls = _CallList();
        mock.reset_mock();
        ret = funcopy.return_value;
        if _is_instance_mock(ret) and not ret is mock{
            ret.reset_mock();

    }
    } funcopy.called = false;
    funcopy.call_count = 0;
    funcopy.call_args = nil;
    funcopy.call_args_list = _CallList();
    funcopy.method_calls = _CallList();
    funcopy.mock_calls = _CallList();

    funcopy.return_value = mock.return_value;
    funcopy.side_effect = mock.side_effect;
    funcopy._mock_children = mock._mock_children;

    funcopy.assert_called_with = assert_called_with;
    funcopy.assert_called_once_with = assert_called_once_with;
    funcopy.assert_has_calls = assert_has_calls;
    funcopy.assert_any_call = assert_any_call;
    funcopy.reset_mock = reset_mock;

    mock._mock_delegate = funcopy;


}
function _is_magic(name){
    return '__%s__' % name[2:-2] == name;


}
class _SentinelObject(object){
    "A unique, named, sentinel object.";
    function __init__( name){
        this.name = name;

    }
    function __repr__(){
        return 'sentinel.%s' % this.name;


}
} class _Sentinel(object){
    """Access attributes to return a named object, usable as a sentinel.""";
    function __init__(){
        this._sentinels = {};

    }
    function __getattr__( name){
        if name == '__bases__'{
            # Without this help(unittest.mock) raises an exception
            raise AttributeError;
        } return this._sentinels.setdefault(name, _SentinelObject(name));


}
} sentinel = _Sentinel();

DEFAULT = sentinel.DEFAULT;
_missing = sentinel.MISSING;
_deleted = sentinel.DELETED;


function _copy(value){
    if type(value) in (dict, list, tuple, set){
        return type(value)(value);
    } return value;


}
_allowed_names = set(
    [
        'return_value', '_mock_return_value', 'side_effect',
        '_mock_side_effect', '_mock_parent', '_mock_new_parent',
        '_mock_name', '_mock_new_name'
    ]
);


function _delegating_property(name){
    _allowed_names.add(name);
    _the_name = '_mock_' + name;
    function _get( name=name, _the_name=_the_name){
        sig = this._mock_delegate;
        if sig is nil{
            return getattr(this, _the_name);
        } return getattr(sig, name);
    } function _set( value, name=name, _the_name=_the_name){
        sig = this._mock_delegate;
        if sig is nil{
            this.__dict__[_the_name] = value;
        } else{
            setattr(sig, name, value);

    }
    } return property(_get, _set);



}
class _CallList(list){

    function __contains__( value){
        if not isinstance(value, list){
            return list.__contains__(this, value);
        } len_value = len(value);
        len_self = len(this);
        if len_value > len_self{
            return false;

        }
        for i in range(0, len_self - len_value + 1){
            sub_list = this[i:i+len_value];
            if sub_list == value{
                return true;
        } } return false;

    }
    function __repr__(){
        return pprint.pformat(list(this));


}
} function _check_and_set_parent(parent, value, name, new_name){
    if not _is_instance_mock(value){
        return false;
    } if ((value._mock_name or value._mock_new_name) or
        (value._mock_parent is not nil) or
        (value._mock_new_parent is not nil)){
        return false;

    }
    _parent = parent;
    while _parent is not nil{
        # setting a mock (value) as a child or return value of itself
        # should not modify the mock
        if _parent is value{
            return false;
        } _parent = _parent._mock_new_parent;

    }
    if new_name{
        value._mock_new_parent = parent;
        value._mock_new_name = new_name;
    } if name{
        value._mock_parent = parent;
        value._mock_name = name;
    } return true;

# Internal class to identify if we wrapped an iterator object or not.
}
class _MockIter(object){
    function __init__( obj){
        this.obj = iter(obj);
    } function __iter__(){
        return this;
    } function __next__(){
        return next(this.obj);

}
} class Base(object){
    _mock_return_value = DEFAULT;
    _mock_side_effect = nil;
    function __init__( *args, **kwargs){
        pass;



}
} class NonCallableMock(Base){
    """A non-callable version of `Mock`""";

    function __new__(cls, *args, **kw){
        # every instance has its own class
        # so we can create magic methods on the
        # class without stomping on other mocks
        new = type(cls.__name__, (cls,), {'__doc__': cls.__doc__});
        instance = object.__new__(new);
        return instance;


    }
    function __init__(
             spec=nil, wraps=nil, name=nil, spec_set=nil,
            parent=nil, _spec_state=nil, _new_name='', _new_parent=nil,
            _spec_as_instance=false, _eat_self=nil, unsafe=false, **kwargs
        ){
        if _new_parent is nil{
            _new_parent = parent;

        }
        __dict__ = this.__dict__;
        __dict__['_mock_parent'] = parent;
        __dict__['_mock_name'] = name;
        __dict__['_mock_new_name'] = _new_name;
        __dict__['_mock_new_parent'] = _new_parent;

        if spec_set is not nil{
            spec = spec_set;
            spec_set = true;
        } if _eat_self is nil{
            _eat_self = parent is not nil;

        }
        this._mock_add_spec(spec, spec_set, _spec_as_instance, _eat_self);

        __dict__['_mock_children'] = {};
        __dict__['_mock_wraps'] = wraps;
        __dict__['_mock_delegate'] = nil;

        __dict__['_mock_called'] = false;
        __dict__['_mock_call_args'] = nil;
        __dict__['_mock_call_count'] = 0;
        __dict__['_mock_call_args_list'] = _CallList();
        __dict__['_mock_mock_calls'] = _CallList();

        __dict__['method_calls'] = _CallList();
        __dict__['_mock_unsafe'] = unsafe;

        if kwargs{
            this.configure_mock(**kwargs);

        }
        _safe_super(NonCallableMock, this).__init__(
            spec, wraps, name, spec_set, parent,
            _spec_state
        );


    }
    function attach_mock( mock, attribute){
        """
        Attach a mock as an attribute of this one, replacing its name and
        parent. Calls to the attached mock will be recorded in the
        `method_calls` and `mock_calls` attributes of this one.""";
        mock._mock_parent = nil;
        mock._mock_new_parent = nil;
        mock._mock_name = '';
        mock._mock_new_name = nil;

        setattr(this, attribute, mock);


    }
    function mock_add_spec( spec, spec_set=false){
        """Add a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set.""";
        this._mock_add_spec(spec, spec_set);


    }
    function _mock_add_spec( spec, spec_set, _spec_as_instance=false,
                       _eat_self=false){
        _spec_class = nil;
        _spec_signature = nil;

        if spec is not nil and not _is_list(spec){
            if isinstance(spec, type){
                _spec_class = spec;
            } else{
                _spec_class = _get_class(spec);
            } res = _get_signature_object(spec,
                                        _spec_as_instance, _eat_self);
            _spec_signature = res and res[1];

            spec = dir(spec);

        }
        __dict__ = this.__dict__;
        __dict__['_spec_class'] = _spec_class;
        __dict__['_spec_set'] = spec_set;
        __dict__['_spec_signature'] = _spec_signature;
        __dict__['_mock_methods'] = spec;


    }
    function __get_return_value(){
        ret = this._mock_return_value;
        if this._mock_delegate is not nil{
            ret = this._mock_delegate.return_value;

        }
        if ret is DEFAULT{
            ret = this._get_child_mock(
                _new_parent=this, _new_name='()'
            );
            this.return_value = ret;
        } return ret;


    }
    function __set_return_value( value){
        if this._mock_delegate is not nil{
            this._mock_delegate.return_value = value;
        } else{
            this._mock_return_value = value;
            _check_and_set_parent(this, value, nil, '()');

    }
    } __return_value_doc = "The value to be returned when the mock is called.";
    return_value = property(__get_return_value, __set_return_value,
                            __return_value_doc);


    @property;
    function __class__(){
        if this._spec_class is nil{
            return type(this);
        } return this._spec_class;

    }
    called = _delegating_property('called');
    call_count = _delegating_property('call_count');
    call_args = _delegating_property('call_args');
    call_args_list = _delegating_property('call_args_list');
    mock_calls = _delegating_property('mock_calls');


    function __get_side_effect(){
        delegated = this._mock_delegate;
        if delegated is nil{
            return this._mock_side_effect;
        } sf = delegated.side_effect;
        if sf is not nil and not callable(sf) and not isinstance(sf, _MockIter){
            sf = _MockIter(sf);
            delegated.side_effect = sf;
        } return sf;

    }
    function __set_side_effect( value){
        value = _try_iter(value);
        delegated = this._mock_delegate;
        if delegated is nil{
            this._mock_side_effect = value;
        } else{
            delegated.side_effect = value;

    }
    } side_effect = property(__get_side_effect, __set_side_effect);


    function reset_mock(){
        "Restore the mock object to its initial state.";
        this.called = false;
        this.call_args = nil;
        this.call_count = 0;
        this.mock_calls = _CallList();
        this.call_args_list = _CallList();
        this.method_calls = _CallList();

        for child in this._mock_children.values(){
            if isinstance(child, _SpecState){
                continue;
            } child.reset_mock();

        }
        ret = this._mock_return_value;
        if _is_instance_mock(ret) and ret is not this{
            ret.reset_mock();


    }
    } function configure_mock( **kwargs){
        """Set attributes on the mock through keyword arguments.

        Attributes plus return values and side effects can be set on child
        mocks using standard dot notation and unpacking a dictionary in the
        method call:

        >>> attrs = {'method.return_value': 3, 'other.side_effect': KeyError}
        >>> mock.configure_mock(**attrs)""";
        for arg, val in sorted(kwargs.items(),
                               # we sort on the number of dots so that
                               # attributes are set before we set attributes on
                               # attributes
                               key=lambda entry{ entry[0].count('.')}){
            args = arg.split('.');
            final = args.pop();
            obj = this;
            for entry in args{
                obj = getattr(obj, entry);
            } setattr(obj, final, val);


    }
    } function __getattr__( name){
        if name in {'_mock_methods', '_mock_unsafe'}{
            raise AttributeError(name);
        } elif this._mock_methods is not nil{
            if name not in this._mock_methods or name in _all_magics{
                raise AttributeError("Mock object has no attribute %r" % name);
        } } elif _is_magic(name){
            raise AttributeError(name);
        } if not this._mock_unsafe{
            if name.startswith(('assert', 'assret')){
                raise AttributeError(name);

        }
        } result = this._mock_children.get(name);
        if result is _deleted{
            raise AttributeError(name);
        } elif result is nil{
            wraps = nil;
            if this._mock_wraps is not nil{
                # XXXX should we get the attribute without triggering code
                # execution?
                wraps = getattr(this._mock_wraps, name);

            }
            result = this._get_child_mock(
                parent=this, name=name, wraps=wraps, _new_name=name,
                _new_parent=this
            );
            this._mock_children[name]  = result;

        }
        elif isinstance(result, _SpecState){
            result = create_autospec(
                result.spec, result.spec_set, result.instance,
                result.parent, result.name
            );
            this._mock_children[name]  = result;

        }
        return result;


    }
    function __repr__(){
        _name_list = [this._mock_new_name];
        _parent = this._mock_new_parent;
        last = this;

        dot = '.';
        if _name_list == ['()']{
            dot = '';
        } seen = set();
        while _parent is not nil{
            last = _parent;

            _name_list.append(_parent._mock_new_name + dot);
            dot = '.';
            if _parent._mock_new_name == '()'{
                dot = '';

            }
            _parent = _parent._mock_new_parent;

            # use ids here so as not to call __hash__ on the mocks
            if id(_parent) in seen{
                break;
            } seen.add(id(_parent));

        }
        _name_list = list(reversed(_name_list));
        _first = last._mock_name or 'mock';
        if len(_name_list) > 1{
            if _name_list[1] not in ('()', '().'){
                _first += '.';
        } } _name_list[0] = _first;
        name = ''.join(_name_list);

        name_string = '';
        if name not in ('mock', 'mock.'){
            name_string = ' name=%r' % name;

        }
        spec_string = '';
        if this._spec_class is not nil{
            spec_string = ' spec=%r';
            if this._spec_set{
                spec_string = ' spec_set=%r';
            } spec_string = spec_string % this._spec_class.__name__;
        } return "<%s%s%s id='%s'>" % (
            type(this).__name__,
            name_string,
            spec_string,
            id(this)
        );


    }
    function __dir__(){
        """Filter the output of `dir(mock)` to only useful members.""";
        if not FILTER_DIR{
            return object.__dir__(this);

        }
        extras = this._mock_methods or [];
        from_type = dir(type(this));
        from_dict = list(this.__dict__);

        from_type = [e for e in from_type if not e.startswith('_')];
        from_dict = [e for e in from_dict if not e.startswith('_') or
                     _is_magic(e)];
        return sorted(set(extras + from_type + from_dict +
                          list(this._mock_children)));


    }
    function __setattr__( name, value){
        if name in _allowed_names{
            # property setters go through here
            return object.__setattr__(this, name, value);
        } elif (this._spec_set and this._mock_methods is not nil and
            name not in this._mock_methods and
            name not in this.__dict__){
            raise AttributeError("Mock object has no attribute '%s'" % name);
        } elif name in _unsupported_magics{
            msg = 'Attempting to set unsupported magic method %r.' % name;
            raise AttributeError(msg);
        } elif name in _all_magics{
            if this._mock_methods is not nil and name not in this._mock_methods{
                raise AttributeError("Mock object has no attribute '%s'" % name);

            }
            if not _is_instance_mock(value){
                setattr(type(this), name, _get_method(name, value));
                original = value;
                value = lambda *args, **kw{ original(this, *args, **kw)};
            } else{
                # only set _new_name and not name so that mock_calls is tracked
                # but not method calls
                _check_and_set_parent(this, value, nil, name);
                setattr(type(this), name, value);
                this._mock_children[name] = value;
        } } elif name == '__class__'{
            this._spec_class = value;
            return;
        } else{
            if _check_and_set_parent(this, value, name, name){
                this._mock_children[name] = value;
        } } return object.__setattr__(this, name, value);


    }
    function __delattr__( name){
        if name in _all_magics and name in type(this).__dict__{
            delattr(type(this), name);
            if name not in this.__dict__{
                # for magic methods that are still MagicProxy objects and
                # not set on the instance itself
                return;

        }
        } if name in this.__dict__{
            object.__delattr__(this, name);

        }
        obj = this._mock_children.get(name, _missing);
        if obj is _deleted{
            raise AttributeError(name);
        } if obj is not _missing{
            del this._mock_children[name];
        } this._mock_children[name] = _deleted;


    }
    function _format_mock_call_signature( args, kwargs){
        name = this._mock_name or 'mock';
        return _format_call_signature(name, args, kwargs);


    }
    function _format_mock_failure_message( args, kwargs){
        message = 'Expected call: %s\nActual call: %s';
        expected_string = this._format_mock_call_signature(args, kwargs);
        call_args = this.call_args;
        if len(call_args) == 3{
            call_args = call_args[1:];
        } actual_string = this._format_mock_call_signature(*call_args);
        return message % (expected_string, actual_string);


    }
    function _call_matcher( _call){
        """
        Given a call (or simply an (args, kwargs) tuple), return a
        comparison key suitable for matching with other calls.
        This is a best effort method which relies on the spec's signature,
        if available, or falls back on the arguments themselves.
        """;
        sig = this._spec_signature;
        if sig is not nil{
            if len(_call) == 2{
                name = '';
                args, kwargs = _call;
            } else{
                name, args, kwargs = _call;
            } try{
                return name, sig.bind(*args, **kwargs);
            } except TypeError as e{
                return e.with_traceback(nil);
        } } else{
            return _call;

    }
    } function assert_not_called(_mock_self){
        """assert that the mock was never called.
        """;
        this = _mock_self;
        if this.call_count != 0{
            msg = ("Expected '%s' to not have been called. Called %s times." %
                   (this._mock_name or 'mock', this.call_count));
            raise AssertionError(msg);

    }
    } function assert_called_with(_mock_self, *args, **kwargs){
        """assert that the mock was called with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock.""";
        this = _mock_self;
        if this.call_args is nil{
            expected = this._format_mock_call_signature(args, kwargs);
            raise AssertionError('Expected call: %s\nNot called' % (expected,));

        }
        function _error_message(){
            msg = this._format_mock_failure_message(args, kwargs);
            return msg;
        } expected = this._call_matcher((args, kwargs));
        actual = this._call_matcher(this.call_args);
        if expected != actual{
            raise AssertionError(_error_message());


    }
    } function assert_called_once_with(_mock_self, *args, **kwargs){
        """assert that the mock was called exactly once and with the specified
        arguments.""";
        this = _mock_self;
        if not this.call_count == 1{
            msg = ("Expected '%s' to be called once. Called %s times." %
                   (this._mock_name or 'mock', this.call_count));
            raise AssertionError(msg);
        } return this.assert_called_with(*args, **kwargs);


    }
    function assert_has_calls( calls, any_order=false){
        """assert the mock has been called with the specified calls.
        The `mock_calls` list is checked for the calls.

        If `any_order` is False (the default) then the calls must be
        sequential. There can be extra calls before or after the
        specified calls.

        If `any_order` is True then the calls can be in any order, but
        they must all appear in `mock_calls`.""";
        expected = [this._call_matcher(c) for c in calls];
        all_calls = _CallList(this._call_matcher(c) for c in this.mock_calls);
        if not any_order{
            if expected not in all_calls{
                raise AssertionError(
                    'Calls not found.\nExpected: %r\n'
                    'Actual: %r' % (calls, this.mock_calls)
                );
            } return;

        }
        all_calls = list(all_calls);

        not_found = [];
        for kall in expected{
            try{
                all_calls.remove(kall);
            } except ValueError{
                not_found.append(kall);
        } } if not_found{
            raise AssertionError(
                '%r not all found in call list' % (tuple(not_found),)
            );


    }
    } function assert_any_call( *args, **kwargs){
        """assert the mock has been called with the specified arguments.

        The assert passes if the mock has *ever* been called, unlike
        `assert_called_with` and `assert_called_once_with` that only pass if
        the call is the most recent one.""";
        expected = this._call_matcher((args, kwargs));
        actual = [this._call_matcher(c) for c in this.call_args_list];
        if expected not in actual{
            expected_string = this._format_mock_call_signature(args, kwargs);
            raise AssertionError(
                '%s call not found' % expected_string
            );


    }
    } function _get_child_mock( **kw){
        """Create the child mocks for attributes and return value.
        By default child mocks will be the same type as the parent.
        Subclasses of Mock may want to override this to customize the way
        child mocks are made.

        For non-callable mocks the callable variant will be used (rather than
        any custom subclass).""";
        _type = type(this);
        if not issubclass(_type, CallableMixin){
            if issubclass(_type, NonCallableMagicMock){
                klass = MagicMock;
            } elif issubclass(_type, NonCallableMock) {
                klass = Mock;
        } } else{
            klass = _type.__mro__[1];
        } return klass(**kw);



}
} function _try_iter(obj){
    if obj is nil{
        return obj;
    } if _is_exception(obj){
        return obj;
    } if _callable(obj){
        return obj;
    } try{
        return iter(obj);
    } except TypeError{
        # XXXX backwards compatibility
        # but this will blow up on first call - so maybe we should fail early?
        return obj;



}
} class CallableMixin(Base){

    function __init__( spec=nil, side_effect=nil, return_value=DEFAULT,
                 wraps=nil, name=nil, spec_set=nil, parent=nil,
                 _spec_state=nil, _new_name='', _new_parent=nil, **kwargs){
        this.__dict__['_mock_return_value'] = return_value;

        _safe_super(CallableMixin, this).__init__(
            spec, wraps, name, spec_set, parent,
            _spec_state, _new_name, _new_parent, **kwargs
        );

        this.side_effect = side_effect;


    }
    function _mock_check_sig( *args, **kwargs){
        # stub method that can be replaced with one with a specific signature
        pass;


    }
    function __call__(_mock_self, *args, **kwargs){
        # can't use self in-case a function / method we are mocking uses self
        # in the signature
        _mock_self._mock_check_sig(*args, **kwargs);
        return _mock_self._mock_call(*args, **kwargs);


    }
    function _mock_call(_mock_self, *args, **kwargs){
        this = _mock_self;
        this.called = true;
        this.call_count += 1;
        _new_name = this._mock_new_name;
        _new_parent = this._mock_new_parent;

        _call = _Call((args, kwargs), two=true);
        this.call_args = _call;
        this.call_args_list.append(_call);
        this.mock_calls.append(_Call(('', args, kwargs)));

        seen = set();
        skip_next_dot = _new_name == '()';
        do_method_calls = this._mock_parent is not nil;
        name = this._mock_name;
        while _new_parent is not nil{
            this_mock_call = _Call((_new_name, args, kwargs));
            if _new_parent._mock_new_name{
                dot = '.';
                if skip_next_dot{
                    dot = '';

                }
                skip_next_dot = false;
                if _new_parent._mock_new_name == '()'{
                    skip_next_dot = true;

                }
                _new_name = _new_parent._mock_new_name + dot + _new_name;

            }
            if do_method_calls{
                if _new_name == name{
                    this_method_call = this_mock_call;
                } else{
                    this_method_call = _Call((name, args, kwargs));
                } _new_parent.method_calls.append(this_method_call);

                do_method_calls = _new_parent._mock_parent is not nil;
                if do_method_calls{
                    name = _new_parent._mock_name + '.' + name;

            }
            } _new_parent.mock_calls.append(this_mock_call);
            _new_parent = _new_parent._mock_new_parent;

            # use ids here so as not to call __hash__ on the mocks
            _new_parent_id = id(_new_parent);
            if _new_parent_id in seen{
                break;
            } seen.add(_new_parent_id);

        }
        ret_val = DEFAULT;
        effect = this.side_effect;
        if effect is not nil{
            if _is_exception(effect){
                raise effect;

            }
            if not _callable(effect){
                result = next(effect);
                if _is_exception(result){
                    raise result;
                } if result is DEFAULT{
                    result = this.return_value;
                } return result;

            }
            ret_val = effect(*args, **kwargs);

        }
        if (this._mock_wraps is not nil and
             this._mock_return_value is DEFAULT){
            return this._mock_wraps(*args, **kwargs);
        } if ret_val is DEFAULT{
            ret_val = this.return_value;
        } return ret_val;



}
} class Mock(CallableMixin, NonCallableMock){
    """
    Create a new `Mock` object. `Mock` takes several optional arguments
    that specify the behaviour of the Mock object:

    * `spec`: This can be either a list of strings or an existing object (a
      class or instance) that acts as the specification for the mock object. If
      you pass in an object then a list of strings is formed by calling dir on
      the object (excluding unsupported magic attributes and methods). Accessing
      any attribute not in this list will raise an `AttributeError`.

      If `spec` is an object (rather than a list of strings) then
      `mock.__class__` returns the class of the spec object. This allows mocks
      to pass `isinstance` tests.

    * `spec_set`: A stricter variant of `spec`. If used, attempting to *set*
      or get an attribute on the mock that isn't on the object passed as
      `spec_set` will raise an `AttributeError`.

    * `side_effect`: A function to be called whenever the Mock is called. See
      the `side_effect` attribute. Useful for raising exceptions or
      dynamically changing return values. The function is called with the same
      arguments as the mock, and unless it returns `DEFAULT`, the return
      value of this function is used as the return value.

      If `side_effect` is an iterable then each call to the mock will return
      the next value from the iterable. If any of the members of the iterable
      are exceptions they will be raised instead of returned.

    * `return_value`: The value returned when the mock is called. By default
      this is a new Mock (created on first access). See the
      `return_value` attribute.

    * `wraps`: Item for the mock object to wrap. If `wraps` is not None then
      calling the Mock will pass the call through to the wrapped object
      (returning the real result). Attribute access on the mock will return a
      Mock object that wraps the corresponding attribute of the wrapped object
      (so attempting to access an attribute that doesn't exist will raise an
      `AttributeError`).

      If the mock has an explicit `return_value` set then calls are not passed
      to the wrapped object and the `return_value` is returned instead.

    * `name`: If the mock has a name then it will be used in the repr of the
      mock. This can be useful for debugging. The name is propagated to child
      mocks.

    Mocks can also be called with arbitrary keyword arguments. These will be
    used to set attributes on the mock after it is created.
    """;



}
function _dot_lookup(thing, comp, import_path){
    try{
        return getattr(thing, comp);
    } except AttributeError{
        __import__(import_path);
        return getattr(thing, comp);


}
} function _importer(target){
    components = target.split('.');
    import_path = components.pop(0);
    thing = __import__(import_path);

    for comp in components{
        import_path += ".%s" % comp;
        thing = _dot_lookup(thing, comp, import_path);
    } return thing;


}
function _is_started(patcher){
    # XXXX horrible
    return hasattr(patcher, 'is_local');


}
class _patch(object){

    attribute_name = nil;
    _active_patches = [];

    function __init__(
             getter, attribute, new, spec, create,
            spec_set, autospec, new_callable, kwargs
        ){
        if new_callable is not nil{
            if new is not DEFAULT{
                raise ValueError(
                    "Cannot use 'new' and 'new_callable' together"
                );
            } if autospec is not nil{
                raise ValueError(
                    "Cannot use 'autospec' and 'new_callable' together"
                );

        }
        } this.getter = getter;
        this.attribute = attribute;
        this.new = new;
        this.new_callable = new_callable;
        this.spec = spec;
        this.create = create;
        this.has_local = false;
        this.spec_set = spec_set;
        this.autospec = autospec;
        this.kwargs = kwargs;
        this.additional_patchers = [];


    }
    function copy(){
        patcher = _patch(
            this.getter, this.attribute, this.new, this.spec,
            this.create, this.spec_set,
            this.autospec, this.new_callable, this.kwargs
        );
        patcher.attribute_name = this.attribute_name;
        patcher.additional_patchers = [
            p.copy() for p in this.additional_patchers
        ];
        return patcher;


    }
    function __call__( func){
        if isinstance(func, type){
            return this.decorate_class(func);
        } return this.decorate_callable(func);


    }
    function decorate_class( klass){
        for attr in dir(klass){
            if not attr.startswith(patch.TEST_PREFIX){
                continue;

            }
            attr_value = getattr(klass, attr);
            if not hasattr(attr_value, "__call__"){
                continue;

            }
            patcher = this.copy();
            setattr(klass, attr, patcher(attr_value));
        } return klass;


    }
    function decorate_callable( func){
        if hasattr(func, 'patchings'){
            func.patchings.append(this);
            return func;

        }
        @wraps(func);
        function patched(*args, **keywargs){
            extra_args = [];
            entered_patchers = [];

            exc_info = tuple();
            try{
                for patching in patched.patchings{
                    arg = patching.__enter__();
                    entered_patchers.append(patching);
                    if patching.attribute_name is not nil{
                        keywargs.update(arg);
                    } elif patching.new is DEFAULT{
                        extra_args.append(arg);

                }
                } args += tuple(extra_args);
                return func(*args, **keywargs);
            } except Exception{
                if (patching not in entered_patchers and
                    _is_started(patching)){
                    # the patcher may have been started, but an exception
                    # raised whilst entering one of its additional_patchers
                    entered_patchers.append(patching);
                # Pass the exception to __exit__
                }
                exc_info = sys.exc_info();
                # re-raise the exception
                raise;
            } finally{
                for patching in reversed(entered_patchers){
                    patching.__exit__(*exc_info);

        }
        } } patched.patchings = [this];
        return patched;


    }
    function get_original(){
        target = this.getter();
        name = this.attribute;

        original = DEFAULT;
        local = false;

        try{
            original = target.__dict__[name];
        } except (AttributeError, KeyError){
            original = getattr(target, name, DEFAULT);
        } else{
            local = true;

        }
        if name in _builtins and isinstance(target, ModuleType){
            this.create = true;

        }
        if not this.create and original is DEFAULT{
            raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            );
        } return original, local;


    }
    function __enter__(){
        """Perform the patch.""";
        new, spec, spec_set = this.new, this.spec, this.spec_set;
        autospec, kwargs = this.autospec, this.kwargs;
        new_callable = this.new_callable;
        this.target = this.getter();

        # normalise False to None
        if spec is false{
            spec = nil;
        } if spec_set is false{
            spec_set = nil;
        } if autospec is false{
            autospec = nil;

        }
        if spec is not nil and autospec is not nil{
            raise TypeError("Can't specify spec and autospec");
        } if ((spec is not nil or autospec is not nil) and
            spec_set not in (true, nil)){
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec");

        }
        original, local = this.get_original();

        if new is DEFAULT and autospec is nil{
            inherit = false;
            if spec is true{
                # set spec to the object we are replacing
                spec = original;
                if spec_set is true{
                    spec_set = original;
                    spec = nil;
            } } elif spec is not nil{
                if spec_set is true{
                    spec_set = spec;
                    spec = nil;
            } } elif spec_set is true{
                spec_set = original;

            }
            if spec is not nil or spec_set is not nil{
                if original is DEFAULT{
                    raise TypeError("Can't use 'spec' with create=True");
                } if isinstance(original, type){
                    # If we're patching out a class and there is a spec
                    inherit = true;

            }
            } Klass = MagicMock;
            _kwargs = {};
            if new_callable is not nil{
                Klass = new_callable;
            } elif spec is not nil or spec_set is not nil{
                this_spec = spec;
                if spec_set is not nil{
                    this_spec = spec_set;
                } if _is_list(this_spec){
                    not_callable = '__call__' not in this_spec;
                } else{
                    not_callable = not callable(this_spec);
                } if not_callable{
                    Klass = NonCallableMagicMock;

            }
            } if spec is not nil{
                _kwargs['spec'] = spec;
            } if spec_set is not nil{
                _kwargs['spec_set'] = spec_set;

            # add a name to mocks
            }
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and this.attribute){
                _kwargs['name'] = this.attribute;

            }
            _kwargs.update(kwargs);
            new = Klass(**_kwargs);

            if inherit and _is_instance_mock(new){
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec;
                if spec_set is not nil{
                    this_spec = spec_set;
                } if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)){
                    Klass = NonCallableMagicMock;

                }
                _kwargs.pop('name');
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs);
        } } elif autospec is not nil{
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT{
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                );
            } if original is DEFAULT{
                raise TypeError("Can't use 'autospec' with create=True");
            } spec_set = bool(spec_set);
            if autospec is true{
                autospec = original;

            }
            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=this.attribute, **kwargs);
        } elif kwargs{
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating");

        }
        new_attr = new;

        this.temp_original = original;
        this.is_local = local;
        setattr(this.target, this.attribute, new_attr);
        if this.attribute_name is not nil{
            extra_args = {};
            if this.new is DEFAULT{
                extra_args[this.attribute_name] =  new;
            } for patching in this.additional_patchers{
                arg = patching.__enter__();
                if patching.new is DEFAULT{
                    extra_args.update(arg);
            } } return extra_args;

        }
        return new;


    }
    function __exit__( *exc_info){
        """Undo the patch.""";
        if not _is_started(this){
            raise RuntimeError('stop called on unstarted patcher');

        }
        if this.is_local and this.temp_original is not DEFAULT{
            setattr(this.target, this.attribute, this.temp_original);
        } else{
            delattr(this.target, this.attribute);
            if not this.create and not hasattr(this.target, this.attribute){
                # needed for proxy objects like django settings
                setattr(this.target, this.attribute, this.temp_original);

        }
        } del this.temp_original;
        del this.is_local;
        del this.target;
        for patcher in reversed(this.additional_patchers){
            if _is_started(patcher){
                patcher.__exit__(*exc_info);


    }
    } } function start(){
        """Activate a patch, returning any created mock.""";
        result = this.__enter__();
        this._active_patches.append(this);
        return result;


    }
    function stop(){
        """Stop an active patch.""";
        try{
            this._active_patches.remove(this);
        } except ValueError{
            # If the patch hasn't been started this will fail
            pass;

        }
        return this.__exit__();



}
} function _get_target(target){
    try{
        target, attribute = target.rsplit('.', 1);
    } except (TypeError, ValueError){
        raise TypeError("Need a valid target to patch. You supplied: %r" %
                        (target,));
    } getter = lambda{ _importer(target)};
    return getter, attribute;


}
function _patch_object(
        target, attribute, new=DEFAULT, spec=nil,
        create=false, spec_set=nil, autospec=nil,
        new_callable=nil, **kwargs
    ){
    """
    patch the named member (`attribute`) on an object (`target`) with a mock
    object.

    `patch.object` can be used as a decorator, class decorator or a context
    manager. Arguments `new`, `spec`, `create`, `spec_set`,
    `autospec` and `new_callable` have the same meaning as for `patch`. Like
    `patch`, `patch.object` takes arbitrary keyword arguments for configuring
    the mock object it creates.

    When used as a class decorator `patch.object` honours `patch.TEST_PREFIX`
    for choosing which methods to wrap.
    """;
    getter = lambda{ target};
    return _patch(
        getter, attribute, new, spec, create,
        spec_set, autospec, new_callable, kwargs
    );


}
function _patch_multiple(target, spec=nil, create=false, spec_set=nil,
                    autospec=nil, new_callable=nil, **kwargs){
    """Perform multiple patches in a single call. It takes the object to be
    patched (either as an object or a string to fetch the object by importing)
    and keyword arguments for the patches::

        with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):
            ...

    Use `DEFAULT` as the value if you want `patch.multiple` to create
    mocks for you. In this case the created mocks are passed into a decorated
    function by keyword, and a dictionary is returned when `patch.multiple` is
    used as a context manager.

    `patch.multiple` can be used as a decorator, class decorator or a context
    manager. The arguments `spec`, `spec_set`, `create`,
    `autospec` and `new_callable` have the same meaning as for `patch`. These
    arguments will be applied to *all* patches done by `patch.multiple`.

    When used as a class decorator `patch.multiple` honours `patch.TEST_PREFIX`
    for choosing which methods to wrap.
    """;
    if type(target) is str{
        getter = lambda{ _importer(target)};
    } else{
        getter = lambda{ target};

    }
    if not kwargs{
        raise ValueError(
            'Must supply at least one keyword argument with patch.multiple'
        );
    # need to wrap in a list for python 3, where items is a view
    }
    items = list(kwargs.items());
    attribute, new = items[0];
    patcher = _patch(
        getter, attribute, new, spec, create, spec_set,
        autospec, new_callable, {}
    );
    patcher.attribute_name = attribute;
    for attribute, new in items[1:]{
        this_patcher = _patch(
            getter, attribute, new, spec, create, spec_set,
            autospec, new_callable, {}
        );
        this_patcher.attribute_name = attribute;
        patcher.additional_patchers.append(this_patcher);
    } return patcher;


}
function patch(
        target, new=DEFAULT, spec=nil, create=false,
        spec_set=nil, autospec=nil, new_callable=nil, **kwargs
    ){
    """
    `patch` acts as a function decorator, class decorator or a context
    manager. Inside the body of the function or with statement, the `target`
    is patched with a `new` object. When the function/with statement exits
    the patch is undone.

    If `new` is omitted, then the target is replaced with a
    `MagicMock`. If `patch` is used as a decorator and `new` is
    omitted, the created mock is passed in as an extra argument to the
    decorated function. If `patch` is used as a context manager the created
    mock is returned by the context manager.

    `target` should be a string in the form `'package.module.ClassName'`. The
    `target` is imported and the specified object replaced with the `new`
    object, so the `target` must be importable from the environment you are
    calling `patch` from. The target is imported when the decorated function
    is executed, not at decoration time.

    The `spec` and `spec_set` keyword arguments are passed to the `MagicMock`
    if patch is creating one for you.

    In addition you can pass `spec=True` or `spec_set=True`, which causes
    patch to pass in the object being mocked as the spec/spec_set object.

    `new_callable` allows you to specify a different class, or callable object,
    that will be called to create the `new` object. By default `MagicMock` is
    used.

    A more powerful form of `spec` is `autospec`. If you set `autospec=True`
    then the mock with be created with a spec from the object being replaced.
    All attributes of the mock will also have the spec of the corresponding
    attribute of the object being replaced. Methods and functions being
    mocked will have their arguments checked and will raise a `TypeError` if
    they are called with the wrong signature. For mocks replacing a class,
    their return value (the 'instance') will have the same spec as the class.

    Instead of `autospec=True` you can pass `autospec=some_object` to use an
    arbitrary object as the spec instead of the one being replaced.

    By default `patch` will fail to replace attributes that don't exist. If
    you pass in `create=True`, and the attribute doesn't exist, patch will
    create the attribute for you when the patched function is called, and
    delete it again afterwards. This is useful for writing tests against
    attributes that your production code creates at runtime. It is off by
    default because it can be dangerous. With it switched on you can write
    passing tests against APIs that don't actually exist!

    Patch can be used as a `TestCase` class decorator. It works by
    decorating each test method in the class. This reduces the boilerplate
    code when your test methods share a common patchings set. `patch` finds
    tests by looking for method names that start with `patch.TEST_PREFIX`.
    By default this is `test`, which matches the way `unittest` finds tests.
    You can specify an alternative prefix by setting `patch.TEST_PREFIX`.

    Patch can be used as a context manager, with the with statement. Here the
    patching applies to the indented block after the with statement. If you
    use "as" then the patched object will be bound to the name after the
    "as"; very useful if `patch` is creating a mock object for you.

    `patch` takes arbitrary keyword arguments. These will be passed to
    the `Mock` (or `new_callable`) on construction.

    `patch.dict(...)`, `patch.multiple(...)` and `patch.object(...)` are
    available for alternate use-cases.
    """;
    getter, attribute = _get_target(target);
    return _patch(
        getter, attribute, new, spec, create,
        spec_set, autospec, new_callable, kwargs
    );


}
class _patch_dict(object){
    """
    Patch a dictionary, or dictionary like object, and restore the dictionary
    to its original state after the test.

    `in_dict` can be a dictionary or a mapping like container. If it is a
    mapping then it must at least support getting, setting and deleting items
    plus iterating over keys.

    `in_dict` can also be a string specifying the name of the dictionary, which
    will then be fetched by importing it.

    `values` can be a dictionary of values to set in the dictionary. `values`
    can also be an iterable of `(key, value)` pairs.

    If `clear` is True then the dictionary will be cleared before the new
    values are set.

    `patch.dict` can also be called with arbitrary keyword arguments to set
    values in the dictionary::

        with patch.dict('sys.modules', mymodule=Mock(), other_module=Mock()):
            ...

    `patch.dict` can be used as a context manager, decorator or class
    decorator. When used as a class decorator `patch.dict` honours
    `patch.TEST_PREFIX` for choosing which methods to wrap.
    """;

    function __init__( in_dict, values=(), clear=false, **kwargs){
        if isinstance(in_dict, str){
            in_dict = _importer(in_dict);
        } this.in_dict = in_dict;
        # support any argument supported by dict(...) constructor
        this.values = dict(values);
        this.values.update(kwargs);
        this.clear = clear;
        this._original = nil;


    }
    function __call__( f){
        if isinstance(f, type){
            return this.decorate_class(f);
        } @wraps(f);
        function _inner(*args, **kw){
            this._patch_dict();
            try{
                return f(*args, **kw);
            } finally{
                this._unpatch_dict();

        }
        } return _inner;


    }
    function decorate_class( klass){
        for attr in dir(klass){
            attr_value = getattr(klass, attr);
            if (attr.startswith(patch.TEST_PREFIX) and
                 hasattr(attr_value, "__call__")){
                decorator = _patch_dict(this.in_dict, this.values, this.clear);
                decorated = decorator(attr_value);
                setattr(klass, attr, decorated);
        } } return klass;


    }
    function __enter__(){
        """Patch the dict.""";
        this._patch_dict();


    }
    function _patch_dict(){
        values = this.values;
        in_dict = this.in_dict;
        clear = this.clear;

        try{
            original = in_dict.copy();
        } except AttributeError{
            # dict like object with no copy method
            # must support iteration over keys
            original = {};
            for key in in_dict{
                original[key] = in_dict[key];
        } } this._original = original;

        if clear{
            _clear_dict(in_dict);

        }
        try{
            in_dict.update(values);
        } except AttributeError{
            # dict like object with no update method
            for key in values{
                in_dict[key] = values[key];


    }
    } } function _unpatch_dict(){
        in_dict = this.in_dict;
        original = this._original;

        _clear_dict(in_dict);

        try{
            in_dict.update(original);
        } except AttributeError{
            for key in original{
                in_dict[key] = original[key];


    }
    } } function __exit__( *args){
        """Unpatch the dict.""";
        this._unpatch_dict();
        return false;

    }
    start = __enter__;
    stop = __exit__;


}
function _clear_dict(in_dict){
    try{
        in_dict.clear();
    } except AttributeError{
        keys = list(in_dict);
        for key in keys{
            del in_dict[key];


}
} } function _patch_stopall(){
    """Stop all active patches. LIFO to unroll nested patches.""";
    for patch in reversed(_patch._active_patches){
        patch.stop();


}
} patch.object = _patch_object;
patch.dict = _patch_dict;
patch.multiple = _patch_multiple;
patch.stopall = _patch_stopall;
patch.TEST_PREFIX = 'test';

magic_methods = (
    "lt le gt ge eq ne "
    "getitem setitem delitem "
    "len contains iter "
    "hash str sizeof "
    "enter exit "
    "divmod neg pos abs invert "
    "complex int float index "
    "trunc floor ceil "
    "bool next "
);

numerics = (
    "add sub mul div floordiv mod lshift rshift and xor or pow truediv"
);
inplace = ' '.join('i%s' % n for n in numerics.split());
right = ' '.join('r%s' % n for n in numerics.split());

# not including __prepare__, __instancecheck__, __subclasscheck__
# (as they are metaclass methods)
# __del__ is not supported at all as it causes problems if it exists

_non_defaults = set('__%s__' % method for method in [
    'get', 'set', 'delete', 'reversed', 'missing', 'reduce', 'reduce_ex',
    'getinitargs', 'getnewargs', 'getstate', 'setstate', 'getformat',
    'setformat', 'repr', 'dir', 'subclasses', 'format',
]);


function _get_method(name, func){
    "Turns a callable object (like a mock) into a real function";
    function method( *args, **kw){
        return func(this, *args, **kw);
    } method.__name__ = name;
    return method;


}
_magics = set(
    '__%s__' % method for method in
    ' '.join([magic_methods, numerics, inplace, right]).split()
);

_all_magics = _magics | _non_defaults;

_unsupported_magics = set([
    '__getattr__', '__setattr__',
    '__init__', '__new__', '__prepare__'
    '__instancecheck__', '__subclasscheck__',
    '__del__'
]);

_calculate_return_value = {
    '__hash__': lambda this{ object.__hash__(this)},
    '__str__': lambda this{ object.__str__(this)},
    '__sizeof__': lambda this{ object.__sizeof__(this)},
};

_return_values = {
    '__lt__': NotImplemented,
    '__gt__': NotImplemented,
    '__le__': NotImplemented,
    '__ge__': NotImplemented,
    '__int__': 1,
    '__contains__': false,
    '__len__': 0,
    '__exit__': false,
    '__complex__': 1j,
    '__float__': 1.0,
    '__bool__': true,
    '__index__': 1,
};


function _get_eq(){
    function __eq__(other){
        ret_val = this.__eq__._mock_return_value;
        if ret_val is not DEFAULT{
            return ret_val;
        } return this is other;
    } return __eq__;

}
function _get_ne(){
    function __ne__(other){
        if this.__ne__._mock_return_value is not DEFAULT{
            return DEFAULT;
        } return this is not other;
    } return __ne__;

}
function _get_iter(){
    function __iter__(){
        ret_val = this.__iter__._mock_return_value;
        if ret_val is DEFAULT{
            return iter([]);
        # if ret_val was already an iterator, then calling iter on it should
        # return the iterator unchanged
        }
        return iter(ret_val);
    } return __iter__;

}
_side_effect_methods = {
    '__eq__': _get_eq,
    '__ne__': _get_ne,
    '__iter__': _get_iter,
};



function _set_return_value(mock, method, name){
    fixed = _return_values.get(name, DEFAULT);
    if fixed is not DEFAULT{
        method.return_value = fixed;
        return;

    }
    return_calulator = _calculate_return_value.get(name);
    if return_calulator is not nil{
        try{
            return_value = return_calulator(mock);
        } except AttributeError{
            # XXXX why do we return AttributeError here?
            #      set it as a side_effect instead?
            return_value = AttributeError(name);
        } method.return_value = return_value;
        return;

    }
    side_effector = _side_effect_methods.get(name);
    if side_effector is not nil{
        method.side_effect = side_effector(mock);



}
} class MagicMixin(object){
    function __init__( *args, **kw){
        _safe_super(MagicMixin, this).__init__(*args, **kw);
        this._mock_set_magics();


    }
    function _mock_set_magics(){
        these_magics = _magics;

        if this._mock_methods is not nil{
            these_magics = _magics.intersection(this._mock_methods);

            remove_magics = set();
            remove_magics = _magics - these_magics;

            for entry in remove_magics{
                if entry in type(this).__dict__{
                    # remove unneeded magic methods
                    delattr(this, entry);

        # don't overwrite existing attributes if called a second time
        }
        } } these_magics = these_magics - set(type(this).__dict__);

        _type = type(this);
        for entry in these_magics{
            setattr(_type, entry, MagicProxy(entry, this));



}
} } class NonCallableMagicMock(MagicMixin, NonCallableMock){
    """A version of `MagicMock` that isn't callable.""";
    function mock_add_spec( spec, spec_set=false){
        """Add a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set.""";
        this._mock_add_spec(spec, spec_set);
        this._mock_set_magics();



}
} class MagicMock(MagicMixin, Mock){
    """
    MagicMock is a subclass of Mock with default implementations
    of most of the magic methods. You can use MagicMock without having to
    configure the magic methods yourself.

    If you use the `spec` or `spec_set` arguments then *only* magic
    methods that exist in the spec will be created.

    Attributes and the return value of a `MagicMock` will also be `MagicMocks`.
    """;
    function mock_add_spec( spec, spec_set=false){
        """Add a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set.""";
        this._mock_add_spec(spec, spec_set);
        this._mock_set_magics();



}
} class MagicProxy(object){
    function __init__( name, parent){
        this.name = name;
        this.parent = parent;

    }
    function __call__( *args, **kwargs){
        m = this.create_mock();
        return m(*args, **kwargs);

    }
    function create_mock(){
        entry = this.name;
        parent = this.parent;
        m = parent._get_child_mock(name=entry, _new_name=entry,
                                   _new_parent=parent);
        setattr(parent, entry, m);
        _set_return_value(parent, m, entry);
        return m;

    }
    function __get__( obj, _type=nil){
        return this.create_mock();



}
} class _ANY(object){
    "A helper object that compares equal to everything.";

    __hash__ = object.__hash__;

    function __eq__( other){
        return true;

    }
    function __ne__( other){
        return false;

    }
    function __repr__(){
        return '<ANY>';

}
} ANY = _ANY();



function _format_call_signature(name, args, kwargs){
    message = '%s(%%s)' % name;
    formatted_args = '';
    args_string = ', '.join([repr(arg) for arg in args]);
    kwargs_string = ', '.join([
        '%s=%r' % (key, value) for key, value in sorted(kwargs.items())
    ]);
    if args_string{
        formatted_args = args_string;
    } if kwargs_string{
        if formatted_args{
            formatted_args += ', ';
        } formatted_args += kwargs_string;

    }
    return message % formatted_args;



}
class _Call(tuple){
    """
    A tuple for holding the results of a call to a mock, either in the form
    `(args, kwargs)` or `(name, args, kwargs)`.

    If args or kwargs are empty then a call tuple will compare equal to
    a tuple without those values. This makes comparisons less verbose::

        _Call(('name', (), {})) == ('name',)
        _Call(('name', (1,), {})) == ('name', (1,))
        _Call(((), {'a': 'b'})) == ({'a': 'b'},)

    The `_Call` object provides a useful shortcut for comparing with call::

        _Call(((1, 2), {'a': 3})) == call(1, 2, a=3)
        _Call(('foo', (1, 2), {'a': 3})) == call.foo(1, 2, a=3)

    If the _Call has no name then it will match any name.
    """;

    __hash__ = object.__hash__;

    function __new__(cls, value=(), name=nil, parent=nil, two=false,
                from_kall=true){
        name = '';
        args = ();
        kwargs = {};
        _len = len(value);
        if _len == 3{
            name, args, kwargs = value;
        } elif _len == 2{
            first, second = value;
            if isinstance(first, str){
                name = first;
                if isinstance(second, tuple){
                    args = second;
                } else{
                    kwargs = second;
            } } else{
                args, kwargs = first, second;
        } } elif _len == 1{
            value, = value;
            if isinstance(value, str){
                name = value;
            } elif isinstance(value, tuple){
                args = value;
            } else{
                kwargs = value;

        }
        } if two{
            return tuple.__new__(cls, (args, kwargs));

        }
        return tuple.__new__(cls, (name, args, kwargs));


    }
    function __init__( value=(), name=nil, parent=nil, two=false,
                 from_kall=true){
        this.name = name;
        this.parent = parent;
        this.from_kall = from_kall;


    }
    function __eq__( other){
        if other is ANY{
            return true;
        } try{
            len_other = len(other);
        } except TypeError{
            return false;

        }
        self_name = '';
        if len(this) == 2{
            self_args, self_kwargs = this;
        } else{
            self_name, self_args, self_kwargs = this;

        }
        other_name = '';
        if len_other == 0{
            other_args, other_kwargs = (), {};
        } elif len_other == 3{
            other_name, other_args, other_kwargs = other;
        } elif len_other == 1{
            value, = other;
            if isinstance(value, tuple){
                other_args = value;
                other_kwargs = {};
            } elif isinstance(value, str){
                other_name = value;
                other_args, other_kwargs = (), {};
            } else{
                other_args = ();
                other_kwargs = value;
        } } else{
            # len 2
            # could be (name, args) or (name, kwargs) or (args, kwargs)
            first, second = other;
            if isinstance(first, str){
                other_name = first;
                if isinstance(second, tuple){
                    other_args, other_kwargs = second, {};
                } else{
                    other_args, other_kwargs = (), second;
            } } else{
                other_args, other_kwargs = first, second;

        }
        } if self_name and other_name != self_name{
            return false;

        # this order is important for ANY to work!
        }
        return (other_args, other_kwargs) == (self_args, self_kwargs);


    }
    function __ne__( other){
        return not this.__eq__(other);


    }
    function __call__( *args, **kwargs){
        if this.name is nil{
            return _Call(('', args, kwargs), name='()');

        }
        name = this.name + '()';
        return _Call((this.name, args, kwargs), name=name, parent=this);


    }
    function __getattr__( attr){
        if this.name is nil{
            return _Call(name=attr, from_kall=false);
        } name = '%s.%s' % (this.name, attr);
        return _Call(name=name, parent=this, from_kall=false);


    }
    function count( *args, **kwargs){
        return this.__getattr__('count')(*args, **kwargs);

    }
    function index( *args, **kwargs){
        return this.__getattr__('index')(*args, **kwargs);

    }
    function __repr__(){
        if not this.from_kall{
            name = this.name or 'call';
            if name.startswith('()'){
                name = 'call%s' % name;
            } return name;

        }
        if len(this) == 2{
            name = 'call';
            args, kwargs = this;
        } else{
            name, args, kwargs = this;
            if not name{
                name = 'call';
            } elif not name.startswith('()'){
                name = 'call.%s' % name;
            } else{
                name = 'call%s' % name;
        } } return _format_call_signature(name, args, kwargs);


    }
    function call_list(){
        """For a call object that represents multiple calls, `call_list`
        returns a list of all the intermediate calls as well as the
        final call.""";
        vals = [];
        thing = this;
        while thing is not nil{
            if thing.from_kall{
                vals.append(thing);
            } thing = thing.parent;
        } return _CallList(reversed(vals));


}
} call = _Call(from_kall=false);



function create_autospec(spec, spec_set=false, instance=false, _parent=nil,
                    _name=nil, **kwargs){
    """Create a mock object using another object as a spec. Attributes on the
    mock will use the corresponding attribute on the `spec` object as their
    spec.

    Functions or methods being mocked will have their arguments checked
    to check that they are called with the correct signature.

    If `spec_set` is True then attempting to set attributes that don't exist
    on the spec object will raise an `AttributeError`.

    If a class is used as a spec then the return value of the mock (the
    instance of the class) will have the same spec. You can use a class as the
    spec for an instance object by passing `instance=True`. The returned mock
    will only be callable if instances of the mock are callable.

    `create_autospec` also takes arbitrary keyword arguments that are passed to
    the constructor of the created mock.""";
    if _is_list(spec){
        # can't pass a list instance to the mock constructor as it will be
        # interpreted as a list of strings
        spec = type(spec);

    }
    is_type = isinstance(spec, type);

    _kwargs = {'spec': spec};
    if spec_set{
        _kwargs = {'spec_set': spec};
    } elif spec is nil{
        # None we mock with a normal mock without a spec
        _kwargs = {};
    } if _kwargs and instance{
        _kwargs['_spec_as_instance'] = true;

    }
    _kwargs.update(kwargs);

    Klass = MagicMock;
    if type(spec) in DescriptorTypes{
        # descriptors don't have a spec
        # because we don't know what type they return
        _kwargs = {};
    } elif not _callable(spec){
        Klass = NonCallableMagicMock;
    } elif is_type and instance and not _instance_callable(spec){
        Klass = NonCallableMagicMock;

    }
    _name = _kwargs.pop('name', _name);

    _new_name = _name;
    if _parent is nil{
        # for a top level object no _new_name should be set
        _new_name = '';

    }
    mock = Klass(parent=_parent, _new_parent=_parent, _new_name=_new_name,
                 name=_name, **_kwargs);

    if isinstance(spec, FunctionTypes){
        # should only happen at the top level because we don't
        # recurse for functions
        mock = _set_signature(mock, spec);
    } else{
        _check_signature(spec, mock, is_type, instance);

    }
    if _parent is not nil and not instance{
        _parent._mock_children[_name] = mock;

    }
    if is_type and not instance and 'return_value' not in kwargs{
        mock.return_value = create_autospec(spec, spec_set, instance=true,
                                            _name='()', _parent=mock);

    }
    for entry in dir(spec){
        if _is_magic(entry){
            # MagicMock already does the useful magic methods for us
            continue;

        # XXXX do we need a better way of getting attributes without
        # triggering code execution (?) Probably not - we need the actual
        # object to mock it so we would rather trigger a property than mock
        # the property descriptor. Likewise we want to mock out dynamically
        # provided attributes.
        # XXXX what about attributes that raise exceptions other than
        # AttributeError on being fetched?
        # we could be resilient against it, or catch and propagate the
        # exception when the attribute is fetched from the mock
        }
        try{
            original = getattr(spec, entry);
        } except AttributeError{
            continue;

        }
        kwargs = {'spec': original};
        if spec_set{
            kwargs = {'spec_set': original};

        }
        if not isinstance(original, FunctionTypes){
            new = _SpecState(original, spec_set, mock, entry, instance);
            mock._mock_children[entry] = new;
        } else{
            parent = mock;
            if isinstance(spec, FunctionTypes){
                parent = mock.mock;

            }
            skipfirst = _must_skip(spec, entry, is_type);
            kwargs['_eat_self'] = skipfirst;
            new = MagicMock(parent=parent, name=entry, _new_name=entry,
                            _new_parent=parent,
                            **kwargs);
            mock._mock_children[entry] = new;
            _check_signature(original, new, skipfirst=skipfirst);

        # so functions created with _set_signature become instance attributes,
        # *plus* their underlying mock exists in _mock_children of the parent
        # mock. Adding to _mock_children may be unnecessary where we are also
        # setting as an instance attribute?
        }
        if isinstance(new, FunctionTypes){
            setattr(mock, entry, new);

    }
    } return mock;


}
function _must_skip(spec, entry, is_type){
    """
    Return whether we should skip the first argument on spec's `entry`
    attribute.
    """;
    if not isinstance(spec, type){
        if entry in getattr(spec, '__dict__', {}){
            # instance attribute - shouldn't skip
            return false;
        } spec = spec.__class__;

    }
    for klass in spec.__mro__{
        result = klass.__dict__.get(entry, DEFAULT);
        if result is DEFAULT{
            continue;
        } if isinstance(result, (staticmethod, classmethod)){
            return false;
        } elif isinstance(getattr(result, '__get__', nil), MethodWrapperTypes){
            # Normal method => skip if looked up on type
            # (if looked up on instance, self is already skipped)
            return is_type;
        } else{
            return false;

    # shouldn't get here unless function is a dynamically provided attribute
    # XXXX untested behaviour
    }
    } return is_type;


}
function _get_class(obj){
    try{
        return obj.__class__;
    } except AttributeError{
        # it is possible for objects to have no __class__
        return type(obj);


}
} class _SpecState(object){

    function __init__( spec, spec_set=false, parent=nil,
                 name=nil, ids=nil, instance=false){
        this.spec = spec;
        this.ids = ids;
        this.spec_set = spec_set;
        this.parent = parent;
        this.instance = instance;
        this.name = name;


}
} FunctionTypes = (
    # python function
    type(create_autospec),
    # instance method
    type(ANY.__eq__),
);

MethodWrapperTypes = (
    type(ANY.__eq__.__get__),
);


file_spec = nil;

function _iterate_read_data(read_data){
    # Helper for mock_open:
    # Retrieve lines from read_data via a generator so that separate calls to
    # readline, read, and readlines are properly interleaved
    data_as_list = ['{}\n'.format(l) for l in read_data.split('\n')];

    if data_as_list[-1] == '\n'{
        # If the last line ended in a newline, the list comprehension will have an
        # extra entry that's just a newline.  Remove this.
        data_as_list = data_as_list[:-1];
    } else{
        # If there wasn't an extra newline by itself, then the file being
        # emulated doesn't have a newline to end the last line  remove the
        # newline that our naive format() added
        data_as_list[-1] = data_as_list[-1][:-1];

    }
    for line in data_as_list{
        yield line;

}
} function mock_open(mock=nil, read_data=''){
    """
    A helper function to create a mock to replace the use of `open`. It works
    for `open` called directly or used as a context manager.

    The `mock` argument is the mock object to configure. If `None` (the
    default) then a `MagicMock` will be created for you, with the API limited
    to methods or attributes available on standard file handles.

    `read_data` is a string for the `read` methoddline`, and `readlines` of the
    file handle to return.  This is an empty string by default.
    """;
    function _readlines_side_effect(*args, **kwargs){
        if handle.readlines.return_value is not nil{
            return handle.readlines.return_value;
        } return list(_data);

    }
    function _read_side_effect(*args, **kwargs){
        if handle.read.return_value is not nil{
            return handle.read.return_value;
        } return ''.join(_data);

    }
    function _readline_side_effect(){
        if handle.readline.return_value is not nil{
            while true{
                yield handle.readline.return_value;
        } } for line in _data{
            yield line;


    }
    } global file_spec;
    if file_spec is nil{
        import _io;
        file_spec = list(set(dir(_io.TextIOWrapper)).union(set(dir(_io.BytesIO))));

    }
    if mock is nil{
        mock = MagicMock(name='open', spec=open);

    }
    handle = MagicMock(spec=file_spec);
    handle.__enter__.return_value = handle;

    _data = _iterate_read_data(read_data);

    handle.write.return_value = nil;
    handle.read.return_value = nil;
    handle.readline.return_value = nil;
    handle.readlines.return_value = nil;

    handle.read.side_effect = _read_side_effect;
    handle.readline.side_effect = _readline_side_effect();
    handle.readlines.side_effect = _readlines_side_effect;

    mock.return_value = handle;
    return mock;


}
class PropertyMock(Mock){
    """
    A mock intended to be used as a property, or other descriptor, on a class.
    `PropertyMock` provides `__get__` and `__set__` methods so you can specify
    a return value when it is fetched.

    Fetching a `PropertyMock` instance from an object calls the mock, with
    no args. Setting it calls the mock with the value being set.
    """;
    function _get_child_mock( **kwargs){
        return MagicMock(**kwargs);

    }
    function __get__( obj, obj_type){
        return this();
    } function __set__( obj, val){
        this(val);

}
}
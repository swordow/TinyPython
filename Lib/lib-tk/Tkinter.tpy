"""Wrapper functions for Tcl/Tk.

Tkinter provides classes which allow the display, positioning and
control of widgets. Toplevel widgets are Tk and Toplevel. Other
widgets are Frame, Label, Entry, Text, Canvas, Button, Radiobutton,
Checkbutton, Scale, Listbox, Scrollbar, OptionMenu, Spinbox
LabelFrame and PanedWindow.

Properties of the widgets are specified with keyword arguments.
Keyword arguments have the same name as the corresponding resource
under Tk.

Widgets are positioned with one of the geometry managers Place, Pack
or Grid. These managers can be called with methods place, pack, grid
available in every Widget.

Actions are bound to events by resources (e.g. keyword argument
command) or with the method bind.

Example (Hello, World):
import Tkinter
from Tkconstants import *
tk = Tkinter.Tk()
frame = Tkinter.Frame(tk, relief=RIDGE, borderwidth=2)
frame.pack(fill=BOTH,expand=1)
label = Tkinter.Label(frame, text="Hello, World")
label.pack(fill=X, expand=1)
button = Tkinter.Button(frame,text="Exit",command=tk.destroy)
button.pack(side=BOTTOM)
tk.mainloop()
""";

__version__ = "$Revision: 81008 $";

import sys;
if sys.platform == "win32"{
    # Attempt to configure Tcl/Tk without requiring PATH
    import FixTk;
} import _tkinter; # If this fails your Python may not be configured for Tk
tkinter = _tkinter; # b/w compat for export
TclError = _tkinter.TclError;
from types import *;
from Tkconstants import *;
import re;

wantobjects = 1;

TkVersion = float(_tkinter.TK_VERSION);
TclVersion = float(_tkinter.TCL_VERSION);

READABLE = _tkinter.READABLE;
WRITABLE = _tkinter.WRITABLE;
EXCEPTION = _tkinter.EXCEPTION;

# These are not always defined, e.g. not on Win32 with Tk 8.0 :-(
try{ _tkinter.createfilehandler;}
except AttributeError{ _tkinter.createfilehandler = nil;}
try{ _tkinter.deletefilehandler;}
except AttributeError{ _tkinter.deletefilehandler = nil;}


_magic_re = re.compile(r'([\\{}])');
_space_re = re.compile(r'([\s])');

function _join(value){
    """Internal function.""";
    return ' '.join(map(_stringify, value));

}
function _stringify(value){
    """Internal function.""";
    if isinstance(value, (list, tuple)){
        if len(value) == 1{
            value = _stringify(value[0]);
            if _magic_re.search(value){
                value = '{%s}' % value;
        } } else{
            value = '{%s}' % _join(value);
    } } else{
        if isinstance(value, str){
            value = unicode(value, 'utf-8');
        } elif not isinstance(value, unicode){
            value = str(value);
        } if not value{
            value = '{}';
        } elif _magic_re.search(value){
            # add '\' before special characters and spaces
            value = _magic_re.sub(r'\\\1', value);
            value = value.replace('\n', r'\n');
            value = _space_re.sub(r'\\\1', value);
            if value[0] == '"'{
                value = '\\' + value;
        } } elif value[0] == '"' or _space_re.search(value){
            value = '{%s}' % value;
    } } return value;

}
function _flatten(tuple){
    """Internal function.""";
    res = ();
    for item in tuple{
        if type(item) in (TupleType, ListType){
            res = res + _flatten(item);
        } elif item is not nil{
            res = res + (item,);
    } } return res;

}
try{ _flatten = _tkinter._flatten;}
except AttributeError{ pass;}

function _cnfmerge(cnfs){
    """Internal function.""";
    if type(cnfs) is DictionaryType{
        return cnfs;
    } elif type(cnfs) in (NoneType, StringType){
        return cnfs;
    } else{
        cnf = {};
        for c in _flatten(cnfs){
            try{
                cnf.update(c);
            } except (AttributeError, TypeError), msg{
                print "_cnfmerge: fallback due to:", msg;
                for k, v in c.items(){
                    cnf[k] = v;
        } } } return cnf;

}
} try{ _cnfmerge = _tkinter._cnfmerge;}
except AttributeError{ pass;}

function _splitdict(tk, v, cut_minus=true, conv=nil){
    """Return a properly formatted dict built from Tcl list pairs.

    If cut_minus is True, the supposed '-' prefix will be removed from
    keys. If conv is specified, it is used to convert values.

    Tcl list is expected to contain an even number of elements.
    """;
    t = tk.splitlist(v);
    if len(t) % 2{
        raise RuntimeError('Tcl list representing a dict is expected '
                           'to contain an even number of elements');
    } it = iter(t);
    dict = {};
    for key, value in zip(it, it){
        key = str(key);
        if cut_minus and key[0] == '-'{
            key = key[1:];
        } if conv{
            value = conv(value);
        } dict[key] = value;
    } return dict;

}
class Event{
    """Container for the properties of an event.

    Instances of this type are generated if one of the following events occurs:

    KeyPress, KeyRelease - for keyboard events
    ButtonPress, ButtonRelease, Motion, Enter, Leave, MouseWheel - for mouse events
    Visibility, Unmap, Map, Expose, FocusIn, FocusOut, Circulate,
    Colormap, Gravity, Reparent, Property, Destroy, Activate,
    Deactivate - for window events.

    If a callback function for one of these events is registered
    using bind, bind_all, bind_class, or tag_bind, the callback is
    called with an Event as first argument. It will have the
    following attributes (in braces are the event types for which
    the attribute is valid):

        serial - serial number of event
    num - mouse button pressed (ButtonPress, ButtonRelease)
    focus - whether the window has the focus (Enter, Leave)
    height - height of the exposed window (Configure, Expose)
    width - width of the exposed window (Configure, Expose)
    keycode - keycode of the pressed key (KeyPress, KeyRelease)
    state - state of the event as a number (ButtonPress, ButtonRelease,
                            Enter, KeyPress, KeyRelease,
                            Leave, Motion)
    state - state as a string (Visibility)
    time - when the event occurred
    x - x-position of the mouse
    y - y-position of the mouse
    x_root - x-position of the mouse on the screen
             (ButtonPress, ButtonRelease, KeyPress, KeyRelease, Motion)
    y_root - y-position of the mouse on the screen
             (ButtonPress, ButtonRelease, KeyPress, KeyRelease, Motion)
    char - pressed character (KeyPress, KeyRelease)
    send_event - see X/Windows documentation
    keysym - keysym of the event as a string (KeyPress, KeyRelease)
    keysym_num - keysym of the event as a number (KeyPress, KeyRelease)
    type - type of the event as a number
    widget - widget in which the event occurred
    delta - delta of wheel movement (MouseWheel)
    """;
    pass;

}
_support_default_root = 1;
_default_root = nil;

function NoDefaultRoot(){
    """Inhibit setting of default root window.

    Call this function to inhibit that the first instance of
    Tk is used for windows without an explicit parent window.
    """;
    global _support_default_root;
    _support_default_root = 0;
    global _default_root;
    _default_root = nil;
    del _default_root;

}
function _tkerror(err){
    """Internal function.""";
    pass;

}
function _exit(code=0){
    """Internal function. Calling it will raise the exception SystemExit.""";
    try{
        code = int(code);
    } except ValueError{
        pass;
    } raise SystemExit, code;

}
_varnum = 0;
class Variable{
    """Class to define value holders for e.g. buttons.

    Subclasses StringVar, IntVar, DoubleVar, BooleanVar are specializations
    that constrain the type of the value returned from get().""";
    _default = "";
    _tclCommands = nil;
    function __init__( master=nil, value=nil, name=nil){
        """Construct a variable

        MASTER can be given as master widget.
        VALUE is an optional value (defaults to "")
        NAME is an optional Tcl name (defaults to PY_VARnum).

        If NAME matches an existing variable and VALUE is omitted
        then the existing value is retained.
        """;
        global _varnum;
        if not master{
            master = _default_root;
        } this._root = master._root();
        this._tk = master.tk;
        if name{
            this._name = name;
        } else{
            this._name = 'PY_VAR' + repr(_varnum);
            _varnum += 1;
        } if value is not nil{
            this.set(value);
        } elif not this._tk.getboolean(this._tk.call("info", "exists", this._name)){
            this.set(this._default);
    } } function __del__(){
        """Unset the variable in Tcl.""";
        if this._tk is nil{
            return;
        } if this._tk.getboolean(this._tk.call("info", "exists", this._name)){
            this._tk.globalunsetvar(this._name);
        } if this._tclCommands is not nil{
            for name in this._tclCommands{
                #print '- Tkinter: deleted command', name
                this._tk.deletecommand(name);
            } this._tclCommands = nil;
    } } function __str__(){
        """Return the name of the variable in Tcl.""";
        return this._name;
    } function set( value){
        """Set the variable to VALUE.""";
        return this._tk.globalsetvar(this._name, value);
    } function get(){
        """Return value of variable.""";
        return this._tk.globalgetvar(this._name);
    } function trace_variable( mode, callback){
        """Define a trace callback for the variable.

        MODE is one of "r", "w", "u" for read, write, undefine.
        CALLBACK must be a function which is called when
        the variable is read, written or undefined.

        Return the name of the callback.
        """;
        f = CallWrapper(callback, nil, this._root).__call__;
        cbname = repr(id(f));
        try{
            callback = callback.im_func;
        } except AttributeError{
            pass;
        } try{
            cbname = cbname + callback.__name__;
        } except AttributeError{
            pass;
        } this._tk.createcommand(cbname, f);
        if this._tclCommands is nil{
            this._tclCommands = [];
        } this._tclCommands.append(cbname);
        this._tk.call("trace", "variable", this._name, mode, cbname);
        return cbname;
    } trace = trace_variable;
    function trace_vdelete( mode, cbname){
        """Delete the trace callback for a variable.

        MODE is one of "r", "w", "u" for read, write, undefine.
        CBNAME is the name of the callback returned from trace_variable or trace.
        """;
        this._tk.call("trace", "vdelete", this._name, mode, cbname);
        cbname = this._tk.splitlist(cbname)[0];
        for m, ca in this.trace_vinfo(){
            if this._tk.splitlist(ca)[0] == cbname{
                break;
        } } else{
            this._tk.deletecommand(cbname);
            try{
                this._tclCommands.remove(cbname);
            } except ValueError{
                pass;
    } } } function trace_vinfo(){
        """Return all trace callback information.""";
        return map(this._tk.splitlist, this._tk.splitlist(
            this._tk.call("trace", "vinfo", this._name)));
    } function __eq__( other){
        """Comparison for equality (==).

        Note: if the Variable's master matters to behavior
        also compare self._master == other._master
        """;
        return this.__class__.__name__ == other.__class__.__name__ \
            and this._name == other._name;

}
} class StringVar(Variable){
    """Value holder for strings variables.""";
    _default = "";
    function __init__( master=nil, value=nil, name=nil){
        """Construct a string variable.

        MASTER can be given as master widget.
        VALUE is an optional value (defaults to "")
        NAME is an optional Tcl name (defaults to PY_VARnum).

        If NAME matches an existing variable and VALUE is omitted
        then the existing value is retained.
        """;
        Variable.__init__(this, master, value, name);

    }
    function get(){
        """Return value of variable as string.""";
        value = this._tk.globalgetvar(this._name);
        if isinstance(value, basestring){
            return value;
        } return str(value);

}
} class IntVar(Variable){
    """Value holder for integer variables.""";
    _default = 0;
    function __init__( master=nil, value=nil, name=nil){
        """Construct an integer variable.

        MASTER can be given as master widget.
        VALUE is an optional value (defaults to 0)
        NAME is an optional Tcl name (defaults to PY_VARnum).

        If NAME matches an existing variable and VALUE is omitted
        then the existing value is retained.
        """;
        Variable.__init__(this, master, value, name);

    }
    function set( value){
        """Set the variable to value, converting booleans to integers.""";
        if isinstance(value, bool){
            value = int(value);
        } return Variable.set(this, value);

    }
    function get(){
        """Return the value of the variable as an integer.""";
        return getint(this._tk.globalgetvar(this._name));

}
} class DoubleVar(Variable){
    """Value holder for float variables.""";
    _default = 0.0;
    function __init__( master=nil, value=nil, name=nil){
        """Construct a float variable.

        MASTER can be given as master widget.
        VALUE is an optional value (defaults to 0.0)
        NAME is an optional Tcl name (defaults to PY_VARnum).

        If NAME matches an existing variable and VALUE is omitted
        then the existing value is retained.
        """;
        Variable.__init__(this, master, value, name);

    }
    function get(){
        """Return the value of the variable as a float.""";
        return getdouble(this._tk.globalgetvar(this._name));

}
} class BooleanVar(Variable){
    """Value holder for boolean variables.""";
    _default = false;
    function __init__( master=nil, value=nil, name=nil){
        """Construct a boolean variable.

        MASTER can be given as master widget.
        VALUE is an optional value (defaults to False)
        NAME is an optional Tcl name (defaults to PY_VARnum).

        If NAME matches an existing variable and VALUE is omitted
        then the existing value is retained.
        """;
        Variable.__init__(this, master, value, name);

    }
    function set( value){
        """Set the variable to VALUE.""";
        return this._tk.globalsetvar(this._name, this._tk.getboolean(value));

    }
    function get(){
        """Return the value of the variable as a bool.""";
        return this._tk.getboolean(this._tk.globalgetvar(this._name));

}
} function mainloop(n=0){
    """Run the main loop of Tcl.""";
    _default_root.tk.mainloop(n);

}
getint = int;

getdouble = float;

function getboolean(s){
    """Convert true and false to integer values 1 and 0.""";
    return _default_root.tk.getboolean(s);

# Methods defined on both toplevel and interior widgets
}
class Misc{
    """Internal class.

    Base class which defines methods common for interior widgets.""";

    # XXX font command?
    _tclCommands = nil;
    function destroy(){
        """Internal function.

        Delete all Tcl commands created for
        this widget in the Tcl interpreter.""";
        if this._tclCommands is not nil{
            for name in this._tclCommands{
                #print '- Tkinter: deleted command', name
                this.tk.deletecommand(name);
            } this._tclCommands = nil;
    } } function deletecommand( name){
        """Internal function.

        Delete the Tcl command provided in NAME.""";
        #print '- Tkinter: deleted command', name
        this.tk.deletecommand(name);
        try{
            this._tclCommands.remove(name);
        } except ValueError{
            pass;
    } } function tk_strictMotif( boolean=nil){
        """Set Tcl internal variable, whether the look and feel
        should adhere to Motif.

        A parameter of 1 means adhere to Motif (e.g. no color
        change if mouse passes over slider).
        Returns the set value.""";
        return this.tk.getboolean(this.tk.call(
            'set', 'tk_strictMotif', boolean));
    } function tk_bisque(){
        """Change the color scheme to light brown as used in Tk 3.6 and before.""";
        this.tk.call('tk_bisque');
    } function tk_setPalette( *args, **kw){
        """Set a new color scheme for all widget elements.

        A single color as argument will cause that all colors of Tk
        widget elements are derived from this.
        Alternatively several keyword parameters and its associated
        colors can be given. The following keywords are valid:
        activeBackground, foreground, selectColor,
        activeForeground, highlightBackground, selectBackground,
        background, highlightColor, selectForeground,
        disabledForeground, insertBackground, troughColor.""";
        this.tk.call(('tk_setPalette',)
              + _flatten(args) + _flatten(kw.items()));
    } function tk_menuBar( *args){
        """Do not use. Needed in Tk 3.6 and earlier.""";
        # obsolete since Tk 4.0
        import warnings;
        warnings.warn('tk_menuBar() does nothing and will be removed in 3.6',
                      DeprecationWarning, stacklevel=2);
    } function wait_variable( name='PY_VAR'){
        """Wait until the variable is modified.

        A parameter of type IntVar, StringVar, DoubleVar or
        BooleanVar must be given.""";
        this.tk.call('tkwait', 'variable', name);
    } waitvar = wait_variable; # XXX b/w compat
    function wait_window( window=nil){
        """Wait until a WIDGET is destroyed.

        If no parameter is given self is used.""";
        if window is nil{
            window = this;
        } this.tk.call('tkwait', 'window', window._w);
    } function wait_visibility( window=nil){
        """Wait until the visibility of a WIDGET changes
        (e.g. it appears).

        If no parameter is given self is used.""";
        if window is nil{
            window = this;
        } this.tk.call('tkwait', 'visibility', window._w);
    } function setvar( name='PY_VAR', value='1'){
        """Set Tcl variable NAME to VALUE.""";
        this.tk.setvar(name, value);
    } function getvar( name='PY_VAR'){
        """Return value of Tcl variable NAME.""";
        return this.tk.getvar(name);
    } getint = int;
    getdouble = float;
    function getboolean( s){
        """Return a boolean value for Tcl boolean values true and false given as parameter.""";
        return this.tk.getboolean(s);
    } function focus_set(){
        """Direct input focus to this widget.

        If the application currently does not have the focus
        this widget will get the focus if the application gets
        the focus through the window manager.""";
        this.tk.call('focus', this._w);
    } focus = focus_set; # XXX b/w compat?
    function focus_force(){
        """Direct input focus to this widget even if the
        application does not have the focus. Use with
        caution!""";
        this.tk.call('focus', '-force', this._w);
    } function focus_get(){
        """Return the widget which has currently the focus in the
        application.

        Use focus_displayof to allow working with several
        displays. Return None if application does not have
        the focus.""";
        name = this.tk.call('focus');
        if name == 'none' or not name{ return nil;}
        return this._nametowidget(name);
    } function focus_displayof(){
        """Return the widget which has currently the focus on the
        display where this widget is located.

        Return None if the application does not have the focus.""";
        name = this.tk.call('focus', '-displayof', this._w);
        if name == 'none' or not name{ return nil;}
        return this._nametowidget(name);
    } function focus_lastfor(){
        """Return the widget which would have the focus if top level
        for this widget gets the focus from the window manager.""";
        name = this.tk.call('focus', '-lastfor', this._w);
        if name == 'none' or not name{ return nil;}
        return this._nametowidget(name);
    } function tk_focusFollowsMouse(){
        """The widget under mouse will get automatically focus. Can not
        be disabled easily.""";
        this.tk.call('tk_focusFollowsMouse');
    } function tk_focusNext(){
        """Return the next widget in the focus order which follows
        widget which has currently the focus.

        The focus order first goes to the next child, then to
        the children of the child recursively and then to the
        next sibling which is higher in the stacking order.  A
        widget is omitted if it has the takefocus resource set
        to 0.""";
        name = this.tk.call('tk_focusNext', this._w);
        if not name{ return nil;}
        return this._nametowidget(name);
    } function tk_focusPrev(){
        """Return previous widget in the focus order. See tk_focusNext for details.""";
        name = this.tk.call('tk_focusPrev', this._w);
        if not name{ return nil;}
        return this._nametowidget(name);
    } function after( ms, func=nil, *args){
        """Call function once after given time.

        MS specifies the time in milliseconds. FUNC gives the
        function which shall be called. Additional parameters
        are given as parameters to the function call.  Return
        identifier to cancel scheduling with after_cancel.""";
        if not func{
            # I'd rather use time.sleep(ms*0.001)
            this.tk.call('after', ms);
            return nil;
        } else{
            function callit(){
                try{
                    func(*args);
                } finally{
                    try{
                        this.deletecommand(name);
                    } except TclError{
                        pass;
            } } } callit.__name__ = func.__name__;
            name = this._register(callit);
            return this.tk.call('after', ms, name);
    } } function after_idle( func, *args){
        """Call FUNC once if the Tcl main loop has no event to
        process.

        Return an identifier to cancel the scheduling with
        after_cancel.""";
        return this.after('idle', func, *args);
    } function after_cancel( id){
        """Cancel scheduling of function identified with ID.

        Identifier returned by after or after_idle must be
        given as first parameter.
        """;
        if not id{
            raise ValueError('id must be a valid identifier returned from '
                             'after or after_idle');
        } try{
            data = this.tk.call('after', 'info', id);
            script = this.tk.splitlist(data)[0];
            this.deletecommand(script);
        } except TclError{
            pass;
        } this.tk.call('after', 'cancel', id);
    } function bell( displayof=0){
        """Ring a display's bell.""";
        this.tk.call(('bell',) + this._displayof(displayof));

    # Clipboard handling:
    }
    function clipboard_get( **kw){
        """Retrieve data from the clipboard on window's display.

        The window keyword defaults to the root window of the Tkinter
        application.

        The type keyword specifies the form in which the data is
        to be returned and should be an atom name such as STRING
        or FILE_NAME.  Type defaults to STRING, except on X11, where the default
        is to try UTF8_STRING and fall back to STRING.

        This command is equivalent to:

        selection_get(CLIPBOARD)
        """;
        if 'type' not in kw and this._windowingsystem == 'x11'{
            try{
                kw['type'] = 'UTF8_STRING';
                return this.tk.call(('clipboard', 'get') + this._options(kw));
            } except TclError{
                del kw['type'];
        } } return this.tk.call(('clipboard', 'get') + this._options(kw));

    }
    function clipboard_clear( **kw){
        """Clear the data in the Tk clipboard.

        A widget specified for the optional displayof keyword
        argument specifies the target display.""";
        if 'displayof' not in kw{ kw['displayof'] = this._w;}
        this.tk.call(('clipboard', 'clear') + this._options(kw));
    } function clipboard_append( string, **kw){
        """Append STRING to the Tk clipboard.

        A widget specified at the optional displayof keyword
        argument specifies the target display. The clipboard
        can be retrieved with selection_get.""";
        if 'displayof' not in kw{ kw['displayof'] = this._w;}
        this.tk.call(('clipboard', 'append') + this._options(kw)
              + ('--', string));
    # XXX grab current w/o window argument
    }
    function grab_current(){
        """Return widget which has currently the grab in this application
        or None.""";
        name = this.tk.call('grab', 'current', this._w);
        if not name{ return nil;}
        return this._nametowidget(name);
    } function grab_release(){
        """Release grab for this widget if currently set.""";
        this.tk.call('grab', 'release', this._w);
    } function grab_set(){
        """Set grab for this widget.

        A grab directs all events to this and descendant
        widgets in the application.""";
        this.tk.call('grab', 'set', this._w);
    } function grab_set_global(){
        """Set global grab for this widget.

        A global grab directs all events to this and
        descendant widgets on the display. Use with caution -
        other applications do not get events anymore.""";
        this.tk.call('grab', 'set', '-global', this._w);
    } function grab_status(){
        """Return None, "local" or "global" if this widget has
        no, a local or a global grab.""";
        status = this.tk.call('grab', 'status', this._w);
        if status == 'none'{ status = nil;}
        return status;
    } function option_add( pattern, value, priority = nil){
        """Set a VALUE (second parameter) for an option
        PATTERN (first parameter).

        An optional third parameter gives the numeric priority
        (defaults to 80).""";
        this.tk.call('option', 'add', pattern, value, priority);
    } function option_clear(){
        """Clear the option database.

        It will be reloaded if option_add is called.""";
        this.tk.call('option', 'clear');
    } function option_get( name, className){
        """Return the value for an option NAME for this widget
        with CLASSNAME.

        Values with higher priority override lower values.""";
        return this.tk.call('option', 'get', this._w, name, className);
    } function option_readfile( fileName, priority = nil){
        """Read file FILENAME into the option database.

        An optional second parameter gives the numeric
        priority.""";
        this.tk.call('option', 'readfile', fileName, priority);
    } function selection_clear( **kw){
        """Clear the current X selection.""";
        if 'displayof' not in kw{ kw['displayof'] = this._w;}
        this.tk.call(('selection', 'clear') + this._options(kw));
    } function selection_get( **kw){
        """Return the contents of the current X selection.

        A keyword parameter selection specifies the name of
        the selection and defaults to PRIMARY.  A keyword
        parameter displayof specifies a widget on the display
        to use. A keyword parameter type specifies the form of data to be
        fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
        before STRING.""";
        if 'displayof' not in kw{ kw['displayof'] = this._w;}
        if 'type' not in kw and this._windowingsystem == 'x11'{
            try{
                kw['type'] = 'UTF8_STRING';
                return this.tk.call(('selection', 'get') + this._options(kw));
            } except TclError{
                del kw['type'];
        } } return this.tk.call(('selection', 'get') + this._options(kw));
    } function selection_handle( command, **kw){
        """Specify a function COMMAND to call if the X
        selection owned by this widget is queried by another
        application.

        This function must return the contents of the
        selection. The function will be called with the
        arguments OFFSET and LENGTH which allows the chunking
        of very long selections. The following keyword
        parameters can be provided:
        selection - name of the selection (default PRIMARY),
        type - type of the selection (e.g. STRING, FILE_NAME).""";
        name = this._register(command);
        this.tk.call(('selection', 'handle') + this._options(kw)
              + (this._w, name));
    } function selection_own( **kw){
        """Become owner of X selection.

        A keyword parameter selection specifies the name of
        the selection (default PRIMARY).""";
        this.tk.call(('selection', 'own') +
                 this._options(kw) + (this._w,));
    } function selection_own_get( **kw){
        """Return owner of X selection.

        The following keyword parameter can
        be provided:
        selection - name of the selection (default PRIMARY),
        type - type of the selection (e.g. STRING, FILE_NAME).""";
        if 'displayof' not in kw{ kw['displayof'] = this._w;}
        name = this.tk.call(('selection', 'own') + this._options(kw));
        if not name{ return nil;}
        return this._nametowidget(name);
    } function send( interp, cmd, *args){
        """Send Tcl command CMD to different interpreter INTERP to be executed.""";
        return this.tk.call(('send', interp, cmd) + args);
    } function lower( belowThis=nil){
        """Lower this widget in the stacking order.""";
        this.tk.call('lower', this._w, belowThis);
    } function tkraise( aboveThis=nil){
        """Raise this widget in the stacking order.""";
        this.tk.call('raise', this._w, aboveThis);
    } lift = tkraise;
    function colormodel( value=nil){
        """Useless. Not implemented in Tk.""";
        return this.tk.call('tk', 'colormodel', this._w, value);
    } function winfo_atom( name, displayof=0){
        """Return integer which represents atom NAME.""";
        args = ('winfo', 'atom') + this._displayof(displayof) + (name,);
        return getint(this.tk.call(args));
    } function winfo_atomname( id, displayof=0){
        """Return name of atom with identifier ID.""";
        args = ('winfo', 'atomname') \
               + this._displayof(displayof) + (id,);
        return this.tk.call(args);
    } function winfo_cells(){
        """Return number of cells in the colormap for this widget.""";
        return getint(
            this.tk.call('winfo', 'cells', this._w));
    } function winfo_children(){
        """Return a list of all widgets which are children of this widget.""";
        result = [];
        for child in this.tk.splitlist(
            this.tk.call('winfo', 'children', this._w)){
            try{
                # Tcl sometimes returns extra windows, e.g. for
                # menus; those need to be skipped
                result.append(this._nametowidget(child));
            } except KeyError{
                pass;
        } } return result;

    }
    function winfo_class(){
        """Return window class name of this widget.""";
        return this.tk.call('winfo', 'class', this._w);
    } function winfo_colormapfull(){
        """Return true if at the last color request the colormap was full.""";
        return this.tk.getboolean(
            this.tk.call('winfo', 'colormapfull', this._w));
    } function winfo_containing( rootX, rootY, displayof=0){
        """Return the widget which is at the root coordinates ROOTX, ROOTY.""";
        args = ('winfo', 'containing') \
               + this._displayof(displayof) + (rootX, rootY);
        name = this.tk.call(args);
        if not name{ return nil;}
        return this._nametowidget(name);
    } function winfo_depth(){
        """Return the number of bits per pixel.""";
        return getint(this.tk.call('winfo', 'depth', this._w));
    } function winfo_exists(){
        """Return true if this widget exists.""";
        return getint(
            this.tk.call('winfo', 'exists', this._w));
    } function winfo_fpixels( number){
        """Return the number of pixels for the given distance NUMBER
        (e.g. "3c") as float.""";
        return getdouble(this.tk.call(
            'winfo', 'fpixels', this._w, number));
    } function winfo_geometry(){
        """Return geometry string for this widget in the form "widthxheight+X+Y".""";
        return this.tk.call('winfo', 'geometry', this._w);
    } function winfo_height(){
        """Return height of this widget.""";
        return getint(
            this.tk.call('winfo', 'height', this._w));
    } function winfo_id(){
        """Return identifier ID for this widget.""";
        return int(this.tk.call('winfo', 'id', this._w), 0);
    } function winfo_interps( displayof=0){
        """Return the name of all Tcl interpreters for this display.""";
        args = ('winfo', 'interps') + this._displayof(displayof);
        return this.tk.splitlist(this.tk.call(args));
    } function winfo_ismapped(){
        """Return true if this widget is mapped.""";
        return getint(
            this.tk.call('winfo', 'ismapped', this._w));
    } function winfo_manager(){
        """Return the window manager name for this widget.""";
        return this.tk.call('winfo', 'manager', this._w);
    } function winfo_name(){
        """Return the name of this widget.""";
        return this.tk.call('winfo', 'name', this._w);
    } function winfo_parent(){
        """Return the name of the parent of this widget.""";
        return this.tk.call('winfo', 'parent', this._w);
    } function winfo_pathname( id, displayof=0){
        """Return the pathname of the widget given by ID.""";
        args = ('winfo', 'pathname') \
               + this._displayof(displayof) + (id,);
        return this.tk.call(args);
    } function winfo_pixels( number){
        """Rounded integer value of winfo_fpixels.""";
        return getint(
            this.tk.call('winfo', 'pixels', this._w, number));
    } function winfo_pointerx(){
        """Return the x coordinate of the pointer on the root window.""";
        return getint(
            this.tk.call('winfo', 'pointerx', this._w));
    } function winfo_pointerxy(){
        """Return a tuple of x and y coordinates of the pointer on the root window.""";
        return this._getints(
            this.tk.call('winfo', 'pointerxy', this._w));
    } function winfo_pointery(){
        """Return the y coordinate of the pointer on the root window.""";
        return getint(
            this.tk.call('winfo', 'pointery', this._w));
    } function winfo_reqheight(){
        """Return requested height of this widget.""";
        return getint(
            this.tk.call('winfo', 'reqheight', this._w));
    } function winfo_reqwidth(){
        """Return requested width of this widget.""";
        return getint(
            this.tk.call('winfo', 'reqwidth', this._w));
    } function winfo_rgb( color){
        """Return tuple of decimal values for red, green, blue for
        COLOR in this widget.""";
        return this._getints(
            this.tk.call('winfo', 'rgb', this._w, color));
    } function winfo_rootx(){
        """Return x coordinate of upper left corner of this widget on the
        root window.""";
        return getint(
            this.tk.call('winfo', 'rootx', this._w));
    } function winfo_rooty(){
        """Return y coordinate of upper left corner of this widget on the
        root window.""";
        return getint(
            this.tk.call('winfo', 'rooty', this._w));
    } function winfo_screen(){
        """Return the screen name of this widget.""";
        return this.tk.call('winfo', 'screen', this._w);
    } function winfo_screencells(){
        """Return the number of the cells in the colormap of the screen
        of this widget.""";
        return getint(
            this.tk.call('winfo', 'screencells', this._w));
    } function winfo_screendepth(){
        """Return the number of bits per pixel of the root window of the
        screen of this widget.""";
        return getint(
            this.tk.call('winfo', 'screendepth', this._w));
    } function winfo_screenheight(){
        """Return the number of pixels of the height of the screen of this widget
        in pixel.""";
        return getint(
            this.tk.call('winfo', 'screenheight', this._w));
    } function winfo_screenmmheight(){
        """Return the number of pixels of the height of the screen of
        this widget in mm.""";
        return getint(
            this.tk.call('winfo', 'screenmmheight', this._w));
    } function winfo_screenmmwidth(){
        """Return the number of pixels of the width of the screen of
        this widget in mm.""";
        return getint(
            this.tk.call('winfo', 'screenmmwidth', this._w));
    } function winfo_screenvisual(){
        """Return one of the strings directcolor, grayscale, pseudocolor,
        staticcolor, staticgray, or truecolor for the default
        colormodel of this screen.""";
        return this.tk.call('winfo', 'screenvisual', this._w);
    } function winfo_screenwidth(){
        """Return the number of pixels of the width of the screen of
        this widget in pixel.""";
        return getint(
            this.tk.call('winfo', 'screenwidth', this._w));
    } function winfo_server(){
        """Return information of the X-Server of the screen of this widget in
        the form "XmajorRminor vendor vendorVersion".""";
        return this.tk.call('winfo', 'server', this._w);
    } function winfo_toplevel(){
        """Return the toplevel widget of this widget.""";
        return this._nametowidget(this.tk.call(
            'winfo', 'toplevel', this._w));
    } function winfo_viewable(){
        """Return true if the widget and all its higher ancestors are mapped.""";
        return getint(
            this.tk.call('winfo', 'viewable', this._w));
    } function winfo_visual(){
        """Return one of the strings directcolor, grayscale, pseudocolor,
        staticcolor, staticgray, or truecolor for the
        colormodel of this widget.""";
        return this.tk.call('winfo', 'visual', this._w);
    } function winfo_visualid(){
        """Return the X identifier for the visual for this widget.""";
        return this.tk.call('winfo', 'visualid', this._w);
    } function winfo_visualsavailable( includeids=0){
        """Return a list of all visuals available for the screen
        of this widget.

        Each item in the list consists of a visual name (see winfo_visual), a
        depth and if INCLUDEIDS=1 is given also the X identifier.""";
        data = this.tk.split(
            this.tk.call('winfo', 'visualsavailable', this._w,
                     includeids and 'includeids' or nil));
        if type(data) is StringType{
            data = [this.tk.split(data)];
        } return map(this.__winfo_parseitem, data);
    } function __winfo_parseitem( t){
        """Internal function.""";
        return t[:1] + tuple(map(this.__winfo_getint, t[1:]));
    } function __winfo_getint( x){
        """Internal function.""";
        return int(x, 0);
    } function winfo_vrootheight(){
        """Return the height of the virtual root window associated with this
        widget in pixels. If there is no virtual root window return the
        height of the screen.""";
        return getint(
            this.tk.call('winfo', 'vrootheight', this._w));
    } function winfo_vrootwidth(){
        """Return the width of the virtual root window associated with this
        widget in pixel. If there is no virtual root window return the
        width of the screen.""";
        return getint(
            this.tk.call('winfo', 'vrootwidth', this._w));
    } function winfo_vrootx(){
        """Return the x offset of the virtual root relative to the root
        window of the screen of this widget.""";
        return getint(
            this.tk.call('winfo', 'vrootx', this._w));
    } function winfo_vrooty(){
        """Return the y offset of the virtual root relative to the root
        window of the screen of this widget.""";
        return getint(
            this.tk.call('winfo', 'vrooty', this._w));
    } function winfo_width(){
        """Return the width of this widget.""";
        return getint(
            this.tk.call('winfo', 'width', this._w));
    } function winfo_x(){
        """Return the x coordinate of the upper left corner of this widget
        in the parent.""";
        return getint(
            this.tk.call('winfo', 'x', this._w));
    } function winfo_y(){
        """Return the y coordinate of the upper left corner of this widget
        in the parent.""";
        return getint(
            this.tk.call('winfo', 'y', this._w));
    } function update(){
        """Enter event loop until all pending events have been processed by Tcl.""";
        this.tk.call('update');
    } function update_idletasks(){
        """Enter event loop until all idle callbacks have been called. This
        will update the display of windows but not process events caused by
        the user.""";
        this.tk.call('update', 'idletasks');
    } function bindtags( tagList=nil){
        """Set or get the list of bindtags for this widget.

        With no argument return the list of all bindtags associated with
        this widget. With a list of strings as argument the bindtags are
        set to this list. The bindtags determine in which order events are
        processed (see bind).""";
        if tagList is nil{
            return this.tk.splitlist(
                this.tk.call('bindtags', this._w));
        } else{
            this.tk.call('bindtags', this._w, tagList);
    } } function _bind( what, sequence, func, add, needcleanup=1){
        """Internal function.""";
        if type(func) is StringType{
            this.tk.call(what + (sequence, func));
        } elif func{
            funcid = this._register(func, this._substitute,
                        needcleanup);
            cmd = ('%sif {"[%s %s]" == "break"} break\n'
                   %
                   (add and '+' or '',
                funcid, this._subst_format_str));
            this.tk.call(what + (sequence, cmd));
            return funcid;
        } elif sequence{
            return this.tk.call(what + (sequence,));
        } else{
            return this.tk.splitlist(this.tk.call(what));
    } } function bind( sequence=nil, func=nil, add=nil){
        """Bind to this widget at event SEQUENCE a call to function FUNC.

        SEQUENCE is a string of concatenated event
        patterns. An event pattern is of the form
        <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
        of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
        Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
        B3, Alt, Button4, B4, Double, Button5, B5 Triple,
        Mod1, M1. TYPE is one of Activate, Enter, Map,
        ButtonPress, Button, Expose, Motion, ButtonRelease
        FocusIn, MouseWheel, Circulate, FocusOut, Property,
        Colormap, Gravity Reparent, Configure, KeyPress, Key,
        Unmap, Deactivate, KeyRelease Visibility, Destroy,
        Leave and DETAIL is the button number for ButtonPress,
        ButtonRelease and DETAIL is the Keysym for KeyPress and
        KeyRelease. Examples are
        <Control-Button-1> for pressing Control and mouse button 1 or
        <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
        An event pattern can also be a virtual event of the form
        <<AString>> where AString can be arbitrary. This
        event can be generated by event_generate.
        If events are concatenated they must appear shortly
        after each other.

        FUNC will be called if the event sequence occurs with an
        instance of Event as argument. If the return value of FUNC is
        "break" no further bound function is invoked.

        An additional boolean parameter ADD specifies whether FUNC will
        be called additionally to the other bound function or whether
        it will replace the previous function.

        Bind will return an identifier to allow deletion of the bound function with
        unbind without memory leak.

        If FUNC or SEQUENCE is omitted the bound function or list
        of bound events are returned.""";

        return this._bind(('bind', this._w), sequence, func, add);
    } function unbind( sequence, funcid=nil){
        """Unbind for this widget for event SEQUENCE  the
        function identified with FUNCID.""";
        this.tk.call('bind', this._w, sequence, '');
        if funcid{
            this.deletecommand(funcid);
    } } function bind_all( sequence=nil, func=nil, add=nil){
        """Bind to all widgets at an event SEQUENCE a call to function FUNC.
        An additional boolean parameter ADD specifies whether FUNC will
        be called additionally to the other bound function or whether
        it will replace the previous function. See bind for the return value.""";
        return this._bind(('bind', 'all'), sequence, func, add, 0);
    } function unbind_all( sequence){
        """Unbind for all widgets for event SEQUENCE all functions.""";
        this.tk.call('bind', 'all' , sequence, '');
    } function bind_class( className, sequence=nil, func=nil, add=nil){

        """Bind to widgets with bindtag CLASSNAME at event
        SEQUENCE a call of function FUNC. An additional
        boolean parameter ADD specifies whether FUNC will be
        called additionally to the other bound function or
        whether it will replace the previous function. See bind for
        the return value.""";

        return this._bind(('bind', className), sequence, func, add, 0);
    } function unbind_class( className, sequence){
        """Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
        all functions.""";
        this.tk.call('bind', className , sequence, '');
    } function mainloop( n=0){
        """Call the mainloop of Tk.""";
        this.tk.mainloop(n);
    } function quit(){
        """Quit the Tcl interpreter. All widgets will be destroyed.""";
        this.tk.quit();
    } function _getints( string){
        """Internal function.""";
        if string{
            return tuple(map(getint, this.tk.splitlist(string)));
    } } function _getdoubles( string){
        """Internal function.""";
        if string{
            return tuple(map(getdouble, this.tk.splitlist(string)));
    } } function _getboolean( string){
        """Internal function.""";
        if string{
            return this.tk.getboolean(string);
    } } function _displayof( displayof){
        """Internal function.""";
        if displayof{
            return ('-displayof', displayof);
        } if displayof is nil{
            return ('-displayof', this._w);
        } return ();
    } @property;
    function _windowingsystem(){
        """Internal function.""";
        try{
            return this._root()._windowingsystem_cached;
        } except AttributeError{
            ws = this._root()._windowingsystem_cached = \
                        this.tk.call('tk', 'windowingsystem');
            return ws;
    } } function _options( cnf, kw = nil){
        """Internal function.""";
        if kw{
            cnf = _cnfmerge((cnf, kw));
        } else{
            cnf = _cnfmerge(cnf);
        } res = ();
        for k, v in cnf.items(){
            if v is not nil{
                if k[-1] == '_'{ k = k[:-1];}
                if hasattr(v, '__call__'){
                    v = this._register(v);
                } elif isinstance(v, (tuple, list)){
                    nv = [];
                    for item in v{
                        if not isinstance(item, (basestring, int, long)){
                            break;
                        } elif isinstance(item, (int, long)){
                            nv.append('%d' % item);
                        } else{
                            # format it to proper Tcl code if it contains space
                            nv.append(_stringify(item));
                    } } else{
                        v = ' '.join(nv);
                } } res = res + ('-'+k, v);
        } } return res;
    } function nametowidget( name){
        """Return the Tkinter instance of a widget identified by
        its Tcl name NAME.""";
        name = str(name).split('.');
        w = this;

        if not name[0]{
            w = w._root();
            name = name[1:];

        }
        for n in name{
            if not n{
                break;
            } w = w.children[n];

        }
        return w;
    } _nametowidget = nametowidget;
    function _register( func, subst=nil, needcleanup=1){
        """Return a newly created Tcl function. If this
        function is called, the Python function FUNC will
        be executed. An optional function SUBST can
        be given which will be executed before FUNC.""";
        f = CallWrapper(func, subst, this).__call__;
        name = repr(id(f));
        try{
            func = func.im_func;
        } except AttributeError{
            pass;
        } try{
            name = name + func.__name__;
        } except AttributeError{
            pass;
        } this.tk.createcommand(name, f);
        if needcleanup{
            if this._tclCommands is nil{
                this._tclCommands = [];
            } this._tclCommands.append(name);
        } return name;
    } register = _register;
    function _root(){
        """Internal function.""";
        w = this;
        while w.master{ w = w.master;}
        return w;
    } _subst_format = ('%#', '%b', '%f', '%h', '%k',
             '%s', '%t', '%w', '%x', '%y',
             '%A', '%E', '%K', '%N', '%W', '%T', '%X', '%Y', '%D');
    _subst_format_str = " ".join(_subst_format);
    function _substitute( *args){
        """Internal function.""";
        if len(args) != len(this._subst_format){ return args;}
        getboolean = this.tk.getboolean;

        getint = int;
        function getint_event(s){
            """Tk changed behavior in 8.4.2, returning "??" rather more often.""";
            try{
                return int(s);
            } except ValueError{
                return s;

        }
        } nsign, b, f, h, k, s, t, w, x, y, A, E, K, N, W, T, X, Y, D = args;
        # Missing: (a, c, d, m, o, v, B, R)
        e = Event();
        # serial field: valid for all events
        # number of button: ButtonPress and ButtonRelease events only
        # height field: Configure, ConfigureRequest, Create,
        # ResizeRequest, and Expose events only
        # keycode field: KeyPress and KeyRelease events only
        # time field: "valid for events that contain a time field"
        # width field: Configure, ConfigureRequest, Create, ResizeRequest,
        # and Expose events only
        # x field: "valid for events that contain an x field"
        # y field: "valid for events that contain a y field"
        # keysym as decimal: KeyPress and KeyRelease events only
        # x_root, y_root fields: ButtonPress, ButtonRelease, KeyPress,
        # KeyRelease, and Motion events
        e.serial = getint(nsign);
        e.num = getint_event(b);
        try{ e.focus = getboolean(f);}
        except TclError{ pass;}
        e.height = getint_event(h);
        e.keycode = getint_event(k);
        e.state = getint_event(s);
        e.time = getint_event(t);
        e.width = getint_event(w);
        e.x = getint_event(x);
        e.y = getint_event(y);
        e.char = A;
        try{ e.send_event = getboolean(E);}
        except TclError{ pass;}
        e.keysym = K;
        e.keysym_num = getint_event(N);
        e.type = T;
        try{
            e.widget = this._nametowidget(W);
        } except KeyError{
            e.widget = W;
        } e.x_root = getint_event(X);
        e.y_root = getint_event(Y);
        try{
            e.delta = getint(D);
        } except ValueError{
            e.delta = 0;
        } return (e,);
    } function _report_exception(){
        """Internal function.""";
        import sys;
        exc, val, tb = sys.exc_type, sys.exc_value, sys.exc_traceback;
        root = this._root();
        root.report_callback_exception(exc, val, tb);

    }
    function _getconfigure( *args){
        """Call Tcl configure command and return the result as a dict.""";
        cnf = {};
        for x in this.tk.splitlist(this.tk.call(*args)){
            x = this.tk.splitlist(x);
            cnf[x[0][1:]] = (x[0][1:],) + x[1:];
        } return cnf;

    }
    function _getconfigure1( *args){
        x = this.tk.splitlist(this.tk.call(*args));
        return (x[0][1:],) + x[1:];

    }
    function _configure( cmd, cnf, kw){
        """Internal function.""";
        if kw{
            cnf = _cnfmerge((cnf, kw));
        } elif cnf{
            cnf = _cnfmerge(cnf);
        } if cnf is nil{
            return this._getconfigure(_flatten((this._w, cmd)));
        } if type(cnf) is StringType{
            return this._getconfigure1(_flatten((this._w, cmd, '-'+cnf)));
        } this.tk.call(_flatten((this._w, cmd)) + this._options(cnf));
    # These used to be defined in Widget:
    }
    function configure( cnf=nil, **kw){
        """Configure resources of a widget.

        The values for resources are specified as keyword
        arguments. To get an overview about
        the allowed keyword arguments call the method keys.
        """;
        return this._configure('configure', cnf, kw);
    } config = configure;
    function cget( key){
        """Return the resource value for a KEY given as string.""";
        return this.tk.call(this._w, 'cget', '-' + key);
    } __getitem__ = cget;
    function __setitem__( key, value){
        this.configure({key: value});
    } function __contains__( key){
        raise TypeError("Tkinter objects don't support 'in' tests.");
    } function keys(){
        """Return a list of all resource names of this widget.""";
        splitlist = this.tk.splitlist;
        return [splitlist(x)[0][1:] for x in
                splitlist(this.tk.call(this._w, 'configure'))];
    } function __str__(){
        """Return the window path name of this widget.""";
        return this._w;
    # Pack methods that apply to the master
    }
    _noarg_ = ['_noarg_'];
    function pack_propagate( flag=_noarg_){
        """Set or get the status for propagation of geometry information.

        A boolean argument specifies whether the geometry information
        of the slaves will determine the size of this widget. If no argument
        is given the current setting will be returned.
        """;
        if flag is Misc._noarg_{
            return this._getboolean(this.tk.call(
                'pack', 'propagate', this._w));
        } else{
            this.tk.call('pack', 'propagate', this._w, flag);
    } } propagate = pack_propagate;
    function pack_slaves(){
        """Return a list of all slaves of this widget
        in its packing order.""";
        return map(this._nametowidget,
               this.tk.splitlist(
                   this.tk.call('pack', 'slaves', this._w)));
    } slaves = pack_slaves;
    # Place method that applies to the master
    function place_slaves(){
        """Return a list of all slaves of this widget
        in its packing order.""";
        return map(this._nametowidget,
               this.tk.splitlist(
                   this.tk.call(
                       'place', 'slaves', this._w)));
    # Grid methods that apply to the master
    }
    function grid_bbox( column=nil, row=nil, col2=nil, row2=nil){
        """Return a tuple of integer coordinates for the bounding
        box of this widget controlled by the geometry manager grid.

        If COLUMN, ROW is given the bounding box applies from
        the cell with row and column 0 to the specified
        cell. If COL2 and ROW2 are given the bounding box
        starts at that cell.

        The returned integers specify the offset of the upper left
        corner in the master widget and the width and height.
        """;
        args = ('grid', 'bbox', this._w);
        if column is not nil and row is not nil{
            args = args + (column, row);
        } if col2 is not nil and row2 is not nil{
            args = args + (col2, row2);
        } return this._getints(this.tk.call(*args)) or nil;

    }
    bbox = grid_bbox;

    function _gridconvvalue( value){
        if isinstance(value, (str, _tkinter.Tcl_Obj)){
            try{
                svalue = str(value);
                if not svalue{
                    return nil;
                } elif '.' in svalue{
                    return getdouble(svalue);
                } else{
                    return getint(svalue);
            } } except ValueError{
                pass;
        } } return value;

    }
    function _grid_configure( command, index, cnf, kw){
        """Internal function.""";
        if type(cnf) is StringType and not kw{
            if cnf[-1:] == '_'{
                cnf = cnf[:-1];
            } if cnf[:1] != '-'{
                cnf = '-'+cnf;
            } options = (cnf,);
        } else{
            options = this._options(cnf, kw);
        } if not options{
            return _splitdict(
                this.tk,
                this.tk.call('grid', command, this._w, index),
                conv=this._gridconvvalue);
        } res = this.tk.call(
                  ('grid', command, this._w, index)
                  + options);
        if len(options) == 1{
            return this._gridconvvalue(res);

    }
    } function grid_columnconfigure( index, cnf={}, **kw){
        """Configure column INDEX of a grid.

        Valid resources are minsize (minimum size of the column),
        weight (how much does additional space propagate to this column)
        and pad (how much space to let additionally).""";
        return this._grid_configure('columnconfigure', index, cnf, kw);
    } columnconfigure = grid_columnconfigure;
    function grid_location( x, y){
        """Return a tuple of column and row which identify the cell
        at which the pixel at position X and Y inside the master
        widget is located.""";
        return this._getints(
            this.tk.call(
                'grid', 'location', this._w, x, y)) or nil;
    } function grid_propagate( flag=_noarg_){
        """Set or get the status for propagation of geometry information.

        A boolean argument specifies whether the geometry information
        of the slaves will determine the size of this widget. If no argument
        is given, the current setting will be returned.
        """;
        if flag is Misc._noarg_{
            return this._getboolean(this.tk.call(
                'grid', 'propagate', this._w));
        } else{
            this.tk.call('grid', 'propagate', this._w, flag);
    } } function grid_rowconfigure( index, cnf={}, **kw){
        """Configure row INDEX of a grid.

        Valid resources are minsize (minimum size of the row),
        weight (how much does additional space propagate to this row)
        and pad (how much space to let additionally).""";
        return this._grid_configure('rowconfigure', index, cnf, kw);
    } rowconfigure = grid_rowconfigure;
    function grid_size(){
        """Return a tuple of the number of column and rows in the grid.""";
        return this._getints(
            this.tk.call('grid', 'size', this._w)) or nil;
    } size = grid_size;
    function grid_slaves( row=nil, column=nil){
        """Return a list of all slaves of this widget
        in its packing order.""";
        args = ();
        if row is not nil{
            args = args + ('-row', row);
        } if column is not nil{
            args = args + ('-column', column);
        } return map(this._nametowidget,
               this.tk.splitlist(this.tk.call(
                   ('grid', 'slaves', this._w) + args)));

    # Support for the "event" command, new in Tk 4.2.
    # By Case Roole.

    }
    function event_add( virtual, *sequences){
        """Bind a virtual event VIRTUAL (of the form <<Name>>)
        to an event SEQUENCE such that the virtual event is triggered
        whenever SEQUENCE occurs.""";
        args = ('event', 'add', virtual) + sequences;
        this.tk.call(args);

    }
    function event_delete( virtual, *sequences){
        """Unbind a virtual event VIRTUAL from SEQUENCE.""";
        args = ('event', 'delete', virtual) + sequences;
        this.tk.call(args);

    }
    function event_generate( sequence, **kw){
        """Generate an event SEQUENCE. Additional
        keyword arguments specify parameter of the event
        (e.g. x, y, rootx, rooty).""";
        args = ('event', 'generate', this._w, sequence);
        for k, v in kw.items(){
            args = args + ('-%s' % k, str(v));
        } this.tk.call(args);

    }
    function event_info( virtual=nil){
        """Return a list of all virtual events or the information
        about the SEQUENCE bound to the virtual event VIRTUAL.""";
        return this.tk.splitlist(
            this.tk.call('event', 'info', virtual));

    # Image related commands

    }
    function image_names(){
        """Return a list of all existing image names.""";
        return this.tk.splitlist(this.tk.call('image', 'names'));

    }
    function image_types(){
        """Return a list of all available image types (e.g. photo bitmap).""";
        return this.tk.splitlist(this.tk.call('image', 'types'));


}
} class CallWrapper{
    """Internal class. Stores function to call when some user
    defined Tcl function is called e.g. after an event occurred.""";
    function __init__( func, subst, widget){
        """Store FUNC, SUBST and WIDGET as members.""";
        this.func = func;
        this.subst = subst;
        this.widget = widget;
    } function __call__( *args){
        """Apply first function SUBST to arguments, than FUNC.""";
        try{
            if this.subst{
                args = this.subst(*args);
            } return this.func(*args);
        } except SystemExit, msg{
            raise SystemExit, msg;
        } except Exception{
            this.widget._report_exception();


}
} } class XView{
    """Mix-in class for querying and changing the horizontal position
    of a widget's window.""";

    function xview( *args){
        """Query and change the horizontal position of the view.""";
        res = this.tk.call(this._w, 'xview', *args);
        if not args{
            return this._getdoubles(res);

    }
    } function xview_moveto( fraction){
        """Adjusts the view in the window so that FRACTION of the
        total width of the canvas is off-screen to the left.""";
        this.tk.call(this._w, 'xview', 'moveto', fraction);

    }
    function xview_scroll( number, what){
        """Shift the x-view according to NUMBER which is measured in "units"
        or "pages" (WHAT).""";
        this.tk.call(this._w, 'xview', 'scroll', number, what);


}
} class YView{
    """Mix-in class for querying and changing the vertical position
    of a widget's window.""";

    function yview( *args){
        """Query and change the vertical position of the view.""";
        res = this.tk.call(this._w, 'yview', *args);
        if not args{
            return this._getdoubles(res);

    }
    } function yview_moveto( fraction){
        """Adjusts the view in the window so that FRACTION of the
        total height of the canvas is off-screen to the top.""";
        this.tk.call(this._w, 'yview', 'moveto', fraction);

    }
    function yview_scroll( number, what){
        """Shift the y-view according to NUMBER which is measured in
        "units" or "pages" (WHAT).""";
        this.tk.call(this._w, 'yview', 'scroll', number, what);


}
} class Wm{
    """Provides functions for the communication with the window manager.""";

    function wm_aspect(
              minNumer=nil, minDenom=nil,
              maxNumer=nil, maxDenom=nil){
        """Instruct the window manager to set the aspect ratio (width/height)
        of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
        of the actual values if no argument is given.""";
        return this._getints(
            this.tk.call('wm', 'aspect', this._w,
                     minNumer, minDenom,
                     maxNumer, maxDenom));
    } aspect = wm_aspect;

    function wm_attributes( *args){
        """This subcommand returns or sets platform specific attributes

        The first form returns a list of the platform specific flags and
        their values. The second form returns the value for the specific
        option. The third form sets one or more of the values. The values
        are as follows:

        On Windows, -disabled gets or sets whether the window is in a
        disabled state. -toolwindow gets or sets the style of the window
        to toolwindow (as defined in the MSDN). -topmost gets or sets
        whether this is a topmost window (displays above all other
        windows).

        On Macintosh, XXXXX

        On Unix, there are currently no special attribute values.
        """;
        args = ('wm', 'attributes', this._w) + args;
        return this.tk.call(args);
    } attributes=wm_attributes;

    function wm_client( name=nil){
        """Store NAME in WM_CLIENT_MACHINE property of this widget. Return
        current value.""";
        return this.tk.call('wm', 'client', this._w, name);
    } client = wm_client;
    function wm_colormapwindows( *wlist){
        """Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
        of this widget. This list contains windows whose colormaps differ from their
        parents. Return current list of widgets if WLIST is empty.""";
        if len(wlist) > 1{
            wlist = (wlist,); # Tk needs a list of windows here
        } args = ('wm', 'colormapwindows', this._w) + wlist;
        if wlist{
            this.tk.call(args);
        } else{
            return map(this._nametowidget, this.tk.splitlist(this.tk.call(args)));
    } } colormapwindows = wm_colormapwindows;
    function wm_command( value=nil){
        """Store VALUE in WM_COMMAND property. It is the command
        which shall be used to invoke the application. Return current
        command if VALUE is None.""";
        return this.tk.call('wm', 'command', this._w, value);
    } command = wm_command;
    function wm_deiconify(){
        """Deiconify this widget. If it was never mapped it will not be mapped.
        On Windows it will raise this widget and give it the focus.""";
        return this.tk.call('wm', 'deiconify', this._w);
    } deiconify = wm_deiconify;
    function wm_focusmodel( model=nil){
        """Set focus model to MODEL. "active" means that this widget will claim
        the focus itself, "passive" means that the window manager shall give
        the focus. Return current focus model if MODEL is None.""";
        return this.tk.call('wm', 'focusmodel', this._w, model);
    } focusmodel = wm_focusmodel;
    function wm_frame(){
        """Return identifier for decorative frame of this widget if present.""";
        return this.tk.call('wm', 'frame', this._w);
    } frame = wm_frame;
    function wm_geometry( newGeometry=nil){
        """Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
        current value if None is given.""";
        return this.tk.call('wm', 'geometry', this._w, newGeometry);
    } geometry = wm_geometry;
    function wm_grid(
         baseWidth=nil, baseHeight=nil,
         widthInc=nil, heightInc=nil){
        """Instruct the window manager that this widget shall only be
        resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
        height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
        number of grid units requested in Tk_GeometryRequest.""";
        return this._getints(this.tk.call(
            'wm', 'grid', this._w,
            baseWidth, baseHeight, widthInc, heightInc));
    } grid = wm_grid;
    function wm_group( pathName=nil){
        """Set the group leader widgets for related widgets to PATHNAME. Return
        the group leader of this widget if None is given.""";
        return this.tk.call('wm', 'group', this._w, pathName);
    } group = wm_group;
    function wm_iconbitmap( bitmap=nil, default=nil){
        """Set bitmap for the iconified widget to BITMAP. Return
        the bitmap if None is given.

        Under Windows, the DEFAULT parameter can be used to set the icon
        for the widget and any descendents that don't have an icon set
        explicitly.  DEFAULT can be the relative path to a .ico file
        (example: root.iconbitmap(default='myicon.ico') ).  See Tk
        documentation for more information.""";
        if default{
            return this.tk.call('wm', 'iconbitmap', this._w, '-default', default);
        } else{
            return this.tk.call('wm', 'iconbitmap', this._w, bitmap);
    } } iconbitmap = wm_iconbitmap;
    function wm_iconify(){
        """Display widget as icon.""";
        return this.tk.call('wm', 'iconify', this._w);
    } iconify = wm_iconify;
    function wm_iconmask( bitmap=nil){
        """Set mask for the icon bitmap of this widget. Return the
        mask if None is given.""";
        return this.tk.call('wm', 'iconmask', this._w, bitmap);
    } iconmask = wm_iconmask;
    function wm_iconname( newName=nil){
        """Set the name of the icon for this widget. Return the name if
        None is given.""";
        return this.tk.call('wm', 'iconname', this._w, newName);
    } iconname = wm_iconname;
    function wm_iconposition( x=nil, y=nil){
        """Set the position of the icon of this widget to X and Y. Return
        a tuple of the current values of X and X if None is given.""";
        return this._getints(this.tk.call(
            'wm', 'iconposition', this._w, x, y));
    } iconposition = wm_iconposition;
    function wm_iconwindow( pathName=nil){
        """Set widget PATHNAME to be displayed instead of icon. Return the current
        value if None is given.""";
        return this.tk.call('wm', 'iconwindow', this._w, pathName);
    } iconwindow = wm_iconwindow;
    function wm_maxsize( width=nil, height=nil){
        """Set max WIDTH and HEIGHT for this widget. If the window is gridded
        the values are given in grid units. Return the current values if None
        is given.""";
        return this._getints(this.tk.call(
            'wm', 'maxsize', this._w, width, height));
    } maxsize = wm_maxsize;
    function wm_minsize( width=nil, height=nil){
        """Set min WIDTH and HEIGHT for this widget. If the window is gridded
        the values are given in grid units. Return the current values if None
        is given.""";
        return this._getints(this.tk.call(
            'wm', 'minsize', this._w, width, height));
    } minsize = wm_minsize;
    function wm_overrideredirect( boolean=nil){
        """Instruct the window manager to ignore this widget
        if BOOLEAN is given with 1. Return the current value if None
        is given.""";
        return this._getboolean(this.tk.call(
            'wm', 'overrideredirect', this._w, boolean));
    } overrideredirect = wm_overrideredirect;
    function wm_positionfrom( who=nil){
        """Instruct the window manager that the position of this widget shall
        be defined by the user if WHO is "user", and by its own policy if WHO is
        "program".""";
        return this.tk.call('wm', 'positionfrom', this._w, who);
    } positionfrom = wm_positionfrom;
    function wm_protocol( name=nil, func=nil){
        """Bind function FUNC to command NAME for this widget.
        Return the function bound to NAME if None is given. NAME could be
        e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW".""";
        if hasattr(func, '__call__'){
            command = this._register(func);
        } else{
            command = func;
        } return this.tk.call(
            'wm', 'protocol', this._w, name, command);
    } protocol = wm_protocol;
    function wm_resizable( width=nil, height=nil){
        """Instruct the window manager whether this width can be resized
        in WIDTH or HEIGHT. Both values are boolean values.""";
        return this.tk.call('wm', 'resizable', this._w, width, height);
    } resizable = wm_resizable;
    function wm_sizefrom( who=nil){
        """Instruct the window manager that the size of this widget shall
        be defined by the user if WHO is "user", and by its own policy if WHO is
        "program".""";
        return this.tk.call('wm', 'sizefrom', this._w, who);
    } sizefrom = wm_sizefrom;
    function wm_state( newstate=nil){
        """Query or set the state of this widget as one of normal, icon,
        iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only).""";
        return this.tk.call('wm', 'state', this._w, newstate);
    } state = wm_state;
    function wm_title( string=nil){
        """Set the title of this widget.""";
        return this.tk.call('wm', 'title', this._w, string);
    } title = wm_title;
    function wm_transient( master=nil){
        """Instruct the window manager that this widget is transient
        with regard to widget MASTER.""";
        return this.tk.call('wm', 'transient', this._w, master);
    } transient = wm_transient;
    function wm_withdraw(){
        """Withdraw this widget from the screen such that it is unmapped
        and forgotten by the window manager. Re-draw it with wm_deiconify.""";
        return this.tk.call('wm', 'withdraw', this._w);
    } withdraw = wm_withdraw;


}
class Tk(Misc, Wm){
    """Toplevel widget of Tk which represents mostly the main window
    of an application. It has an associated Tcl interpreter.""";
    _w = '.';
    function __init__( screenName=nil, baseName=nil, className='Tk',
                 useTk=1, sync=0, use=nil){
        """Return a new Toplevel widget on screen SCREENNAME. A new Tcl interpreter will
        be created. BASENAME will be used for the identification of the profile file (see
        readprofile).
        It is constructed from sys.argv[0] without extensions if None is given. CLASSNAME
        is the name of the widget class.""";
        this.master = nil;
        this.children = {};
        this._tkloaded = 0;
        # to avoid recursions in the getattr code in case of failure, we
        # ensure that self.tk is always _something_.
        this.tk = nil;
        if baseName is nil{
            import os;
            baseName = os.path.basename(sys.argv[0]);
            baseName, ext = os.path.splitext(baseName);
            if ext not in ('.py', '.pyc', '.pyo'){
                baseName = baseName + ext;
        } } interactive = 0;
        this.tk = _tkinter.create(screenName, baseName, className, interactive, wantobjects, useTk, sync, use);
        if useTk{
            this._loadtk();
        } if not sys.flags.ignore_environment{
            # Issue #16248: Honor the -E flag to avoid code injection.
            this.readprofile(baseName, className);
    } } function loadtk(){
        if not this._tkloaded{
            this.tk.loadtk();
            this._loadtk();
    } } function _loadtk(){
        this._tkloaded = 1;
        global _default_root;
        # Version sanity checks
        tk_version = this.tk.getvar('tk_version');
        if tk_version != _tkinter.TK_VERSION{
            raise RuntimeError, \
            "tk.h version (%s) doesn't match libtk.a version (%s)" \
            % (_tkinter.TK_VERSION, tk_version);
        # Under unknown circumstances, tcl_version gets coerced to float
        }
        tcl_version = str(this.tk.getvar('tcl_version'));
        if tcl_version != _tkinter.TCL_VERSION{
            raise RuntimeError, \
            "tcl.h version (%s) doesn't match libtcl.a version (%s)" \
            % (_tkinter.TCL_VERSION, tcl_version);
        } if TkVersion < 4.0{
            raise RuntimeError, \
            "Tk 4.0 or higher is required; found Tk %s" \
            % str(TkVersion);
        # Create and register the tkerror and exit commands
        # We need to inline parts of _register here, _ register
        # would register differently-named commands.
        }
        if this._tclCommands is nil{
            this._tclCommands = [];
        } this.tk.createcommand('tkerror', _tkerror);
        this.tk.createcommand('exit', _exit);
        this._tclCommands.append('tkerror');
        this._tclCommands.append('exit');
        if _support_default_root and not _default_root{
            _default_root = this;
        } this.protocol("WM_DELETE_WINDOW", this.destroy);
    } function destroy(){
        """Destroy this and all descendants widgets. This will
        end the application of this Tcl interpreter.""";
        for c in this.children.values(){ c.destroy();}
        this.tk.call('destroy', this._w);
        Misc.destroy(this);
        global _default_root;
        if _support_default_root and _default_root is this{
            _default_root = nil;
    } } function readprofile( baseName, className){
        """Internal function. It reads BASENAME.tcl and CLASSNAME.tcl into
        the Tcl Interpreter and calls execfile on BASENAME.py and CLASSNAME.py if
        such a file exists in the home directory.""";
        import os;
        if 'HOME' in os.environ{ home = os.environ['HOME'];}
        else{ home = os.curdir;}
        class_tcl = os.path.join(home, '.%s.tcl' % className);
        class_py = os.path.join(home, '.%s.py' % className);
        base_tcl = os.path.join(home, '.%s.tcl' % baseName);
        base_py = os.path.join(home, '.%s.py' % baseName);
        dir = {'self': this};
        exec 'from Tkinter import *' in dir;
        if os.path.isfile(class_tcl){
            this.tk.call('source', class_tcl);
        } if os.path.isfile(class_py){
            execfile(class_py, dir);
        } if os.path.isfile(base_tcl){
            this.tk.call('source', base_tcl);
        } if os.path.isfile(base_py){
            execfile(base_py, dir);
    } } function report_callback_exception( exc, val, tb){
        """Report callback exception on sys.stderr.

        Applications may want to override this internal function, and
        should when sys.stderr is None.""";
        import traceback, sys;
        print >>sys.stderr, "Exception in Tkinter callback";
        sys.last_type = exc;
        sys.last_value = val;
        sys.last_traceback = tb;
        traceback.print_exception(exc, val, tb);
    } function __getattr__( attr){
        "Delegate attribute access to the interpreter object";
        return getattr(this.tk, attr);

# Ideally, the classes Pack, Place and Grid disappear, the
# pack/place/grid methods are defined on the Widget class, and
# everybody uses w.pack_whatever(...) instead of Pack.whatever(w,
# ...), with pack(), place() and grid() being short for
# pack_configure(), place_configure() and grid_columnconfigure(), and
# forget() being short for pack_forget().  As a practical matter, I'm
# afraid that there is too much code out there that may be using the
# Pack, Place or Grid class, so I leave them intact -- but only as
# backwards compatibility features.  Also note that those methods that
# take a master as argument (e.g. pack_propagate) have been moved to
# the Misc class (which now incorporates all methods common between
# toplevel and interior widgets).  Again, for compatibility, these are
# copied into the Pack, Place or Grid class.


}
} function Tcl(screenName=nil, baseName=nil, className='Tk', useTk=0){
    return Tk(screenName, baseName, className, useTk);

}
class Pack{
    """Geometry manager Pack.

    Base class to use the methods pack_* in every widget.""";
    function pack_configure( cnf={}, **kw){
        """Pack a widget in the parent widget. Use as options:
        after=widget - pack it after you have packed widget
        anchor=NSEW (or subset) - position widget according to
                                  given direction
        before=widget - pack it before you will pack widget
        expand=bool - expand widget if parent size grows
        fill=NONE or X or Y or BOTH - fill widget if widget grows
        in=master - use master to contain this widget
        in_=master - see 'in' option description
        ipadx=amount - add internal padding in x direction
        ipady=amount - add internal padding in y direction
        padx=amount - add padding in x direction
        pady=amount - add padding in y direction
        side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
        """;
        this.tk.call(
              ('pack', 'configure', this._w)
              + this._options(cnf, kw));
    } pack = configure = config = pack_configure;
    function pack_forget(){
        """Unmap this widget and do not use it for the packing order.""";
        this.tk.call('pack', 'forget', this._w);
    } forget = pack_forget;
    function pack_info(){
        """Return information about the packing options
        for this widget.""";
        d = _splitdict(this.tk, this.tk.call('pack', 'info', this._w));
        if 'in' in d{
            d['in'] = this.nametowidget(d['in']);
        } return d;
    } info = pack_info;
    propagate = pack_propagate = Misc.pack_propagate;
    slaves = pack_slaves = Misc.pack_slaves;

}
class Place{
    """Geometry manager Place.

    Base class to use the methods place_* in every widget.""";
    function place_configure( cnf={}, **kw){
        """Place a widget in the parent widget. Use as options:
        in=master - master relative to which the widget is placed
        in_=master - see 'in' option description
        x=amount - locate anchor of this widget at position x of master
        y=amount - locate anchor of this widget at position y of master
        relx=amount - locate anchor of this widget between 0.0 and 1.0
                      relative to width of master (1.0 is right edge)
        rely=amount - locate anchor of this widget between 0.0 and 1.0
                      relative to height of master (1.0 is bottom edge)
        anchor=NSEW (or subset) - position anchor according to given direction
        width=amount - width of this widget in pixel
        height=amount - height of this widget in pixel
        relwidth=amount - width of this widget between 0.0 and 1.0
                          relative to width of master (1.0 is the same width
                          as the master)
        relheight=amount - height of this widget between 0.0 and 1.0
                           relative to height of master (1.0 is the same
                           height as the master)
        bordermode="inside" or "outside" - whether to take border width of
                                           master widget into account
        """;
        this.tk.call(
              ('place', 'configure', this._w)
              + this._options(cnf, kw));
    } place = configure = config = place_configure;
    function place_forget(){
        """Unmap this widget.""";
        this.tk.call('place', 'forget', this._w);
    } forget = place_forget;
    function place_info(){
        """Return information about the placing options
        for this widget.""";
        d = _splitdict(this.tk, this.tk.call('place', 'info', this._w));
        if 'in' in d{
            d['in'] = this.nametowidget(d['in']);
        } return d;
    } info = place_info;
    slaves = place_slaves = Misc.place_slaves;

}
class Grid{
    """Geometry manager Grid.

    Base class to use the methods grid_* in every widget.""";
    # Thanks to Masazumi Yoshikawa (yosikawa@isi.edu)
    function grid_configure( cnf={}, **kw){
        """Position a widget in the parent widget in a grid. Use as options:
        column=number - use cell identified with given column (starting with 0)
        columnspan=number - this widget will span several columns
        in=master - use master to contain this widget
        in_=master - see 'in' option description
        ipadx=amount - add internal padding in x direction
        ipady=amount - add internal padding in y direction
        padx=amount - add padding in x direction
        pady=amount - add padding in y direction
        row=number - use cell identified with given row (starting with 0)
        rowspan=number - this widget will span several rows
        sticky=NSEW - if cell is larger on which sides will this
                      widget stick to the cell boundary
        """;
        this.tk.call(
              ('grid', 'configure', this._w)
              + this._options(cnf, kw));
    } grid = configure = config = grid_configure;
    bbox = grid_bbox = Misc.grid_bbox;
    columnconfigure = grid_columnconfigure = Misc.grid_columnconfigure;
    function grid_forget(){
        """Unmap this widget.""";
        this.tk.call('grid', 'forget', this._w);
    } forget = grid_forget;
    function grid_remove(){
        """Unmap this widget but remember the grid options.""";
        this.tk.call('grid', 'remove', this._w);
    } function grid_info(){
        """Return information about the options
        for positioning this widget in a grid.""";
        d = _splitdict(this.tk, this.tk.call('grid', 'info', this._w));
        if 'in' in d{
            d['in'] = this.nametowidget(d['in']);
        } return d;
    } info = grid_info;
    location = grid_location = Misc.grid_location;
    propagate = grid_propagate = Misc.grid_propagate;
    rowconfigure = grid_rowconfigure = Misc.grid_rowconfigure;
    size = grid_size = Misc.grid_size;
    slaves = grid_slaves = Misc.grid_slaves;

}
class BaseWidget(Misc){
    """Internal class.""";
    function _setup( master, cnf){
        """Internal function. Sets up information about children.""";
        if _support_default_root{
            global _default_root;
            if not master{
                if not _default_root{
                    _default_root = Tk();
                } master = _default_root;
        } } this.master = master;
        this.tk = master.tk;
        name = nil;
        if 'name' in cnf{
            name = cnf['name'];
            del cnf['name'];
        } if not name{
            name = repr(id(this));
        } this._name = name;
        if master._w=='.'{
            this._w = '.' + name;
        } else{
            this._w = master._w + '.' + name;
        } this.children = {};
        if this._name in this.master.children{
            this.master.children[this._name].destroy();
        } this.master.children[this._name] = this;
    } function __init__( master, widgetName, cnf={}, kw={}, extra=()){
        """Construct a widget with the parent widget MASTER, a name WIDGETNAME
        and appropriate options.""";
        if kw{
            cnf = _cnfmerge((cnf, kw));
        } this.widgetName = widgetName;
        BaseWidget._setup(this, master, cnf);
        if this._tclCommands is nil{
            this._tclCommands = [];
        } classes = [];
        for k in cnf.keys(){
            if type(k) is ClassType{
                classes.append((k, cnf[k]));
                del cnf[k];
        } } this.tk.call(
            (widgetName, this._w) + extra + this._options(cnf));
        for k, v in classes{
            k.configure(this, v);
    } } function destroy(){
        """Destroy this and all descendants widgets.""";
        for c in this.children.values(){ c.destroy();}
        this.tk.call('destroy', this._w);
        if this._name in this.master.children{
            del this.master.children[this._name];
        } Misc.destroy(this);
    } function _do( name, args=()){
        # XXX Obsolete -- better use self.tk.call directly!
        return this.tk.call((this._w, name) + args);

}
} class Widget(BaseWidget, Pack, Place, Grid){
    """Internal class.

    Base class for a widget which can be positioned with the geometry managers
    Pack, Place or Grid.""";
    pass;

}
class Toplevel(BaseWidget, Wm){
    """Toplevel widget, e.g. for dialogs.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct a toplevel widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, class,
        colormap, container, cursor, height, highlightbackground,
        highlightcolor, highlightthickness, menu, relief, screen, takefocus,
        use, visual, width.""";
        if kw{
            cnf = _cnfmerge((cnf, kw));
        } extra = ();
        for wmkey in ['screen', 'class_', 'class', 'visual',
                  'colormap']{
            if wmkey in cnf{
                val = cnf[wmkey];
                # TBD: a hack needed because some keys
                # are not valid as keyword arguments
                if wmkey[-1] == '_'{ opt = '-'+wmkey[:-1];}
                else{ opt = '-'+wmkey;}
                extra = extra + (opt, val);
                del cnf[wmkey];
        } } BaseWidget.__init__(this, master, 'toplevel', cnf, {}, extra);
        root = this._root();
        this.iconname(root.iconname());
        this.title(root.title());
        this.protocol("WM_DELETE_WINDOW", this.destroy);

}
} class Button(Widget){
    """Button widget.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct a button widget with the parent MASTER.

        STANDARD OPTIONS

            activebackground, activeforeground, anchor,
            background, bitmap, borderwidth, cursor,
            disabledforeground, font, foreground
            highlightbackground, highlightcolor,
            highlightthickness, image, justify,
            padx, pady, relief, repeatdelay,
            repeatinterval, takefocus, text,
            textvariable, underline, wraplength

        WIDGET-SPECIFIC OPTIONS

            command, compound, default, height,
            overrelief, state, width
        """;
        Widget.__init__(this, master, 'button', cnf, kw);

    }
    function tkButtonEnter( *dummy){
        this.tk.call('tkButtonEnter', this._w);

    }
    function tkButtonLeave( *dummy){
        this.tk.call('tkButtonLeave', this._w);

    }
    function tkButtonDown( *dummy){
        this.tk.call('tkButtonDown', this._w);

    }
    function tkButtonUp( *dummy){
        this.tk.call('tkButtonUp', this._w);

    }
    function tkButtonInvoke( *dummy){
        this.tk.call('tkButtonInvoke', this._w);

    }
    function flash(){
        """Flash the button.

        This is accomplished by redisplaying
        the button several times, alternating between active and
        normal colors. At the end of the flash the button is left
        in the same normal/active state as when the command was
        invoked. This command is ignored if the button's state is
        disabled.
        """;
        this.tk.call(this._w, 'flash');

    }
    function invoke(){
        """Invoke the command associated with the button.

        The return value is the return value from the command,
        or an empty string if there is no command associated with
        the button. This command is ignored if the button's state
        is disabled.
        """;
        return this.tk.call(this._w, 'invoke');

# Indices:
# XXX I don't like these -- take them away
}
} function AtEnd(){
    return 'end';
} function AtInsert(*args){
    s = 'insert';
    for a in args{
        if a{ s = s + (' ' + a);}
    } return s;
} function AtSelFirst(){
    return 'sel.first';
} function AtSelLast(){
    return 'sel.last';
} function At(x, y=nil){
    if y is nil{
        return '@%r' % (x,);
    } else{
        return '@%r,%r' % (x, y);

}
} class Canvas(Widget, XView, YView){
    """Canvas widget to display graphical elements like lines or text.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct a canvas widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, closeenough,
        confine, cursor, height, highlightbackground, highlightcolor,
        highlightthickness, insertbackground, insertborderwidth,
        insertofftime, insertontime, insertwidth, offset, relief,
        scrollregion, selectbackground, selectborderwidth, selectforeground,
        state, takefocus, width, xscrollcommand, xscrollincrement,
        yscrollcommand, yscrollincrement.""";
        Widget.__init__(this, master, 'canvas', cnf, kw);
    } function addtag( *args){
        """Internal function.""";
        this.tk.call((this._w, 'addtag') + args);
    } function addtag_above( newtag, tagOrId){
        """Add tag NEWTAG to all items above TAGORID.""";
        this.addtag(newtag, 'above', tagOrId);
    } function addtag_all( newtag){
        """Add tag NEWTAG to all items.""";
        this.addtag(newtag, 'all');
    } function addtag_below( newtag, tagOrId){
        """Add tag NEWTAG to all items below TAGORID.""";
        this.addtag(newtag, 'below', tagOrId);
    } function addtag_closest( newtag, x, y, halo=nil, start=nil){
        """Add tag NEWTAG to item which is closest to pixel at X, Y.
        If several match take the top-most.
        All items closer than HALO are considered overlapping (all are
        closests). If START is specified the next below this tag is taken.""";
        this.addtag(newtag, 'closest', x, y, halo, start);
    } function addtag_enclosed( newtag, x1, y1, x2, y2){
        """Add tag NEWTAG to all items in the rectangle defined
        by X1,Y1,X2,Y2.""";
        this.addtag(newtag, 'enclosed', x1, y1, x2, y2);
    } function addtag_overlapping( newtag, x1, y1, x2, y2){
        """Add tag NEWTAG to all items which overlap the rectangle
        defined by X1,Y1,X2,Y2.""";
        this.addtag(newtag, 'overlapping', x1, y1, x2, y2);
    } function addtag_withtag( newtag, tagOrId){
        """Add tag NEWTAG to all items with TAGORID.""";
        this.addtag(newtag, 'withtag', tagOrId);
    } function bbox( *args){
        """Return a tuple of X1,Y1,X2,Y2 coordinates for a rectangle
        which encloses all items with tags specified as arguments.""";
        return this._getints(
            this.tk.call((this._w, 'bbox') + args)) or nil;
    } function tag_unbind( tagOrId, sequence, funcid=nil){
        """Unbind for all items with TAGORID for event SEQUENCE  the
        function identified with FUNCID.""";
        this.tk.call(this._w, 'bind', tagOrId, sequence, '');
        if funcid{
            this.deletecommand(funcid);
    } } function tag_bind( tagOrId, sequence=nil, func=nil, add=nil){
        """Bind to all items with TAGORID at event SEQUENCE a call to function FUNC.

        An additional boolean parameter ADD specifies whether FUNC will be
        called additionally to the other bound function or whether it will
        replace the previous function. See bind for the return value.""";
        return this._bind((this._w, 'bind', tagOrId),
                  sequence, func, add);
    } function canvasx( screenx, gridspacing=nil){
        """Return the canvas x coordinate of pixel position SCREENX rounded
        to nearest multiple of GRIDSPACING units.""";
        return getdouble(this.tk.call(
            this._w, 'canvasx', screenx, gridspacing));
    } function canvasy( screeny, gridspacing=nil){
        """Return the canvas y coordinate of pixel position SCREENY rounded
        to nearest multiple of GRIDSPACING units.""";
        return getdouble(this.tk.call(
            this._w, 'canvasy', screeny, gridspacing));
    } function coords( *args){
        """Return a list of coordinates for the item given in ARGS.""";
        # XXX Should use _flatten on args
        return map(getdouble,
                           this.tk.splitlist(
                   this.tk.call((this._w, 'coords') + args)));
    } function _create( itemType, args, kw){ # Args: (val, val, ..., cnf={})
        """Internal function.""";
        args = _flatten(args);
        cnf = args[-1];
        if type(cnf) in (DictionaryType, TupleType){
            args = args[:-1];
        } else{
            cnf = {};
        } return getint(this.tk.call(
            this._w, 'create', itemType,
            *(args + this._options(cnf, kw))));
    } function create_arc( *args, **kw){
        """Create arc shaped region with coordinates x1,y1,x2,y2.""";
        return this._create('arc', args, kw);
    } function create_bitmap( *args, **kw){
        """Create bitmap with coordinates x1,y1.""";
        return this._create('bitmap', args, kw);
    } function create_image( *args, **kw){
        """Create image item with coordinates x1,y1.""";
        return this._create('image', args, kw);
    } function create_line( *args, **kw){
        """Create line with coordinates x1,y1,...,xn,yn.""";
        return this._create('line', args, kw);
    } function create_oval( *args, **kw){
        """Create oval with coordinates x1,y1,x2,y2.""";
        return this._create('oval', args, kw);
    } function create_polygon( *args, **kw){
        """Create polygon with coordinates x1,y1,...,xn,yn.""";
        return this._create('polygon', args, kw);
    } function create_rectangle( *args, **kw){
        """Create rectangle with coordinates x1,y1,x2,y2.""";
        return this._create('rectangle', args, kw);
    } function create_text( *args, **kw){
        """Create text with coordinates x1,y1.""";
        return this._create('text', args, kw);
    } function create_window( *args, **kw){
        """Create window with coordinates x1,y1,x2,y2.""";
        return this._create('window', args, kw);
    } function dchars( *args){
        """Delete characters of text items identified by tag or id in ARGS (possibly
        several times) from FIRST to LAST character (including).""";
        this.tk.call((this._w, 'dchars') + args);
    } function delete( *args){
        """Delete items identified by all tag or ids contained in ARGS.""";
        this.tk.call((this._w, 'delete') + args);
    } function dtag( *args){
        """Delete tag or id given as last arguments in ARGS from items
        identified by first argument in ARGS.""";
        this.tk.call((this._w, 'dtag') + args);
    } function find( *args){
        """Internal function.""";
        return this._getints(
            this.tk.call((this._w, 'find') + args)) or ();
    } function find_above( tagOrId){
        """Return items above TAGORID.""";
        return this.find('above', tagOrId);
    } function find_all(){
        """Return all items.""";
        return this.find('all');
    } function find_below( tagOrId){
        """Return all items below TAGORID.""";
        return this.find('below', tagOrId);
    } function find_closest( x, y, halo=nil, start=nil){
        """Return item which is closest to pixel at X, Y.
        If several match take the top-most.
        All items closer than HALO are considered overlapping (all are
        closest). If START is specified the next below this tag is taken.""";
        return this.find('closest', x, y, halo, start);
    } function find_enclosed( x1, y1, x2, y2){
        """Return all items in rectangle defined
        by X1,Y1,X2,Y2.""";
        return this.find('enclosed', x1, y1, x2, y2);
    } function find_overlapping( x1, y1, x2, y2){
        """Return all items which overlap the rectangle
        defined by X1,Y1,X2,Y2.""";
        return this.find('overlapping', x1, y1, x2, y2);
    } function find_withtag( tagOrId){
        """Return all items with TAGORID.""";
        return this.find('withtag', tagOrId);
    } function focus( *args){
        """Set focus to the first item specified in ARGS.""";
        return this.tk.call((this._w, 'focus') + args);
    } function gettags( *args){
        """Return tags associated with the first item specified in ARGS.""";
        return this.tk.splitlist(
            this.tk.call((this._w, 'gettags') + args));
    } function icursor( *args){
        """Set cursor at position POS in the item identified by TAGORID.
        In ARGS TAGORID must be first.""";
        this.tk.call((this._w, 'icursor') + args);
    } function index( *args){
        """Return position of cursor as integer in item specified in ARGS.""";
        return getint(this.tk.call((this._w, 'index') + args));
    } function insert( *args){
        """Insert TEXT in item TAGORID at position POS. ARGS must
        be TAGORID POS TEXT.""";
        this.tk.call((this._w, 'insert') + args);
    } function itemcget( tagOrId, option){
        """Return the resource value for an OPTION for item TAGORID.""";
        return this.tk.call(
            (this._w, 'itemcget') + (tagOrId, '-'+option));
    } function itemconfigure( tagOrId, cnf=nil, **kw){
        """Configure resources of an item TAGORID.

        The values for resources are specified as keyword
        arguments. To get an overview about
        the allowed keyword arguments call the method without arguments.
        """;
        return this._configure(('itemconfigure', tagOrId), cnf, kw);
    } itemconfig = itemconfigure;
    # lower, tkraise/lift hide Misc.lower, Misc.tkraise/lift,
    # so the preferred name for them is tag_lower, tag_raise
    # (similar to tag_bind, and similar to the Text widget);
    # unfortunately can't delete the old ones yet (maybe in 1.6)
    function tag_lower( *args){
        """Lower an item TAGORID given in ARGS
        (optional below another item).""";
        this.tk.call((this._w, 'lower') + args);
    } lower = tag_lower;
    function move( *args){
        """Move an item TAGORID given in ARGS.""";
        this.tk.call((this._w, 'move') + args);
    } function postscript( cnf={}, **kw){
        """Print the contents of the canvas to a postscript
        file. Valid options: colormap, colormode, file, fontmap,
        height, pageanchor, pageheight, pagewidth, pagex, pagey,
        rotate, width, x, y.""";
        return this.tk.call((this._w, 'postscript') +
                    this._options(cnf, kw));
    } function tag_raise( *args){
        """Raise an item TAGORID given in ARGS
        (optional above another item).""";
        this.tk.call((this._w, 'raise') + args);
    } lift = tkraise = tag_raise;
    function scale( *args){
        """Scale item TAGORID with XORIGIN, YORIGIN, XSCALE, YSCALE.""";
        this.tk.call((this._w, 'scale') + args);
    } function scan_mark( x, y){
        """Remember the current X, Y coordinates.""";
        this.tk.call(this._w, 'scan', 'mark', x, y);
    } function scan_dragto( x, y, gain=10){
        """Adjust the view of the canvas to GAIN times the
        difference between X and Y and the coordinates given in
        scan_mark.""";
        this.tk.call(this._w, 'scan', 'dragto', x, y, gain);
    } function select_adjust( tagOrId, index){
        """Adjust the end of the selection near the cursor of an item TAGORID to index.""";
        this.tk.call(this._w, 'select', 'adjust', tagOrId, index);
    } function select_clear(){
        """Clear the selection if it is in this widget.""";
        this.tk.call(this._w, 'select', 'clear');
    } function select_from( tagOrId, index){
        """Set the fixed end of a selection in item TAGORID to INDEX.""";
        this.tk.call(this._w, 'select', 'from', tagOrId, index);
    } function select_item(){
        """Return the item which has the selection.""";
        return this.tk.call(this._w, 'select', 'item') or nil;
    } function select_to( tagOrId, index){
        """Set the variable end of a selection in item TAGORID to INDEX.""";
        this.tk.call(this._w, 'select', 'to', tagOrId, index);
    } function type( tagOrId){
        """Return the type of the item TAGORID.""";
        return this.tk.call(this._w, 'type', tagOrId) or nil;

}
} class Checkbutton(Widget){
    """Checkbutton widget which is either in on- or off-state.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct a checkbutton widget with the parent MASTER.

        Valid resource names: activebackground, activeforeground, anchor,
        background, bd, bg, bitmap, borderwidth, command, cursor,
        disabledforeground, fg, font, foreground, height,
        highlightbackground, highlightcolor, highlightthickness, image,
        indicatoron, justify, offvalue, onvalue, padx, pady, relief,
        selectcolor, selectimage, state, takefocus, text, textvariable,
        underline, variable, width, wraplength.""";
        Widget.__init__(this, master, 'checkbutton', cnf, kw);
    } function deselect(){
        """Put the button in off-state.""";
        this.tk.call(this._w, 'deselect');
    } function flash(){
        """Flash the button.""";
        this.tk.call(this._w, 'flash');
    } function invoke(){
        """Toggle the button and invoke a command if given as resource.""";
        return this.tk.call(this._w, 'invoke');
    } function select(){
        """Put the button in on-state.""";
        this.tk.call(this._w, 'select');
    } function toggle(){
        """Toggle the button.""";
        this.tk.call(this._w, 'toggle');

}
} class Entry(Widget, XView){
    """Entry widget which allows displaying simple text.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct an entry widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, cursor,
        exportselection, fg, font, foreground, highlightbackground,
        highlightcolor, highlightthickness, insertbackground,
        insertborderwidth, insertofftime, insertontime, insertwidth,
        invalidcommand, invcmd, justify, relief, selectbackground,
        selectborderwidth, selectforeground, show, state, takefocus,
        textvariable, validate, validatecommand, vcmd, width,
        xscrollcommand.""";
        Widget.__init__(this, master, 'entry', cnf, kw);
    } function delete( first, last=nil){
        """Delete text from FIRST to LAST (not included).""";
        this.tk.call(this._w, 'delete', first, last);
    } function get(){
        """Return the text.""";
        return this.tk.call(this._w, 'get');
    } function icursor( index){
        """Insert cursor at INDEX.""";
        this.tk.call(this._w, 'icursor', index);
    } function index( index){
        """Return position of cursor.""";
        return getint(this.tk.call(
            this._w, 'index', index));
    } function insert( index, string){
        """Insert STRING at INDEX.""";
        this.tk.call(this._w, 'insert', index, string);
    } function scan_mark( x){
        """Remember the current X, Y coordinates.""";
        this.tk.call(this._w, 'scan', 'mark', x);
    } function scan_dragto( x){
        """Adjust the view of the canvas to 10 times the
        difference between X and Y and the coordinates given in
        scan_mark.""";
        this.tk.call(this._w, 'scan', 'dragto', x);
    } function selection_adjust( index){
        """Adjust the end of the selection near the cursor to INDEX.""";
        this.tk.call(this._w, 'selection', 'adjust', index);
    } select_adjust = selection_adjust;
    function selection_clear(){
        """Clear the selection if it is in this widget.""";
        this.tk.call(this._w, 'selection', 'clear');
    } select_clear = selection_clear;
    function selection_from( index){
        """Set the fixed end of a selection to INDEX.""";
        this.tk.call(this._w, 'selection', 'from', index);
    } select_from = selection_from;
    function selection_present(){
        """Return True if there are characters selected in the entry, False
        otherwise.""";
        return this.tk.getboolean(
            this.tk.call(this._w, 'selection', 'present'));
    } select_present = selection_present;
    function selection_range( start, end){
        """Set the selection from START to END (not included).""";
        this.tk.call(this._w, 'selection', 'range', start, end);
    } select_range = selection_range;
    function selection_to( index){
        """Set the variable end of a selection to INDEX.""";
        this.tk.call(this._w, 'selection', 'to', index);
    } select_to = selection_to;

}
class Frame(Widget){
    """Frame widget which may contain other widgets and can have a 3D border.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct a frame widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, class,
        colormap, container, cursor, height, highlightbackground,
        highlightcolor, highlightthickness, relief, takefocus, visual, width.""";
        cnf = _cnfmerge((cnf, kw));
        extra = ();
        if 'class_' in cnf{
            extra = ('-class', cnf['class_']);
            del cnf['class_'];
        } elif 'class' in cnf{
            extra = ('-class', cnf['class']);
            del cnf['class'];
        } Widget.__init__(this, master, 'frame', cnf, {}, extra);

}
} class Label(Widget){
    """Label widget which can display text and bitmaps.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct a label widget with the parent MASTER.

        STANDARD OPTIONS

            activebackground, activeforeground, anchor,
            background, bitmap, borderwidth, cursor,
            disabledforeground, font, foreground,
            highlightbackground, highlightcolor,
            highlightthickness, image, justify,
            padx, pady, relief, takefocus, text,
            textvariable, underline, wraplength

        WIDGET-SPECIFIC OPTIONS

            height, state, width

        """;
        Widget.__init__(this, master, 'label', cnf, kw);

}
} class Listbox(Widget, XView, YView){
    """Listbox widget which can display a list of strings.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct a listbox widget with the parent MASTER.

        Valid resource names: background, bd, bg, borderwidth, cursor,
        exportselection, fg, font, foreground, height, highlightbackground,
        highlightcolor, highlightthickness, relief, selectbackground,
        selectborderwidth, selectforeground, selectmode, setgrid, takefocus,
        width, xscrollcommand, yscrollcommand, listvariable.""";
        Widget.__init__(this, master, 'listbox', cnf, kw);
    } function activate( index){
        """Activate item identified by INDEX.""";
        this.tk.call(this._w, 'activate', index);
    } function bbox( index){
        """Return a tuple of X1,Y1,X2,Y2 coordinates for a rectangle
        which encloses the item identified by the given index.""";
        return this._getints(this.tk.call(this._w, 'bbox', index)) or nil;
    } function curselection(){
        """Return the indices of currently selected item.""";
        return this._getints(this.tk.call(this._w, 'curselection')) or ();
    } function delete( first, last=nil){
        """Delete items from FIRST to LAST (included).""";
        this.tk.call(this._w, 'delete', first, last);
    } function get( first, last=nil){
        """Get list of items from FIRST to LAST (included).""";
        if last is not nil{
            return this.tk.splitlist(this.tk.call(
                this._w, 'get', first, last));
        } else{
            return this.tk.call(this._w, 'get', first);
    } } function index( index){
        """Return index of item identified with INDEX.""";
        i = this.tk.call(this._w, 'index', index);
        if i == 'none'{ return nil;}
        return getint(i);
    } function insert( index, *elements){
        """Insert ELEMENTS at INDEX.""";
        this.tk.call((this._w, 'insert', index) + elements);
    } function nearest( y){
        """Get index of item which is nearest to y coordinate Y.""";
        return getint(this.tk.call(
            this._w, 'nearest', y));
    } function scan_mark( x, y){
        """Remember the current X, Y coordinates.""";
        this.tk.call(this._w, 'scan', 'mark', x, y);
    } function scan_dragto( x, y){
        """Adjust the view of the listbox to 10 times the
        difference between X and Y and the coordinates given in
        scan_mark.""";
        this.tk.call(this._w, 'scan', 'dragto', x, y);
    } function see( index){
        """Scroll such that INDEX is visible.""";
        this.tk.call(this._w, 'see', index);
    } function selection_anchor( index){
        """Set the fixed end oft the selection to INDEX.""";
        this.tk.call(this._w, 'selection', 'anchor', index);
    } select_anchor = selection_anchor;
    function selection_clear( first, last=nil){
        """Clear the selection from FIRST to LAST (included).""";
        this.tk.call(this._w,
                 'selection', 'clear', first, last);
    } select_clear = selection_clear;
    function selection_includes( index){
        """Return 1 if INDEX is part of the selection.""";
        return this.tk.getboolean(this.tk.call(
            this._w, 'selection', 'includes', index));
    } select_includes = selection_includes;
    function selection_set( first, last=nil){
        """Set the selection from FIRST to LAST (included) without
        changing the currently selected elements.""";
        this.tk.call(this._w, 'selection', 'set', first, last);
    } select_set = selection_set;
    function size(){
        """Return the number of elements in the listbox.""";
        return getint(this.tk.call(this._w, 'size'));
    } function itemcget( index, option){
        """Return the resource value for an ITEM and an OPTION.""";
        return this.tk.call(
            (this._w, 'itemcget') + (index, '-'+option));
    } function itemconfigure( index, cnf=nil, **kw){
        """Configure resources of an ITEM.

        The values for resources are specified as keyword arguments.
        To get an overview about the allowed keyword arguments
        call the method without arguments.
        Valid resource names: background, bg, foreground, fg,
        selectbackground, selectforeground.""";
        return this._configure(('itemconfigure', index), cnf, kw);
    } itemconfig = itemconfigure;

}
class Menu(Widget){
    """Menu widget which allows displaying menu bars, pull-down menus and pop-up menus.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct menu widget with the parent MASTER.

        Valid resource names: activebackground, activeborderwidth,
        activeforeground, background, bd, bg, borderwidth, cursor,
        disabledforeground, fg, font, foreground, postcommand, relief,
        selectcolor, takefocus, tearoff, tearoffcommand, title, type.""";
        Widget.__init__(this, master, 'menu', cnf, kw);
    } function tk_bindForTraversal(){
        # obsolete since Tk 4.0
        import warnings;
        warnings.warn('tk_bindForTraversal() does nothing and '
                      'will be removed in 3.6',
                      DeprecationWarning, stacklevel=2);
    } function tk_mbPost(){
        this.tk.call('tk_mbPost', this._w);
    } function tk_mbUnpost(){
        this.tk.call('tk_mbUnpost');
    } function tk_traverseToMenu( char){
        this.tk.call('tk_traverseToMenu', this._w, char);
    } function tk_traverseWithinMenu( char){
        this.tk.call('tk_traverseWithinMenu', this._w, char);
    } function tk_getMenuButtons(){
        return this.tk.call('tk_getMenuButtons', this._w);
    } function tk_nextMenu( count){
        this.tk.call('tk_nextMenu', count);
    } function tk_nextMenuEntry( count){
        this.tk.call('tk_nextMenuEntry', count);
    } function tk_invokeMenu(){
        this.tk.call('tk_invokeMenu', this._w);
    } function tk_firstMenu(){
        this.tk.call('tk_firstMenu', this._w);
    } function tk_mbButtonDown(){
        this.tk.call('tk_mbButtonDown', this._w);
    } function tk_popup( x, y, entry=""){
        """Post the menu at position X,Y with entry ENTRY.""";
        this.tk.call('tk_popup', this._w, x, y, entry);
    } function activate( index){
        """Activate entry at INDEX.""";
        this.tk.call(this._w, 'activate', index);
    } function add( itemType, cnf={}, **kw){
        """Internal function.""";
        this.tk.call((this._w, 'add', itemType) +
                 this._options(cnf, kw));
    } function add_cascade( cnf={}, **kw){
        """Add hierarchical menu item.""";
        this.add('cascade', cnf or kw);
    } function add_checkbutton( cnf={}, **kw){
        """Add checkbutton menu item.""";
        this.add('checkbutton', cnf or kw);
    } function add_command( cnf={}, **kw){
        """Add command menu item.""";
        this.add('command', cnf or kw);
    } function add_radiobutton( cnf={}, **kw){
        """Addd radio menu item.""";
        this.add('radiobutton', cnf or kw);
    } function add_separator( cnf={}, **kw){
        """Add separator.""";
        this.add('separator', cnf or kw);
    } function insert( index, itemType, cnf={}, **kw){
        """Internal function.""";
        this.tk.call((this._w, 'insert', index, itemType) +
                 this._options(cnf, kw));
    } function insert_cascade( index, cnf={}, **kw){
        """Add hierarchical menu item at INDEX.""";
        this.insert(index, 'cascade', cnf or kw);
    } function insert_checkbutton( index, cnf={}, **kw){
        """Add checkbutton menu item at INDEX.""";
        this.insert(index, 'checkbutton', cnf or kw);
    } function insert_command( index, cnf={}, **kw){
        """Add command menu item at INDEX.""";
        this.insert(index, 'command', cnf or kw);
    } function insert_radiobutton( index, cnf={}, **kw){
        """Addd radio menu item at INDEX.""";
        this.insert(index, 'radiobutton', cnf or kw);
    } function insert_separator( index, cnf={}, **kw){
        """Add separator at INDEX.""";
        this.insert(index, 'separator', cnf or kw);
    } function delete( index1, index2=nil){
        """Delete menu items between INDEX1 and INDEX2 (included).""";
        if index2 is nil{
            index2 = index1;

        }
        num_index1, num_index2 = this.index(index1), this.index(index2);
        if (num_index1 is nil) or (num_index2 is nil){
            num_index1, num_index2 = 0, -1;

        }
        for i in range(num_index1, num_index2 + 1){
            if 'command' in this.entryconfig(i){
                c = str(this.entrycget(i, 'command'));
                if c{
                    this.deletecommand(c);
        } } } this.tk.call(this._w, 'delete', index1, index2);
    } function entrycget( index, option){
        """Return the resource value of a menu item for OPTION at INDEX.""";
        return this.tk.call(this._w, 'entrycget', index, '-' + option);
    } function entryconfigure( index, cnf=nil, **kw){
        """Configure a menu item at INDEX.""";
        return this._configure(('entryconfigure', index), cnf, kw);
    } entryconfig = entryconfigure;
    function index( index){
        """Return the index of a menu item identified by INDEX.""";
        i = this.tk.call(this._w, 'index', index);
        if i == 'none'{ return nil;}
        return getint(i);
    } function invoke( index){
        """Invoke a menu item identified by INDEX and execute
        the associated command.""";
        return this.tk.call(this._w, 'invoke', index);
    } function post( x, y){
        """Display a menu at position X,Y.""";
        this.tk.call(this._w, 'post', x, y);
    } function type( index){
        """Return the type of the menu item at INDEX.""";
        return this.tk.call(this._w, 'type', index);
    } function unpost(){
        """Unmap a menu.""";
        this.tk.call(this._w, 'unpost');
    } function yposition( index){
        """Return the y-position of the topmost pixel of the menu item at INDEX.""";
        return getint(this.tk.call(
            this._w, 'yposition', index));

}
} class Menubutton(Widget){
    """Menubutton widget, obsolete since Tk8.0.""";
    function __init__( master=nil, cnf={}, **kw){
        Widget.__init__(this, master, 'menubutton', cnf, kw);

}
} class Message(Widget){
    """Message widget to display multiline text. Obsolete since Label does it too.""";
    function __init__( master=nil, cnf={}, **kw){
        Widget.__init__(this, master, 'message', cnf, kw);

}
} class Radiobutton(Widget){
    """Radiobutton widget which shows only one of several buttons in on-state.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct a radiobutton widget with the parent MASTER.

        Valid resource names: activebackground, activeforeground, anchor,
        background, bd, bg, bitmap, borderwidth, command, cursor,
        disabledforeground, fg, font, foreground, height,
        highlightbackground, highlightcolor, highlightthickness, image,
        indicatoron, justify, padx, pady, relief, selectcolor, selectimage,
        state, takefocus, text, textvariable, underline, value, variable,
        width, wraplength.""";
        Widget.__init__(this, master, 'radiobutton', cnf, kw);
    } function deselect(){
        """Put the button in off-state.""";

        this.tk.call(this._w, 'deselect');
    } function flash(){
        """Flash the button.""";
        this.tk.call(this._w, 'flash');
    } function invoke(){
        """Toggle the button and invoke a command if given as resource.""";
        return this.tk.call(this._w, 'invoke');
    } function select(){
        """Put the button in on-state.""";
        this.tk.call(this._w, 'select');

}
} class Scale(Widget){
    """Scale widget which can display a numerical scale.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct a scale widget with the parent MASTER.

        Valid resource names: activebackground, background, bigincrement, bd,
        bg, borderwidth, command, cursor, digits, fg, font, foreground, from,
        highlightbackground, highlightcolor, highlightthickness, label,
        length, orient, relief, repeatdelay, repeatinterval, resolution,
        showvalue, sliderlength, sliderrelief, state, takefocus,
        tickinterval, to, troughcolor, variable, width.""";
        Widget.__init__(this, master, 'scale', cnf, kw);
    } function get(){
        """Get the current value as integer or float.""";
        value = this.tk.call(this._w, 'get');
        try{
            return getint(value);
        } except ValueError{
            return getdouble(value);
    } } function set( value){
        """Set the value to VALUE.""";
        this.tk.call(this._w, 'set', value);
    } function coords( value=nil){
        """Return a tuple (X,Y) of the point along the centerline of the
        trough that corresponds to VALUE or the current value if None is
        given.""";

        return this._getints(this.tk.call(this._w, 'coords', value));
    } function identify( x, y){
        """Return where the point X,Y lies. Valid return values are "slider",
        "though1" and "though2".""";
        return this.tk.call(this._w, 'identify', x, y);

}
} class Scrollbar(Widget){
    """Scrollbar widget which displays a slider at a certain position.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct a scrollbar widget with the parent MASTER.

        Valid resource names: activebackground, activerelief,
        background, bd, bg, borderwidth, command, cursor,
        elementborderwidth, highlightbackground,
        highlightcolor, highlightthickness, jump, orient,
        relief, repeatdelay, repeatinterval, takefocus,
        troughcolor, width.""";
        Widget.__init__(this, master, 'scrollbar', cnf, kw);
    } function activate( index){
        """Display the element at INDEX with activebackground and activerelief.
        INDEX can be "arrow1","slider" or "arrow2".""";
        this.tk.call(this._w, 'activate', index);
    } function delta( deltax, deltay){
        """Return the fractional change of the scrollbar setting if it
        would be moved by DELTAX or DELTAY pixels.""";
        return getdouble(
            this.tk.call(this._w, 'delta', deltax, deltay));
    } function fraction( x, y){
        """Return the fractional value which corresponds to a slider
        position of X,Y.""";
        return getdouble(this.tk.call(this._w, 'fraction', x, y));
    } function identify( x, y){
        """Return the element under position X,Y as one of
        "arrow1","slider","arrow2" or "".""";
        return this.tk.call(this._w, 'identify', x, y);
    } function get(){
        """Return the current fractional values (upper and lower end)
        of the slider position.""";
        return this._getdoubles(this.tk.call(this._w, 'get'));
    } function set( *args){
        """Set the fractional values of the slider position (upper and
        lower ends as value between 0 and 1).""";
        this.tk.call((this._w, 'set') + args);



}
} class Text(Widget, XView, YView){
    """Text widget which can display text in various forms.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct a text widget with the parent MASTER.

        STANDARD OPTIONS

            background, borderwidth, cursor,
            exportselection, font, foreground,
            highlightbackground, highlightcolor,
            highlightthickness, insertbackground,
            insertborderwidth, insertofftime,
            insertontime, insertwidth, padx, pady,
            relief, selectbackground,
            selectborderwidth, selectforeground,
            setgrid, takefocus,
            xscrollcommand, yscrollcommand,

        WIDGET-SPECIFIC OPTIONS

            autoseparators, height, maxundo,
            spacing1, spacing2, spacing3,
            state, tabs, undo, width, wrap,

        """;
        Widget.__init__(this, master, 'text', cnf, kw);
    } function bbox( *args){
        """Return a tuple of (x,y,width,height) which gives the bounding
        box of the visible part of the character at the index in ARGS.""";
        return this._getints(
            this.tk.call((this._w, 'bbox') + args)) or nil;
    } function tk_textSelectTo( index){
        this.tk.call('tk_textSelectTo', this._w, index);
    } function tk_textBackspace(){
        this.tk.call('tk_textBackspace', this._w);
    } function tk_textIndexCloser( a, b, c){
        this.tk.call('tk_textIndexCloser', this._w, a, b, c);
    } function tk_textResetAnchor( index){
        this.tk.call('tk_textResetAnchor', this._w, index);
    } function compare( index1, op, index2){
        """Return whether between index INDEX1 and index INDEX2 the
        relation OP is satisfied. OP is one of <, <=, ==, >=, >, or !=.""";
        return this.tk.getboolean(this.tk.call(
            this._w, 'compare', index1, op, index2));
    } function debug( boolean=nil){
        """Turn on the internal consistency checks of the B-Tree inside the text
        widget according to BOOLEAN.""";
        if boolean is nil{
            return this.tk.getboolean(this.tk.call(this._w, 'debug'));
        } this.tk.call(this._w, 'debug', boolean);
    } function delete( index1, index2=nil){
        """Delete the characters between INDEX1 and INDEX2 (not included).""";
        this.tk.call(this._w, 'delete', index1, index2);
    } function dlineinfo( index){
        """Return tuple (x,y,width,height,baseline) giving the bounding box
        and baseline position of the visible part of the line containing
        the character at INDEX.""";
        return this._getints(this.tk.call(this._w, 'dlineinfo', index));
    } function dump( index1, index2=nil, command=nil, **kw){
        """Return the contents of the widget between index1 and index2.

        The type of contents returned in filtered based on the keyword
        parameters; if 'all', 'image', 'mark', 'tag', 'text', or 'window' are
        given and true, then the corresponding items are returned. The result
        is a list of triples of the form (key, value, index). If none of the
        keywords are true then 'all' is used by default.

        If the 'command' argument is given, it is called once for each element
        of the list of triples, with the values of each triple serving as the
        arguments to the function. In this case the list is not returned.""";
        args = [];
        func_name = nil;
        result = nil;
        if not command{
            # Never call the dump command without the -command flag, since the
            # output could involve Tcl quoting and would be a pain to parse
            # right. Instead just set the command to build a list of triples
            # as if we had done the parsing.
            result = [];
            function append_triple(key, value, index, result=result){
                result.append((key, value, index));
            } command = append_triple;
        } try{
            if not isinstance(command, str){
                func_name = command = this._register(command);
            } args += ["-command", command];
            for key in kw{
                if kw[key]{ args.append("-" + key);}
            } args.append(index1);
            if index2{
                args.append(index2);
            } this.tk.call(this._w, "dump", *args);
            return result;
        } finally{
            if func_name{
                this.deletecommand(func_name);

    ## new in tk8.4
    }
    } } function edit( *args){
        """Internal method

        This method controls the undo mechanism and
        the modified flag. The exact behavior of the
        command depends on the option argument that
        follows the edit argument. The following forms
        of the command are currently supported:

        edit_modified, edit_redo, edit_reset, edit_separator
        and edit_undo

        """;
        return this.tk.call(this._w, 'edit', *args);

    }
    function edit_modified( arg=nil){
        """Get or Set the modified flag

        If arg is not specified, returns the modified
        flag of the widget. The insert, delete, edit undo and
        edit redo commands or the user can set or clear the
        modified flag. If boolean is specified, sets the
        modified flag of the widget to arg.
        """;
        return this.edit("modified", arg);

    }
    function edit_redo(){
        """Redo the last undone edit

        When the undo option is true, reapplies the last
        undone edits provided no other edits were done since
        then. Generates an error when the redo stack is empty.
        Does nothing when the undo option is false.
        """;
        return this.edit("redo");

    }
    function edit_reset(){
        """Clears the undo and redo stacks
        """;
        return this.edit("reset");

    }
    function edit_separator(){
        """Inserts a separator (boundary) on the undo stack.

        Does nothing when the undo option is false
        """;
        return this.edit("separator");

    }
    function edit_undo(){
        """Undoes the last edit action

        If the undo option is true. An edit action is defined
        as all the insert and delete commands that are recorded
        on the undo stack in between two separators. Generates
        an error when the undo stack is empty. Does nothing
        when the undo option is false
        """;
        return this.edit("undo");

    }
    function get( index1, index2=nil){
        """Return the text from INDEX1 to INDEX2 (not included).""";
        return this.tk.call(this._w, 'get', index1, index2);
    # (Image commands are new in 8.0)
    }
    function image_cget( index, option){
        """Return the value of OPTION of an embedded image at INDEX.""";
        if option[:1] != "-"{
            option = "-" + option;
        } if option[-1:] == "_"{
            option = option[:-1];
        } return this.tk.call(this._w, "image", "cget", index, option);
    } function image_configure( index, cnf=nil, **kw){
        """Configure an embedded image at INDEX.""";
        return this._configure(('image', 'configure', index), cnf, kw);
    } function image_create( index, cnf={}, **kw){
        """Create an embedded image at INDEX.""";
        return this.tk.call(
                 this._w, "image", "create", index,
                 *this._options(cnf, kw));
    } function image_names(){
        """Return all names of embedded images in this widget.""";
        return this.tk.call(this._w, "image", "names");
    } function index( index){
        """Return the index in the form line.char for INDEX.""";
        return str(this.tk.call(this._w, 'index', index));
    } function insert( index, chars, *args){
        """Insert CHARS before the characters at INDEX. An additional
        tag can be given in ARGS. Additional CHARS and tags can follow in ARGS.""";
        this.tk.call((this._w, 'insert', index, chars) + args);
    } function mark_gravity( markName, direction=nil){
        """Change the gravity of a mark MARKNAME to DIRECTION (LEFT or RIGHT).
        Return the current value if None is given for DIRECTION.""";
        return this.tk.call(
            (this._w, 'mark', 'gravity', markName, direction));
    } function mark_names(){
        """Return all mark names.""";
        return this.tk.splitlist(this.tk.call(
            this._w, 'mark', 'names'));
    } function mark_set( markName, index){
        """Set mark MARKNAME before the character at INDEX.""";
        this.tk.call(this._w, 'mark', 'set', markName, index);
    } function mark_unset( *markNames){
        """Delete all marks in MARKNAMES.""";
        this.tk.call((this._w, 'mark', 'unset') + markNames);
    } function mark_next( index){
        """Return the name of the next mark after INDEX.""";
        return this.tk.call(this._w, 'mark', 'next', index) or nil;
    } function mark_previous( index){
        """Return the name of the previous mark before INDEX.""";
        return this.tk.call(this._w, 'mark', 'previous', index) or nil;
    } function scan_mark( x, y){
        """Remember the current X, Y coordinates.""";
        this.tk.call(this._w, 'scan', 'mark', x, y);
    } function scan_dragto( x, y){
        """Adjust the view of the text to 10 times the
        difference between X and Y and the coordinates given in
        scan_mark.""";
        this.tk.call(this._w, 'scan', 'dragto', x, y);
    } function search( pattern, index, stopindex=nil,
           forwards=nil, backwards=nil, exact=nil,
           regexp=nil, nocase=nil, count=nil, elide=nil){
        """Search PATTERN beginning from INDEX until STOPINDEX.
        Return the index of the first character of a match or an
        empty string.""";
        args = [this._w, 'search'];
        if forwards{ args.append('-forwards');}
        if backwards{ args.append('-backwards');}
        if exact{ args.append('-exact');}
        if regexp{ args.append('-regexp');}
        if nocase{ args.append('-nocase');}
        if elide{ args.append('-elide');}
        if count{ args.append('-count'); args.append(count);}
        if pattern and pattern[0] == '-'{ args.append('--');}
        args.append(pattern);
        args.append(index);
        if stopindex{ args.append(stopindex);}
        return str(this.tk.call(tuple(args)));
    } function see( index){
        """Scroll such that the character at INDEX is visible.""";
        this.tk.call(this._w, 'see', index);
    } function tag_add( tagName, index1, *args){
        """Add tag TAGNAME to all characters between INDEX1 and index2 in ARGS.
        Additional pairs of indices may follow in ARGS.""";
        this.tk.call(
            (this._w, 'tag', 'add', tagName, index1) + args);
    } function tag_unbind( tagName, sequence, funcid=nil){
        """Unbind for all characters with TAGNAME for event SEQUENCE  the
        function identified with FUNCID.""";
        this.tk.call(this._w, 'tag', 'bind', tagName, sequence, '');
        if funcid{
            this.deletecommand(funcid);
    } } function tag_bind( tagName, sequence, func, add=nil){
        """Bind to all characters with TAGNAME at event SEQUENCE a call to function FUNC.

        An additional boolean parameter ADD specifies whether FUNC will be
        called additionally to the other bound function or whether it will
        replace the previous function. See bind for the return value.""";
        return this._bind((this._w, 'tag', 'bind', tagName),
                  sequence, func, add);
    } function tag_cget( tagName, option){
        """Return the value of OPTION for tag TAGNAME.""";
        if option[:1] != '-'{
            option = '-' + option;
        } if option[-1:] == '_'{
            option = option[:-1];
        } return this.tk.call(this._w, 'tag', 'cget', tagName, option);
    } function tag_configure( tagName, cnf=nil, **kw){
        """Configure a tag TAGNAME.""";
        return this._configure(('tag', 'configure', tagName), cnf, kw);
    } tag_config = tag_configure;
    function tag_delete( *tagNames){
        """Delete all tags in TAGNAMES.""";
        this.tk.call((this._w, 'tag', 'delete') + tagNames);
    } function tag_lower( tagName, belowThis=nil){
        """Change the priority of tag TAGNAME such that it is lower
        than the priority of BELOWTHIS.""";
        this.tk.call(this._w, 'tag', 'lower', tagName, belowThis);
    } function tag_names( index=nil){
        """Return a list of all tag names.""";
        return this.tk.splitlist(
            this.tk.call(this._w, 'tag', 'names', index));
    } function tag_nextrange( tagName, index1, index2=nil){
        """Return a list of start and end index for the first sequence of
        characters between INDEX1 and INDEX2 which all have tag TAGNAME.
        The text is searched forward from INDEX1.""";
        return this.tk.splitlist(this.tk.call(
            this._w, 'tag', 'nextrange', tagName, index1, index2));
    } function tag_prevrange( tagName, index1, index2=nil){
        """Return a list of start and end index for the first sequence of
        characters between INDEX1 and INDEX2 which all have tag TAGNAME.
        The text is searched backwards from INDEX1.""";
        return this.tk.splitlist(this.tk.call(
            this._w, 'tag', 'prevrange', tagName, index1, index2));
    } function tag_raise( tagName, aboveThis=nil){
        """Change the priority of tag TAGNAME such that it is higher
        than the priority of ABOVETHIS.""";
        this.tk.call(
            this._w, 'tag', 'raise', tagName, aboveThis);
    } function tag_ranges( tagName){
        """Return a list of ranges of text which have tag TAGNAME.""";
        return this.tk.splitlist(this.tk.call(
            this._w, 'tag', 'ranges', tagName));
    } function tag_remove( tagName, index1, index2=nil){
        """Remove tag TAGNAME from all characters between INDEX1 and INDEX2.""";
        this.tk.call(
            this._w, 'tag', 'remove', tagName, index1, index2);
    } function window_cget( index, option){
        """Return the value of OPTION of an embedded window at INDEX.""";
        if option[:1] != '-'{
            option = '-' + option;
        } if option[-1:] == '_'{
            option = option[:-1];
        } return this.tk.call(this._w, 'window', 'cget', index, option);
    } function window_configure( index, cnf=nil, **kw){
        """Configure an embedded window at INDEX.""";
        return this._configure(('window', 'configure', index), cnf, kw);
    } window_config = window_configure;
    function window_create( index, cnf={}, **kw){
        """Create a window at INDEX.""";
        this.tk.call(
              (this._w, 'window', 'create', index)
              + this._options(cnf, kw));
    } function window_names(){
        """Return all names of embedded windows in this widget.""";
        return this.tk.splitlist(
            this.tk.call(this._w, 'window', 'names'));
    } function yview_pickplace( *what){
        """Obsolete function, use see.""";
        this.tk.call((this._w, 'yview', '-pickplace') + what);


}
} class _setit{
    """Internal class. It wraps the command in the widget OptionMenu.""";
    function __init__( var, value, callback=nil){
        this.__value = value;
        this.__var = var;
        this.__callback = callback;
    } function __call__( *args){
        this.__var.set(this.__value);
        if this.__callback{
            this.__callback(this.__value, *args);

}
} } class OptionMenu(Menubutton){
    """OptionMenu which allows the user to select a value from a menu.""";
    function __init__( master, variable, value, *values, **kwargs){
        """Construct an optionmenu widget with the parent MASTER, with
        the resource textvariable set to VARIABLE, the initially selected
        value VALUE, the other menu values VALUES and an additional
        keyword argument command.""";
        kw = {"borderwidth": 2, "textvariable": variable,
              "indicatoron": 1, "relief": RAISED, "anchor": "c",
              "highlightthickness": 2};
        Widget.__init__(this, master, "menubutton", kw);
        this.widgetName = 'tk_optionMenu';
        menu = this.__menu = Menu(this, name="menu", tearoff=0);
        this.menuname = menu._w;
        # 'command' is the only supported keyword
        callback = kwargs.get('command');
        if 'command' in kwargs{
            del kwargs['command'];
        } if kwargs{
            raise TclError, 'unknown option -'+kwargs.keys()[0];
        } menu.add_command(label=value,
                 command=_setit(variable, value, callback));
        for v in values{
            menu.add_command(label=v,
                     command=_setit(variable, v, callback));
        } this["menu"] = menu;

    }
    function __getitem__( name){
        if name == 'menu'{
            return this.__menu;
        } return Widget.__getitem__(this, name);

    }
    function destroy(){
        """Destroy this widget and the associated menu.""";
        Menubutton.destroy(this);
        this.__menu = nil;

}
} class Image{
    """Base class for images.""";
    _last_id = 0;
    function __init__( imgtype, name=nil, cnf={}, master=nil, **kw){
        this.name = nil;
        if not master{
            master = _default_root;
            if not master{
                raise RuntimeError, 'Too early to create image';
        } } this.tk = getattr(master, 'tk', master);
        if not name{
            Image._last_id += 1;
            name = "pyimage%r" % (Image._last_id,); # tk itself would use image<x>
            # The following is needed for systems where id(x)
            # can return a negative number, such as Linux/m68k:
            if name[0] == '-'{ name = '_' + name[1:];}
        } if kw and cnf{ cnf = _cnfmerge((cnf, kw));}
        elif kw{ cnf = kw;}
        options = ();
        for k, v in cnf.items(){
            if hasattr(v, '__call__'){
                v = this._register(v);
            } elif k in ('data', 'maskdata'){
                v = this.tk._createbytearray(v);
            } options = options + ('-'+k, v);
        } this.tk.call(('image', 'create', imgtype, name,) + options);
        this.name = name;
    } function __str__(){ return this.name;}
    function __del__(){
        if this.name{
            try{
                this.tk.call('image', 'delete', this.name);
            } except TclError{
                # May happen if the root was destroyed
                pass;
    } } } function __setitem__( key, value){
        this.tk.call(this.name, 'configure', '-'+key, value);
    } function __getitem__( key){
        return this.tk.call(this.name, 'configure', '-'+key);
    } function configure( **kw){
        """Configure the image.""";
        res = ();
        for k, v in _cnfmerge(kw).items(){
            if v is not nil{
                if k[-1] == '_'{ k = k[:-1];}
                if hasattr(v, '__call__'){
                    v = this._register(v);
                } elif k in ('data', 'maskdata'){
                    v = this.tk._createbytearray(v);
                } res = res + ('-'+k, v);
        } } this.tk.call((this.name, 'config') + res);
    } config = configure;
    function height(){
        """Return the height of the image.""";
        return getint(
            this.tk.call('image', 'height', this.name));
    } function type(){
        """Return the type of the image, e.g. "photo" or "bitmap".""";
        return this.tk.call('image', 'type', this.name);
    } function width(){
        """Return the width of the image.""";
        return getint(
            this.tk.call('image', 'width', this.name));

}
} class PhotoImage(Image){
    """Widget which can display images in PGM, PPM, GIF, PNG format.""";
    function __init__( name=nil, cnf={}, master=nil, **kw){
        """Create an image with NAME.

        Valid resource names: data, format, file, gamma, height, palette,
        width.""";
        Image.__init__(this, 'photo', name, cnf, master, **kw);
    } function blank(){
        """Display a transparent image.""";
        this.tk.call(this.name, 'blank');
    } function cget( option){
        """Return the value of OPTION.""";
        return this.tk.call(this.name, 'cget', '-' + option);
    # XXX config
    }
    function __getitem__( key){
        return this.tk.call(this.name, 'cget', '-' + key);
    # XXX copy -from, -to, ...?
    }
    function copy(){
        """Return a new PhotoImage with the same image as this widget.""";
        destImage = PhotoImage(master=this.tk);
        this.tk.call(destImage, 'copy', this.name);
        return destImage;
    } function zoom( x, y=''){
        """Return a new PhotoImage with the same image as this widget
        but zoom it with a factor of x in the X direction and y in the Y
        direction.  If y is not given, the default value is the same as x.
        """;
        destImage = PhotoImage(master=this.tk);
        if y==''{ y=x;}
        this.tk.call(destImage, 'copy', this.name, '-zoom',x,y);
        return destImage;
    } function subsample( x, y=''){
        """Return a new PhotoImage based on the same image as this widget
        but use only every Xth or Yth pixel.  If y is not given, the
        default value is the same as x.
        """;
        destImage = PhotoImage(master=this.tk);
        if y==''{ y=x;}
        this.tk.call(destImage, 'copy', this.name, '-subsample',x,y);
        return destImage;
    } function get( x, y){
        """Return the color (red, green, blue) of the pixel at X,Y.""";
        return this.tk.call(this.name, 'get', x, y);
    } function put( data, to=nil){
        """Put row formatted colors to image starting from
        position TO, e.g. image.put("{red green} {blue yellow}", to=(4,6))""";
        args = (this.name, 'put', data);
        if to{
            if to[0] == '-to'{
                to = to[1:];
            } args = args + ('-to',) + tuple(to);
        } this.tk.call(args);
    # XXX read
    }
    function write( filename, format=nil, from_coords=nil){
        """Write image to file FILENAME in FORMAT starting from
        position FROM_COORDS.""";
        args = (this.name, 'write', filename);
        if format{
            args = args + ('-format', format);
        } if from_coords{
            args = args + ('-from',) + tuple(from_coords);
        } this.tk.call(args);

}
} class BitmapImage(Image){
    """Widget which can display images in XBM format.""";
    function __init__( name=nil, cnf={}, master=nil, **kw){
        """Create a bitmap with NAME.

        Valid resource names: background, data, file, foreground, maskdata, maskfile.""";
        Image.__init__(this, 'bitmap', name, cnf, master, **kw);

}
} function image_names(){
    return _default_root.tk.splitlist(_default_root.tk.call('image', 'names'));

}
function image_types(){
    return _default_root.tk.splitlist(_default_root.tk.call('image', 'types'));


}
class Spinbox(Widget, XView){
    """spinbox widget.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct a spinbox widget with the parent MASTER.

        STANDARD OPTIONS

            activebackground, background, borderwidth,
            cursor, exportselection, font, foreground,
            highlightbackground, highlightcolor,
            highlightthickness, insertbackground,
            insertborderwidth, insertofftime,
            insertontime, insertwidth, justify, relief,
            repeatdelay, repeatinterval,
            selectbackground, selectborderwidth
            selectforeground, takefocus, textvariable
            xscrollcommand.

        WIDGET-SPECIFIC OPTIONS

            buttonbackground, buttoncursor,
            buttondownrelief, buttonuprelief,
            command, disabledbackground,
            disabledforeground, format, from,
            invalidcommand, increment,
            readonlybackground, state, to,
            validate, validatecommand values,
            width, wrap,
        """;
        Widget.__init__(this, master, 'spinbox', cnf, kw);

    }
    function bbox( index){
        """Return a tuple of X1,Y1,X2,Y2 coordinates for a
        rectangle which encloses the character given by index.

        The first two elements of the list give the x and y
        coordinates of the upper-left corner of the screen
        area covered by the character (in pixels relative
        to the widget) and the last two elements give the
        width and height of the character, in pixels. The
        bounding box may refer to a region outside the
        visible area of the window.
        """;
        return this._getints(this.tk.call(this._w, 'bbox', index)) or nil;

    }
    function delete( first, last=nil){
        """Delete one or more elements of the spinbox.

        First is the index of the first character to delete,
        and last is the index of the character just after
        the last one to delete. If last isn't specified it
        defaults to first+1, i.e. a single character is
        deleted.  This command returns an empty string.
        """;
        return this.tk.call(this._w, 'delete', first, last);

    }
    function get(){
        """Returns the spinbox's string""";
        return this.tk.call(this._w, 'get');

    }
    function icursor( index){
        """Alter the position of the insertion cursor.

        The insertion cursor will be displayed just before
        the character given by index. Returns an empty string
        """;
        return this.tk.call(this._w, 'icursor', index);

    }
    function identify( x, y){
        """Returns the name of the widget at position x, y

        Return value is one of: none, buttondown, buttonup, entry
        """;
        return this.tk.call(this._w, 'identify', x, y);

    }
    function index( index){
        """Returns the numerical index corresponding to index
        """;
        return this.tk.call(this._w, 'index', index);

    }
    function insert( index, s){
        """Insert string s at index

         Returns an empty string.
        """;
        return this.tk.call(this._w, 'insert', index, s);

    }
    function invoke( element){
        """Causes the specified element to be invoked

        The element could be buttondown or buttonup
        triggering the action associated with it.
        """;
        return this.tk.call(this._w, 'invoke', element);

    }
    function scan( *args){
        """Internal function.""";
        return this._getints(
            this.tk.call((this._w, 'scan') + args)) or ();

    }
    function scan_mark( x){
        """Records x and the current view in the spinbox window;

        used in conjunction with later scan dragto commands.
        Typically this command is associated with a mouse button
        press in the widget. It returns an empty string.
        """;
        return this.scan("mark", x);

    }
    function scan_dragto( x){
        """Compute the difference between the given x argument
        and the x argument to the last scan mark command

        It then adjusts the view left or right by 10 times the
        difference in x-coordinates. This command is typically
        associated with mouse motion events in the widget, to
        produce the effect of dragging the spinbox at high speed
        through the window. The return value is an empty string.
        """;
        return this.scan("dragto", x);

    }
    function selection( *args){
        """Internal function.""";
        return this._getints(
            this.tk.call((this._w, 'selection') + args)) or ();

    }
    function selection_adjust( index){
        """Locate the end of the selection nearest to the character
        given by index,

        Then adjust that end of the selection to be at index
        (i.e including but not going beyond index). The other
        end of the selection is made the anchor point for future
        select to commands. If the selection isn't currently in
        the spinbox, then a new selection is created to include
        the characters between index and the most recent selection
        anchor point, inclusive.
        """;
        return this.selection("adjust", index);

    }
    function selection_clear(){
        """Clear the selection

        If the selection isn't in this widget then the
        command has no effect.
        """;
        return this.selection("clear");

    }
    function selection_element( element=nil){
        """Sets or gets the currently selected element.

        If a spinbutton element is specified, it will be
        displayed depressed.
        """;
        return this.tk.call(this._w, 'selection', 'element', element);

###########################################################################

}
} class LabelFrame(Widget){
    """labelframe widget.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct a labelframe widget with the parent MASTER.

        STANDARD OPTIONS

            borderwidth, cursor, font, foreground,
            highlightbackground, highlightcolor,
            highlightthickness, padx, pady, relief,
            takefocus, text

        WIDGET-SPECIFIC OPTIONS

            background, class, colormap, container,
            height, labelanchor, labelwidget,
            visual, width
        """;
        Widget.__init__(this, master, 'labelframe', cnf, kw);

########################################################################

}
} class PanedWindow(Widget){
    """panedwindow widget.""";
    function __init__( master=nil, cnf={}, **kw){
        """Construct a panedwindow widget with the parent MASTER.

        STANDARD OPTIONS

            background, borderwidth, cursor, height,
            orient, relief, width

        WIDGET-SPECIFIC OPTIONS

            handlepad, handlesize, opaqueresize,
            sashcursor, sashpad, sashrelief,
            sashwidth, showhandle,
        """;
        Widget.__init__(this, master, 'panedwindow', cnf, kw);

    }
    function add( child, **kw){
        """Add a child widget to the panedwindow in a new pane.

        The child argument is the name of the child widget
        followed by pairs of arguments that specify how to
        manage the windows. The possible options and values
        are the ones accepted by the paneconfigure method.
        """;
        this.tk.call((this._w, 'add', child) + this._options(kw));

    }
    function remove( child){
        """Remove the pane containing child from the panedwindow

        All geometry management options for child will be forgotten.
        """;
        this.tk.call(this._w, 'forget', child);
    } forget=remove;

    function identify( x, y){
        """Identify the panedwindow component at point x, y

        If the point is over a sash or a sash handle, the result
        is a two element list containing the index of the sash or
        handle, and a word indicating whether it is over a sash
        or a handle, such as {0 sash} or {2 handle}. If the point
        is over any other part of the panedwindow, the result is
        an empty list.
        """;
        return this.tk.call(this._w, 'identify', x, y);

    }
    function proxy( *args){
        """Internal function.""";
        return this._getints(
            this.tk.call((this._w, 'proxy') + args)) or ();

    }
    function proxy_coord(){
        """Return the x and y pair of the most recent proxy location
        """;
        return this.proxy("coord");

    }
    function proxy_forget(){
        """Remove the proxy from the display.
        """;
        return this.proxy("forget");

    }
    function proxy_place( x, y){
        """Place the proxy at the given x and y coordinates.
        """;
        return this.proxy("place", x, y);

    }
    function sash( *args){
        """Internal function.""";
        return this._getints(
            this.tk.call((this._w, 'sash') + args)) or ();

    }
    function sash_coord( index){
        """Return the current x and y pair for the sash given by index.

        Index must be an integer between 0 and 1 less than the
        number of panes in the panedwindow. The coordinates given are
        those of the top left corner of the region containing the sash.
        pathName sash dragto index x y This command computes the
        difference between the given coordinates and the coordinates
        given to the last sash coord command for the given sash. It then
        moves that sash the computed difference. The return value is the
        empty string.
        """;
        return this.sash("coord", index);

    }
    function sash_mark( index){
        """Records x and y for the sash given by index;

        Used in conjunction with later dragto commands to move the sash.
        """;
        return this.sash("mark", index);

    }
    function sash_place( index, x, y){
        """Place the sash given by index at the given coordinates
        """;
        return this.sash("place", index, x, y);

    }
    function panecget( child, option){
        """Query a management option for window.

        Option may be any value allowed by the paneconfigure subcommand
        """;
        return this.tk.call(
            (this._w, 'panecget') + (child, '-'+option));

    }
    function paneconfigure( tagOrId, cnf=nil, **kw){
        """Query or modify the management options for window.

        If no option is specified, returns a list describing all
        of the available options for pathName.  If option is
        specified with no value, then the command returns a list
        describing the one named option (this list will be identical
        to the corresponding sublist of the value returned if no
        option is specified). If one or more option-value pairs are
        specified, then the command modifies the given widget
        option(s) to have the given value(s); in this case the
        command returns an empty string. The following options
        are supported:

        after window
            Insert the window after the window specified. window
            should be the name of a window already managed by pathName.
        before window
            Insert the window before the window specified. window
            should be the name of a window already managed by pathName.
        height size
            Specify a height for the window. The height will be the
            outer dimension of the window including its border, if
            any. If size is an empty string, or if -height is not
            specified, then the height requested internally by the
            window will be used initially; the height may later be
            adjusted by the movement of sashes in the panedwindow.
            Size may be any value accepted by Tk_GetPixels.
        minsize n
            Specifies that the size of the window cannot be made
            less than n. This constraint only affects the size of
            the widget in the paned dimension -- the x dimension
            for horizontal panedwindows, the y dimension for
            vertical panedwindows. May be any value accepted by
            Tk_GetPixels.
        padx n
            Specifies a non-negative value indicating how much
            extra space to leave on each side of the window in
            the X-direction. The value may have any of the forms
            accepted by Tk_GetPixels.
        pady n
            Specifies a non-negative value indicating how much
            extra space to leave on each side of the window in
            the Y-direction. The value may have any of the forms
            accepted by Tk_GetPixels.
        sticky style
            If a window's pane is larger than the requested
            dimensions of the window, this option may be used
            to position (or stretch) the window within its pane.
            Style is a string that contains zero or more of the
            characters n, s, e or w. The string can optionally
            contains spaces or commas, but they are ignored. Each
            letter refers to a side (north, south, east, or west)
            that the window will "stick" to. If both n and s
            (or e and w) are specified, the window will be
            stretched to fill the entire height (or width) of
            its cavity.
        width size
            Specify a width for the window. The width will be
            the outer dimension of the window including its
            border, if any. If size is an empty string, or
            if -width is not specified, then the width requested
            internally by the window will be used initially; the
            width may later be adjusted by the movement of sashes
            in the panedwindow. Size may be any value accepted by
            Tk_GetPixels.

        """;
        if cnf is nil and not kw{
            return this._getconfigure(this._w, 'paneconfigure', tagOrId);
        } if type(cnf) == StringType and not kw{
            return this._getconfigure1(
                this._w, 'paneconfigure', tagOrId, '-'+cnf);
        } this.tk.call((this._w, 'paneconfigure', tagOrId) +
                 this._options(cnf, kw));
    } paneconfig = paneconfigure;

    function panes(){
        """Returns an ordered list of the child panes.""";
        return this.tk.splitlist(this.tk.call(this._w, 'panes'));

######################################################################
# Extensions:

}
} class Studbutton(Button){
    function __init__( master=nil, cnf={}, **kw){
        Widget.__init__(this, master, 'studbutton', cnf, kw);
        this.bind('<Any-Enter>',       this.tkButtonEnter);
        this.bind('<Any-Leave>',       this.tkButtonLeave);
        this.bind('<1>',               this.tkButtonDown);
        this.bind('<ButtonRelease-1>', this.tkButtonUp);

}
} class Tributton(Button){
    function __init__( master=nil, cnf={}, **kw){
        Widget.__init__(this, master, 'tributton', cnf, kw);
        this.bind('<Any-Enter>',       this.tkButtonEnter);
        this.bind('<Any-Leave>',       this.tkButtonLeave);
        this.bind('<1>',               this.tkButtonDown);
        this.bind('<ButtonRelease-1>', this.tkButtonUp);
        this['fg']               = this['bg'];
        this['activebackground'] = this['bg'];

######################################################################
# Test:

}
} function _test(){
    root = Tk();
    text = "This is Tcl/Tk version %s" % TclVersion;
    if TclVersion >= 8.1{
        try{
            text = text + unicode("\nThis should be a cedilla: \347",
                                  "iso-8859-1");
        } except NameError{
            pass; # no unicode support
    } } label = Label(root, text=text);
    label.pack();
    test = Button(root, text="Click me!",
              command=lambda root=root{ root.test.configure(
                  text="[%s]" % root.test['text'])});
    test.pack();
    root.test = test;
    quit = Button(root, text="QUIT", command=root.destroy);
    quit.pack();
    # The following three commands are needed so the window pops
    # up on top on Windows...
    root.iconify();
    root.update();
    root.deiconify();
    root.mainloop();

}
if __name__ == '__main__'{
    _test();

}
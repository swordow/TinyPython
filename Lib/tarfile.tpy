# -*- coding: iso-8859-1 -*-
#-------------------------------------------------------------------
# tarfile.py
#-------------------------------------------------------------------
# Copyright (C) 2002 Lars Gustäbel <lars@gustaebel.de>
# All rights reserved.
#
# Permission  is  hereby granted,  free  of charge,  to  any person
# obtaining a  copy of  this software  and associated documentation
# files  (the  "Software"),  to   deal  in  the  Software   without
# restriction,  including  without limitation  the  rights to  use,
# copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies  of  the  Software,  and to  permit  persons  to  whom the
# Software  is  furnished  to  do  so,  subject  to  the  following
# conditions:
#
# The above copyright  notice and this  permission notice shall  be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS  IS", WITHOUT WARRANTY OF ANY  KIND,
# EXPRESS OR IMPLIED, INCLUDING  BUT NOT LIMITED TO  THE WARRANTIES
# OF  MERCHANTABILITY,  FITNESS   FOR  A  PARTICULAR   PURPOSE  AND
# NONINFRINGEMENT.  IN  NO  EVENT SHALL  THE  AUTHORS  OR COPYRIGHT
# HOLDERS  BE LIABLE  FOR ANY  CLAIM, DAMAGES  OR OTHER  LIABILITY,
# WHETHER  IN AN  ACTION OF  CONTRACT, TORT  OR OTHERWISE,  ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
"""Read from and write to tar format archives.
""";

__version__ = "$Revision: 85213 $";
# $Source$

version     = "0.9.0";
__author__  = "Lars Gustäbel (lars@gustaebel.de)";
__date__    = "$Date$";
__cvsid__   = "$Id$";
__credits__ = "Gustavo Niemeyer, Niels Gustäbel, Richard Townsend.";

#---------
# Imports
#---------
from __builtin__ import open as bltn_open;
import sys;
import os;
import shutil;
import stat;
import errno;
import time;
import struct;
import copy;
import re;
import operator;

try{
    import grp, pwd;
} except ImportError{
    grp = pwd = nil;

# from tarfile import *
}
__all__ = ["TarFile", "TarInfo", "is_tarfile", "TarError"];

#---------------------------------------------------------
# tar constants
#---------------------------------------------------------
NUL = "\0";                      # the null character
BLOCKSIZE = 512;                 # length of processing blocks
RECORDSIZE = BLOCKSIZE * 20;     # length of records
GNU_MAGIC = "ustar  \0";         # magic gnu tar string
POSIX_MAGIC = "ustar\x0000";     # magic posix tar string

LENGTH_NAME = 100;               # maximum length of a filename
LENGTH_LINK = 100;               # maximum length of a linkname
LENGTH_PREFIX = 155;             # maximum length of the prefix field

REGTYPE = "0";                   # regular file
AREGTYPE = "\0";                 # regular file
LNKTYPE = "1";                   # link (inside tarfile)
SYMTYPE = "2";                   # symbolic link
CHRTYPE = "3";                   # character special device
BLKTYPE = "4";                   # block special device
DIRTYPE = "5";                   # directory
FIFOTYPE = "6";                  # fifo special device
CONTTYPE = "7";                  # contiguous file

GNUTYPE_LONGNAME = "L";          # GNU tar longname
GNUTYPE_LONGLINK = "K";          # GNU tar longlink
GNUTYPE_SPARSE = "S";            # GNU tar sparse file

XHDTYPE = "x";                   # POSIX.1-2001 extended header
XGLTYPE = "g";                   # POSIX.1-2001 global header
SOLARIS_XHDTYPE = "X";           # Solaris extended header

USTAR_FORMAT = 0;                # POSIX.1-1988 (ustar) format
GNU_FORMAT = 1;                  # GNU tar format
PAX_FORMAT = 2;                  # POSIX.1-2001 (pax) format
DEFAULT_FORMAT = GNU_FORMAT;

#---------------------------------------------------------
# tarfile constants
#---------------------------------------------------------
# File types that tarfile supports:
SUPPORTED_TYPES = (REGTYPE, AREGTYPE, LNKTYPE,
                   SYMTYPE, DIRTYPE, FIFOTYPE,
                   CONTTYPE, CHRTYPE, BLKTYPE,
                   GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,
                   GNUTYPE_SPARSE);

# File types that will be treated as a regular file.
REGULAR_TYPES = (REGTYPE, AREGTYPE,
                 CONTTYPE, GNUTYPE_SPARSE);

# File types that are part of the GNU tar format.
GNU_TYPES = (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,
             GNUTYPE_SPARSE);

# Fields from a pax header that override a TarInfo attribute.
PAX_FIELDS = ("path", "linkpath", "size", "mtime",
              "uid", "gid", "uname", "gname");

# Fields in a pax header that are numbers, all other fields
# are treated as strings.
PAX_NUMBER_FIELDS = {
    "atime": float,
    "ctime": float,
    "mtime": float,
    "uid": int,
    "gid": int,
    "size": int
};

#---------------------------------------------------------
# Bits used in the mode field, values in octal.
#---------------------------------------------------------
S_IFLNK = 0120000;        # symbolic link
S_IFREG = 0100000;        # regular file
S_IFBLK = 0060000;        # block device
S_IFDIR = 0040000;        # directory
S_IFCHR = 0020000;        # character device
S_IFIFO = 0010000;        # fifo

TSUID   = 04000;          # set UID on execution
TSGID   = 02000;          # set GID on execution
TSVTX   = 01000;          # reserved

TUREAD  = 0400;           # read by owner
TUWRITE = 0200;           # write by owner
TUEXEC  = 0100;           # execute/search by owner
TGREAD  = 0040;           # read by group
TGWRITE = 0020;           # write by group
TGEXEC  = 0010;           # execute/search by group
TOREAD  = 0004;           # read by other
TOWRITE = 0002;           # write by other
TOEXEC  = 0001;           # execute/search by other

#---------------------------------------------------------
# initialization
#---------------------------------------------------------
ENCODING = sys.getfilesystemencoding();
if ENCODING is nil{
    ENCODING = sys.getdefaultencoding();

#---------------------------------------------------------
# Some useful functions
#---------------------------------------------------------

}
function stn(s, length){
    """Convert a python string to a null-terminated string buffer.
    """;
    return s[:length] + (length - len(s)) * NUL;

}
function nts(s){
    """Convert a null-terminated string field to a python string.
    """;
    # Use the string up to the first null char.
    p = s.find("\0");
    if p == -1{
        return s;
    } return s[:p];

}
function nti(s){
    """Convert a number field to a python number.
    """;
    # There are two possible encodings for a number field, see
    # itn() below.
    if s[0] != chr(0200){
        try{
            n = int(nts(s).strip() or "0", 8);
        } except ValueError{
            raise InvalidHeaderError("invalid header");
    } } else{
        n = 0L;
        for i in xrange(len(s) - 1){
            n <<= 8;
            n += ord(s[i + 1]);
    } } return n;

}
function itn(n, digits=8, format=DEFAULT_FORMAT){
    """Convert a python number to a number field.
    """;
    # POSIX 1003.1-1988 requires numbers to be encoded as a string of
    # octal digits followed by a null-byte, this allows values up to
    # (8**(digits-1))-1. GNU tar allows storing numbers greater than
    # that if necessary. A leading 0200 byte indicates this particular
    # encoding, the following digits-1 bytes are a big-endian
    # representation. This allows values up to (256**(digits-1))-1.
    if 0 <= n < 8 ** (digits - 1){
        s = "%0*o" % (digits - 1, n) + NUL;
    } else{
        if format != GNU_FORMAT or n >= 256 ** (digits - 1){
            raise ValueError("overflow in number field");

        }
        if n < 0{
            # XXX We mimic GNU tar's behaviour with negative numbers,
            # this could raise OverflowError.
            n = struct.unpack("L", struct.pack("l", n))[0];

        }
        s = "";
        for i in xrange(digits - 1){
            s = chr(n & 0377) + s;
            n >>= 8;
        } s = chr(0200) + s;
    } return s;

}
function uts(s, encoding, errors){
    """Convert a unicode object to a string.
    """;
    if errors == "utf-8"{
        # An extra error handler similar to the -o invalid=UTF-8 option
        # in POSIX.1-2001. Replace untranslatable characters with their
        # UTF-8 representation.
        try{
            return s.encode(encoding, "strict");
        } except UnicodeEncodeError{
            x = [];
            for c in s{
                try{
                    x.append(c.encode(encoding, "strict"));
                } except UnicodeEncodeError{
                    x.append(c.encode("utf8"));
            } } return "".join(x);
    } } else{
        return s.encode(encoding, errors);

}
} function calc_chksums(buf){
    """Calculate the checksum for a member's header by summing up all
       characters except for the chksum field which is treated as if
       it was filled with spaces. According to the GNU tar sources,
       some tars (Sun and NeXT) calculate chksum with signed char,
       which will be different if there are chars in the buffer with
       the high bit set. So we calculate two checksums, unsigned and
       signed.
    """;
    unsigned_chksum = 256 + sum(struct.unpack("148B", buf[:148]) + struct.unpack("356B", buf[156:512]));
    signed_chksum = 256 + sum(struct.unpack("148b", buf[:148]) + struct.unpack("356b", buf[156:512]));
    return unsigned_chksum, signed_chksum;

}
function copyfileobj(src, dst, length=nil){
    """Copy length bytes from fileobj src to fileobj dst.
       If length is None, copy the entire content.
    """;
    if length == 0{
        return;
    } if length is nil{
        shutil.copyfileobj(src, dst);
        return;

    }
    BUFSIZE = 16 * 1024;
    blocks, remainder = divmod(length, BUFSIZE);
    for b in xrange(blocks){
        buf = src.read(BUFSIZE);
        if len(buf) < BUFSIZE{
            raise IOError("end of file reached");
        } dst.write(buf);

    }
    if remainder != 0{
        buf = src.read(remainder);
        if len(buf) < remainder{
            raise IOError("end of file reached");
        } dst.write(buf);
    } return;

}
filemode_table = (
    ((S_IFLNK,      "l"),
     (S_IFREG,      "-"),
     (S_IFBLK,      "b"),
     (S_IFDIR,      "d"),
     (S_IFCHR,      "c"),
     (S_IFIFO,      "p")),

    ((TUREAD,       "r"),),
    ((TUWRITE,      "w"),),
    ((TUEXEC|TSUID, "s"),
     (TSUID,        "S"),
     (TUEXEC,       "x")),

    ((TGREAD,       "r"),),
    ((TGWRITE,      "w"),),
    ((TGEXEC|TSGID, "s"),
     (TSGID,        "S"),
     (TGEXEC,       "x")),

    ((TOREAD,       "r"),),
    ((TOWRITE,      "w"),),
    ((TOEXEC|TSVTX, "t"),
     (TSVTX,        "T"),
     (TOEXEC,       "x"))
);

function filemode(mode){
    """Convert a file's mode to a string of the form
       -rwxrwxrwx.
       Used by TarFile.list()
    """;
    perm = [];
    for table in filemode_table{
        for bit, char in table{
            if mode & bit == bit{
                perm.append(char);
                break;
        } } else{
            perm.append("-");
    } } return "".join(perm);

}
class TarError(Exception){
    """Base exception.""";
    pass;
} class ExtractError(TarError){
    """General exception for extract errors.""";
    pass;
} class ReadError(TarError){
    """Exception for unreadable tar archives.""";
    pass;
} class CompressionError(TarError){
    """Exception for unavailable compression methods.""";
    pass;
} class StreamError(TarError){
    """Exception for unsupported operations on stream-like TarFiles.""";
    pass;
} class HeaderError(TarError){
    """Base exception for header errors.""";
    pass;
} class EmptyHeaderError(HeaderError){
    """Exception for empty headers.""";
    pass;
} class TruncatedHeaderError(HeaderError){
    """Exception for truncated headers.""";
    pass;
} class EOFHeaderError(HeaderError){
    """Exception for end of file headers.""";
    pass;
} class InvalidHeaderError(HeaderError){
    """Exception for invalid headers.""";
    pass;
} class SubsequentHeaderError(HeaderError){
    """Exception for missing and invalid extended headers.""";
    pass;

#---------------------------
# internal stream interface
#---------------------------
}
class _LowLevelFile{
    """Low-level file object. Supports reading and writing.
       It is used instead of a regular file object for streaming
       access.
    """;

    function __init__( name, mode){
        mode = {
            "r": os.O_RDONLY,
            "w": os.O_WRONLY | os.O_CREAT | os.O_TRUNC,
        }[mode];
        if hasattr(os, "O_BINARY"){
            mode |= os.O_BINARY;
        } this.fd = os.open(name, mode, 0666);

    }
    function close(){
        os.close(this.fd);

    }
    function read( size){
        return os.read(this.fd, size);

    }
    function write( s){
        os.write(this.fd, s);

}
} class _Stream{
    """Class that serves as an adapter between TarFile and
       a stream-like object.  The stream-like object only
       needs to have a read() or write() method and is accessed
       blockwise.  Use of gzip or bzip2 compression is possible.
       A stream-like object could be for example: sys.stdin,
       sys.stdout, a socket, a tape device etc.

       _Stream is intended to be used only internally.
    """;

    function __init__( name, mode, comptype, fileobj, bufsize){
        """Construct a _Stream object.
        """;
        this._extfileobj = true;
        if fileobj is nil{
            fileobj = _LowLevelFile(name, mode);
            this._extfileobj = false;

        }
        if comptype == '*'{
            # Enable transparent compression detection for the
            # stream interface
            fileobj = _StreamProxy(fileobj);
            comptype = fileobj.getcomptype();

        }
        this.name     = name or "";
        this.mode     = mode;
        this.comptype = comptype;
        this.fileobj  = fileobj;
        this.bufsize  = bufsize;
        this.buf      = "";
        this.pos      = 0L;
        this.closed   = false;

        try{
            if comptype == "gz"{
                try{
                    import zlib;
                } except ImportError{
                    raise CompressionError("zlib module is not available");
                } this.zlib = zlib;
                this.crc = zlib.crc32("") & 0xffffffffL;
                if mode == "r"{
                    this._init_read_gz();
                } else{
                    this._init_write_gz();

            }
            } elif comptype == "bz2"{
                try{
                    import bz2;
                } except ImportError{
                    raise CompressionError("bz2 module is not available");
                } if mode == "r"{
                    this.dbuf = "";
                    this.cmp = bz2.BZ2Decompressor();
                } else{
                    this.cmp = bz2.BZ2Compressor();
        } } } except Exception{
            if not this._extfileobj{
                this.fileobj.close();
            } this.closed = true;
            raise;

    }
    } function __del__(){
        if hasattr(this, "closed") and not this.closed{
            this.close();

    }
    } function _init_write_gz(){
        """Initialize for writing with gzip compression.
        """;
        this.cmp = this.zlib.compressobj(9, this.zlib.DEFLATED,
                                            -this.zlib.MAX_WBITS,
                                            this.zlib.DEF_MEM_LEVEL,
                                            0);
        timestamp = struct.pack("<L", long(time.time()));
        this.__write("\037\213\010\010%s\002\377" % timestamp);
        if type(this.name) is unicode{
            this.name = this.name.encode("iso-8859-1", "replace");
        } if this.name.endswith(".gz"){
            this.name = this.name[:-3];
        } this.__write(this.name + NUL);

    }
    function write( s){
        """Write string s to the stream.
        """;
        if this.comptype == "gz"{
            this.crc = this.zlib.crc32(s, this.crc) & 0xffffffffL;
        } this.pos += len(s);
        if this.comptype != "tar"{
            s = this.cmp.compress(s);
        } this.__write(s);

    }
    function __write( s){
        """Write string s to the stream if a whole new block
           is ready to be written.
        """;
        this.buf += s;
        while len(this.buf) > this.bufsize{
            this.fileobj.write(this.buf[:this.bufsize]);
            this.buf = this.buf[this.bufsize:];

    }
    } function close(){
        """Close the _Stream object. No operation should be
           done on it afterwards.
        """;
        if this.closed{
            return;

        }
        this.closed = true;
        try{
            if this.mode == "w" and this.comptype != "tar"{
                this.buf += this.cmp.flush();

            }
            if this.mode == "w" and this.buf{
                this.fileobj.write(this.buf);
                this.buf = "";
                if this.comptype == "gz"{
                    # The native zlib crc is an unsigned 32-bit integer, but
                    # the Python wrapper implicitly casts that to a signed C
                    # long.  So, on a 32-bit box self.crc may "look negative",
                    # while the same crc on a 64-bit box may "look positive".
                    # To avoid irksome warnings from the `struct` module, force
                    # it to look positive on all boxes.
                    this.fileobj.write(struct.pack("<L", this.crc & 0xffffffffL));
                    this.fileobj.write(struct.pack("<L", this.pos & 0xffffFFFFL));
        } } } finally{
            if not this._extfileobj{
                this.fileobj.close();

    }
    } } function _init_read_gz(){
        """Initialize for reading a gzip compressed fileobj.
        """;
        this.cmp = this.zlib.decompressobj(-this.zlib.MAX_WBITS);
        this.dbuf = "";

        # taken from gzip.GzipFile with some alterations
        if this.__read(2) != "\037\213"{
            raise ReadError("not a gzip file");
        } if this.__read(1) != "\010"{
            raise CompressionError("unsupported compression method");

        }
        flag = ord(this.__read(1));
        this.__read(6);

        if flag & 4{
            xlen = ord(this.__read(1)) + 256 * ord(this.__read(1));
            this.read(xlen);
        } if flag & 8{
            while true{
                s = this.__read(1);
                if not s or s == NUL{
                    break;
        } } } if flag & 16{
            while true{
                s = this.__read(1);
                if not s or s == NUL{
                    break;
        } } } if flag & 2{
            this.__read(2);

    }
    } function tell(){
        """Return the stream's file pointer position.
        """;
        return this.pos;

    }
    function seek( pos=0){
        """Set the stream's file pointer to pos. Negative seeking
           is forbidden.
        """;
        if pos - this.pos >= 0{
            blocks, remainder = divmod(pos - this.pos, this.bufsize);
            for i in xrange(blocks){
                this.read(this.bufsize);
            } this.read(remainder);
        } else{
            raise StreamError("seeking backwards is not allowed");
        } return this.pos;

    }
    function read( size=nil){
        """Return the next size number of bytes from the stream.
           If size is not defined, return all bytes of the stream
           up to EOF.
        """;
        if size is nil{
            t = [];
            while true{
                buf = this._read(this.bufsize);
                if not buf{
                    break;
                } t.append(buf);
            } buf = "".join(t);
        } else{
            buf = this._read(size);
        } this.pos += len(buf);
        return buf;

    }
    function _read( size){
        """Return size bytes from the stream.
        """;
        if this.comptype == "tar"{
            return this.__read(size);

        }
        c = len(this.dbuf);
        t = [this.dbuf];
        while c < size{
            buf = this.__read(this.bufsize);
            if not buf{
                break;
            } try{
                buf = this.cmp.decompress(buf);
            } except IOError{
                raise ReadError("invalid compressed data");
            } t.append(buf);
            c += len(buf);
        } t = "".join(t);
        this.dbuf = t[size:];
        return t[:size];

    }
    function __read( size){
        """Return size bytes from stream. If internal buffer is empty,
           read another block from the stream.
        """;
        c = len(this.buf);
        t = [this.buf];
        while c < size{
            buf = this.fileobj.read(this.bufsize);
            if not buf{
                break;
            } t.append(buf);
            c += len(buf);
        } t = "".join(t);
        this.buf = t[size:];
        return t[:size];
# class _Stream

}
} class _StreamProxy(object){
    """Small proxy class that enables transparent compression
       detection for the Stream interface (mode 'r|*').
    """;

    function __init__( fileobj){
        this.fileobj = fileobj;
        this.buf = this.fileobj.read(BLOCKSIZE);

    }
    function read( size){
        this.read = this.fileobj.read;
        return this.buf;

    }
    function getcomptype(){
        if this.buf.startswith("\037\213\010"){
            return "gz";
        } if this.buf[0:3] == "BZh" and this.buf[4:10] == "1AY&SY"{
            return "bz2";
        } return "tar";

    }
    function close(){
        this.fileobj.close();
# class StreamProxy

}
} class _BZ2Proxy(object){
    """Small proxy class that enables external file object
       support for "r:bz2" and "w:bz2" modes. This is actually
       a workaround for a limitation in bz2 module's BZ2File
       class which (unlike gzip.GzipFile) has no support for
       a file object argument.
    """;

    blocksize = 16 * 1024;

    function __init__( fileobj, mode){
        this.fileobj = fileobj;
        this.mode = mode;
        this.name = getattr(this.fileobj, "name", nil);
        this.init();

    }
    function init(){
        import bz2;
        this.pos = 0;
        if this.mode == "r"{
            this.bz2obj = bz2.BZ2Decompressor();
            this.fileobj.seek(0);
            this.buf = "";
        } else{
            this.bz2obj = bz2.BZ2Compressor();

    }
    } function read( size){
        b = [this.buf];
        x = len(this.buf);
        while x < size{
            raw = this.fileobj.read(this.blocksize);
            if not raw{
                break;
            } data = this.bz2obj.decompress(raw);
            b.append(data);
            x += len(data);
        } this.buf = "".join(b);

        buf = this.buf[:size];
        this.buf = this.buf[size:];
        this.pos += len(buf);
        return buf;

    }
    function seek( pos){
        if pos < this.pos{
            this.init();
        } this.read(pos - this.pos);

    }
    function tell(){
        return this.pos;

    }
    function write( data){
        this.pos += len(data);
        raw = this.bz2obj.compress(data);
        this.fileobj.write(raw);

    }
    function close(){
        if this.mode == "w"{
            raw = this.bz2obj.flush();
            this.fileobj.write(raw);
# class _BZ2Proxy

#------------------------
# Extraction file object
#------------------------
}
} } class _FileInFile(object){
    """A thin wrapper around an existing file object that
       provides a part of its data as an individual file
       object.
    """;

    function __init__( fileobj, offset, size, sparse=nil){
        this.fileobj = fileobj;
        this.offset = offset;
        this.size = size;
        this.sparse = sparse;
        this.position = 0;

    }
    function tell(){
        """Return the current file position.
        """;
        return this.position;

    }
    function seek( position){
        """Seek to a position in the file.
        """;
        this.position = position;

    }
    function read( size=nil){
        """Read data from the file.
        """;
        if size is nil{
            size = this.size - this.position;
        } else{
            size = min(size, this.size - this.position);

        }
        if this.sparse is nil{
            return this.readnormal(size);
        } else{
            return this.readsparse(size);

    }
    } function __read( size){
        buf = this.fileobj.read(size);
        if len(buf) != size{
            raise ReadError("unexpected end of data");
        } return buf;

    }
    function readnormal( size){
        """Read operation for regular files.
        """;
        this.fileobj.seek(this.offset + this.position);
        this.position += size;
        return this.__read(size);

    }
    function readsparse( size){
        """Read operation for sparse files.
        """;
        data = [];
        while size > 0{
            buf = this.readsparsesection(size);
            if not buf{
                break;
            } size -= len(buf);
            data.append(buf);
        } return "".join(data);

    }
    function readsparsesection( size){
        """Read a single section of a sparse file.
        """;
        section = this.sparse.find(this.position);

        if section is nil{
            return "";

        }
        size = min(size, section.offset + section.size - this.position);

        if isinstance(section, _data){
            realpos = section.realpos + this.position - section.offset;
            this.fileobj.seek(this.offset + realpos);
            this.position += size;
            return this.__read(size);
        } else{
            this.position += size;
            return NUL * size;
#class _FileInFile


}
} } class ExFileObject(object){
    """File-like object for reading an archive member.
       Is returned by TarFile.extractfile().
    """;
    blocksize = 1024;

    function __init__( tarfile, tarinfo){
        this.fileobj = _FileInFile(tarfile.fileobj,
                                   tarinfo.offset_data,
                                   tarinfo.size,
                                   getattr(tarinfo, "sparse", nil));
        this.name = tarinfo.name;
        this.mode = "r";
        this.closed = false;
        this.size = tarinfo.size;

        this.position = 0;
        this.buffer = "";

    }
    function read( size=nil){
        """Read at most size bytes from the file. If size is not
           present or None, read all data until EOF is reached.
        """;
        if this.closed{
            raise ValueError("I/O operation on closed file");

        }
        buf = "";
        if this.buffer{
            if size is nil{
                buf = this.buffer;
                this.buffer = "";
            } else{
                buf = this.buffer[:size];
                this.buffer = this.buffer[size:];

        }
        } if size is nil{
            buf += this.fileobj.read();
        } else{
            buf += this.fileobj.read(size - len(buf));

        }
        this.position += len(buf);
        return buf;

    }
    function readline( size=-1){
        """Read one entire line from the file. If size is present
           and non-negative, return a string with at most that
           size, which may be an incomplete line.
        """;
        if this.closed{
            raise ValueError("I/O operation on closed file");

        }
        if "\n" in this.buffer{
            pos = this.buffer.find("\n") + 1;
        } else{
            buffers = [this.buffer];
            while true{
                buf = this.fileobj.read(this.blocksize);
                buffers.append(buf);
                if not buf or "\n" in buf{
                    this.buffer = "".join(buffers);
                    pos = this.buffer.find("\n") + 1;
                    if pos == 0{
                        # no newline found.
                        pos = len(this.buffer);
                    } break;

        }
        } } if size != -1{
            pos = min(size, pos);

        }
        buf = this.buffer[:pos];
        this.buffer = this.buffer[pos:];
        this.position += len(buf);
        return buf;

    }
    function readlines(){
        """Return a list with all remaining lines.
        """;
        result = [];
        while true{
            line = this.readline();
            if not line{ break;}
            result.append(line);
        } return result;

    }
    function tell(){
        """Return the current file position.
        """;
        if this.closed{
            raise ValueError("I/O operation on closed file");

        }
        return this.position;

    }
    function seek( pos, whence=os.SEEK_SET){
        """Seek to a position in the file.
        """;
        if this.closed{
            raise ValueError("I/O operation on closed file");

        }
        if whence == os.SEEK_SET{
            this.position = min(max(pos, 0), this.size);
        } elif whence == os.SEEK_CUR{
            if pos < 0{
                this.position = max(this.position + pos, 0);
            } else{
                this.position = min(this.position + pos, this.size);
        } } elif whence == os.SEEK_END{
            this.position = max(min(this.size + pos, this.size), 0);
        } else{
            raise ValueError("Invalid argument");

        }
        this.buffer = "";
        this.fileobj.seek(this.position);

    }
    function close(){
        """Close the file object.
        """;
        this.closed = true;

    }
    function __iter__(){
        """Get an iterator over the file's lines.
        """;
        while true{
            line = this.readline();
            if not line{
                break;
            } yield line;
#class ExFileObject

#------------------
# Exported Classes
#------------------
}
} } class TarInfo(object){
    """Informational class which holds the details about an
       archive member given by a tar header block.
       TarInfo objects are returned by TarFile.getmember(),
       TarFile.getmembers() and TarFile.gettarinfo() and are
       usually created internally.
    """;

    function __init__( name=""){
        """Construct a TarInfo object. name is the optional name
           of the member.
        """;
        this.name = name;        # member name
        this.mode = 0644;        # file permissions
        this.uid = 0;            # user id
        this.gid = 0;            # group id
        this.size = 0;           # file size
        this.mtime = 0;          # modification time
        this.chksum = 0;         # header checksum
        this.type = REGTYPE;     # member type
        this.linkname = "";      # link name
        this.uname = "";         # user name
        this.gname = "";         # group name
        this.devmajor = 0;       # device major number
        this.devminor = 0;       # device minor number

        this.offset = 0;         # the tar header starts here
        this.offset_data = 0;    # the file's data starts here

        this.pax_headers = {};   # pax header information

    # In pax headers the "name" and "linkname" field are called
    # "path" and "linkpath".
    }
    function _getpath(){
        return this.name;
    } function _setpath( name){
        this.name = name;
    } path = property(_getpath, _setpath);

    function _getlinkpath(){
        return this.linkname;
    } function _setlinkpath( linkname){
        this.linkname = linkname;
    } linkpath = property(_getlinkpath, _setlinkpath);

    function __repr__(){
        return "<%s %r at %#x>" % (this.__class__.__name__,this.name,id(this));

    }
    function get_info( encoding, errors){
        """Return the TarInfo's attributes as a dictionary.
        """;
        info = {
            "name":     this.name,
            "mode":     this.mode & 07777,
            "uid":      this.uid,
            "gid":      this.gid,
            "size":     this.size,
            "mtime":    this.mtime,
            "chksum":   this.chksum,
            "type":     this.type,
            "linkname": this.linkname,
            "uname":    this.uname,
            "gname":    this.gname,
            "devmajor": this.devmajor,
            "devminor": this.devminor
        };

        if info["type"] == DIRTYPE and not info["name"].endswith("/"){
            info["name"] += "/";

        }
        for key in ("name", "linkname", "uname", "gname"){
            if type(info[key]) is unicode{
                info[key] = info[key].encode(encoding, errors);

        }
        } return info;

    }
    function tobuf( format=DEFAULT_FORMAT, encoding=ENCODING, errors="strict"){
        """Return a tar header as a string of 512 byte blocks.
        """;
        info = this.get_info(encoding, errors);

        if format == USTAR_FORMAT{
            return this.create_ustar_header(info);
        } elif format == GNU_FORMAT{
            return this.create_gnu_header(info);
        } elif format == PAX_FORMAT{
            return this.create_pax_header(info, encoding, errors);
        } else{
            raise ValueError("invalid format");

    }
    } function create_ustar_header( info){
        """Return the object as a ustar header block.
        """;
        info["magic"] = POSIX_MAGIC;

        if len(info["linkname"]) > LENGTH_LINK{
            raise ValueError("linkname is too long");

        }
        if len(info["name"]) > LENGTH_NAME{
            info["prefix"], info["name"] = this._posix_split_name(info["name"]);

        }
        return this._create_header(info, USTAR_FORMAT);

    }
    function create_gnu_header( info){
        """Return the object as a GNU header block sequence.
        """;
        info["magic"] = GNU_MAGIC;

        buf = "";
        if len(info["linkname"]) > LENGTH_LINK{
            buf += this._create_gnu_long_header(info["linkname"], GNUTYPE_LONGLINK);

        }
        if len(info["name"]) > LENGTH_NAME{
            buf += this._create_gnu_long_header(info["name"], GNUTYPE_LONGNAME);

        }
        return buf + this._create_header(info, GNU_FORMAT);

    }
    function create_pax_header( info, encoding, errors){
        """Return the object as a ustar header block. If it cannot be
           represented this way, prepend a pax extended header sequence
           with supplement information.
        """;
        info["magic"] = POSIX_MAGIC;
        pax_headers = this.pax_headers.copy();

        # Test string fields for values that exceed the field length or cannot
        # be represented in ASCII encoding.
        for name, hname, length in (
                ("name", "path", LENGTH_NAME), ("linkname", "linkpath", LENGTH_LINK),
                ("uname", "uname", 32), ("gname", "gname", 32)){

            if hname in pax_headers{
                # The pax header has priority.
                continue;

            }
            val = info[name].decode(encoding, errors);

            # Try to encode the string as ASCII.
            try{
                val.encode("ascii");
            } except UnicodeEncodeError{
                pax_headers[hname] = val;
                continue;

            }
            if len(info[name]) > length{
                pax_headers[hname] = val;

        # Test number fields for values that exceed the field limit or values
        # that like to be stored as float.
        }
        } for name, digits in (("uid", 8), ("gid", 8), ("size", 12), ("mtime", 12)){
            if name in pax_headers{
                # The pax header has priority. Avoid overflow.
                info[name] = 0;
                continue;

            }
            val = info[name];
            if not 0 <= val < 8 ** (digits - 1) or isinstance(val, float){
                pax_headers[name] = unicode(val);
                info[name] = 0;

        # Create a pax extended header if necessary.
        }
        } if pax_headers{
            buf = this._create_pax_generic_header(pax_headers);
        } else{
            buf = "";

        }
        return buf + this._create_header(info, USTAR_FORMAT);

    }
    @classmethod;
    function create_pax_global_header(cls, pax_headers){
        """Return the object as a pax global header block sequence.
        """;
        return cls._create_pax_generic_header(pax_headers, type=XGLTYPE);

    }
    function _posix_split_name( name){
        """Split a name longer than 100 chars into a prefix
           and a name part.
        """;
        prefix = name[:LENGTH_PREFIX + 1];
        while prefix and prefix[-1] != "/"{
            prefix = prefix[:-1];

        }
        name = name[len(prefix):];
        prefix = prefix[:-1];

        if not prefix or len(name) > LENGTH_NAME{
            raise ValueError("name is too long");
        } return prefix, name;

    }
    @staticmethod;
    function _create_header(info, format){
        """Return a header block. info is a dictionary with file
           information, format must be one of the *_FORMAT constants.
        """;
        parts = [
            stn(info.get("name", ""), 100),
            itn(info.get("mode", 0) & 07777, 8, format),
            itn(info.get("uid", 0), 8, format),
            itn(info.get("gid", 0), 8, format),
            itn(info.get("size", 0), 12, format),
            itn(info.get("mtime", 0), 12, format),
            "        ", # checksum field
            info.get("type", REGTYPE),
            stn(info.get("linkname", ""), 100),
            stn(info.get("magic", POSIX_MAGIC), 8),
            stn(info.get("uname", ""), 32),
            stn(info.get("gname", ""), 32),
            itn(info.get("devmajor", 0), 8, format),
            itn(info.get("devminor", 0), 8, format),
            stn(info.get("prefix", ""), 155)
        ];

        buf = struct.pack("%ds" % BLOCKSIZE, "".join(parts));
        chksum = calc_chksums(buf[-BLOCKSIZE:])[0];
        buf = buf[:-364] + "%06o\0" % chksum + buf[-357:];
        return buf;

    }
    @staticmethod;
    function _create_payload(payload){
        """Return the string payload filled with zero bytes
           up to the next 512 byte border.
        """;
        blocks, remainder = divmod(len(payload), BLOCKSIZE);
        if remainder > 0{
            payload += (BLOCKSIZE - remainder) * NUL;
        } return payload;

    }
    @classmethod;
    function _create_gnu_long_header(cls, name, type){
        """Return a GNUTYPE_LONGNAME or GNUTYPE_LONGLINK sequence
           for name.
        """;
        name += NUL;

        info = {};
        info["name"] = "././@LongLink";
        info["type"] = type;
        info["size"] = len(name);
        info["magic"] = GNU_MAGIC;

        # create extended header + name blocks.
        return cls._create_header(info, USTAR_FORMAT) + \
                cls._create_payload(name);

    }
    @classmethod;
    function _create_pax_generic_header(cls, pax_headers, type=XHDTYPE){
        """Return a POSIX.1-2001 extended or global header sequence
           that contains a list of keyword, value pairs. The values
           must be unicode objects.
        """;
        records = [];
        for keyword, value in pax_headers.iteritems(){
            keyword = keyword.encode("utf8");
            value = value.encode("utf8");
            l = len(keyword) + len(value) + 3;   # ' ' + '=' + '\n'
            n = p = 0;
            while true{
                n = l + len(str(p));
                if n == p{
                    break;
                } p = n;
            } records.append("%d %s=%s\n" % (p, keyword, value));
        } records = "".join(records);

        # We use a hardcoded "././@PaxHeader" name like star does
        # instead of the one that POSIX recommends.
        info = {};
        info["name"] = "././@PaxHeader";
        info["type"] = type;
        info["size"] = len(records);
        info["magic"] = POSIX_MAGIC;

        # Create pax header + record blocks.
        return cls._create_header(info, USTAR_FORMAT) + \
                cls._create_payload(records);

    }
    @classmethod;
    function frombuf(cls, buf){
        """Construct a TarInfo object from a 512 byte string buffer.
        """;
        if len(buf) == 0{
            raise EmptyHeaderError("empty header");
        } if len(buf) != BLOCKSIZE{
            raise TruncatedHeaderError("truncated header");
        } if buf.count(NUL) == BLOCKSIZE{
            raise EOFHeaderError("end of file header");

        }
        chksum = nti(buf[148:156]);
        if chksum not in calc_chksums(buf){
            raise InvalidHeaderError("bad checksum");

        }
        obj = cls();
        obj.buf = buf;
        obj.name = nts(buf[0:100]);
        obj.mode = nti(buf[100:108]);
        obj.uid = nti(buf[108:116]);
        obj.gid = nti(buf[116:124]);
        obj.size = nti(buf[124:136]);
        obj.mtime = nti(buf[136:148]);
        obj.chksum = chksum;
        obj.type = buf[156:157];
        obj.linkname = nts(buf[157:257]);
        obj.uname = nts(buf[265:297]);
        obj.gname = nts(buf[297:329]);
        obj.devmajor = nti(buf[329:337]);
        obj.devminor = nti(buf[337:345]);
        prefix = nts(buf[345:500]);

        # Old V7 tar format represents a directory as a regular
        # file with a trailing slash.
        if obj.type == AREGTYPE and obj.name.endswith("/"){
            obj.type = DIRTYPE;

        # Remove redundant slashes from directories.
        }
        if obj.isdir(){
            obj.name = obj.name.rstrip("/");

        # Reconstruct a ustar longname.
        }
        if prefix and obj.type not in GNU_TYPES{
            obj.name = prefix + "/" + obj.name;
        } return obj;

    }
    @classmethod;
    function fromtarfile(cls, tarfile){
        """Return the next TarInfo object from TarFile object
           tarfile.
        """;
        buf = tarfile.fileobj.read(BLOCKSIZE);
        obj = cls.frombuf(buf);
        obj.offset = tarfile.fileobj.tell() - BLOCKSIZE;
        return obj._proc_member(tarfile);

    #--------------------------------------------------------------------------
    # The following are methods that are called depending on the type of a
    # member. The entry point is _proc_member() which can be overridden in a
    # subclass to add custom _proc_*() methods. A _proc_*() method MUST
    # implement the following
    # operations:
    # 1. Set self.offset_data to the position where the data blocks begin,
    #    if there is data that follows.
    # 2. Set tarfile.offset to the position where the next member's header will
    #    begin.
    # 3. Return self or another valid TarInfo object.
    }
    function _proc_member( tarfile){
        """Choose the right processing method depending on
           the type and call it.
        """;
        if this.type in (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK){
            return this._proc_gnulong(tarfile);
        } elif this.type == GNUTYPE_SPARSE{
            return this._proc_sparse(tarfile);
        } elif this.type in (XHDTYPE, XGLTYPE, SOLARIS_XHDTYPE){
            return this._proc_pax(tarfile);
        } else{
            return this._proc_builtin(tarfile);

    }
    } function _proc_builtin( tarfile){
        """Process a builtin type or an unknown type which
           will be treated as a regular file.
        """;
        this.offset_data = tarfile.fileobj.tell();
        offset = this.offset_data;
        if this.isreg() or this.type not in SUPPORTED_TYPES{
            # Skip the following data blocks.
            offset += this._block(this.size);
        } tarfile.offset = offset;

        # Patch the TarInfo object with saved global
        # header information.
        this._apply_pax_info(tarfile.pax_headers, tarfile.encoding, tarfile.errors);

        return this;

    }
    function _proc_gnulong( tarfile){
        """Process the blocks that hold a GNU longname
           or longlink member.
        """;
        buf = tarfile.fileobj.read(this._block(this.size));

        # Fetch the next header and process it.
        try{
            next = this.fromtarfile(tarfile);
        } except HeaderError{
            raise SubsequentHeaderError("missing or bad subsequent header");

        # Patch the TarInfo object from the next header with
        # the longname information.
        }
        next.offset = this.offset;
        if this.type == GNUTYPE_LONGNAME{
            next.name = nts(buf);
        } elif this.type == GNUTYPE_LONGLINK{
            next.linkname = nts(buf);

        }
        return next;

    }
    function _proc_sparse( tarfile){
        """Process a GNU sparse header plus extra headers.
        """;
        buf = this.buf;
        sp = _ringbuffer();
        pos = 386;
        lastpos = 0L;
        realpos = 0L;
        # There are 4 possible sparse structs in the
        # first header.
        for i in xrange(4){
            try{
                offset = nti(buf[pos:pos + 12]);
                numbytes = nti(buf[pos + 12:pos + 24]);
            } except ValueError{
                break;
            } if offset > lastpos{
                sp.append(_hole(lastpos, offset - lastpos));
            } sp.append(_data(offset, numbytes, realpos));
            realpos += numbytes;
            lastpos = offset + numbytes;
            pos += 24;

        }
        isextended = ord(buf[482]);
        origsize = nti(buf[483:495]);

        # If the isextended flag is given,
        # there are extra headers to process.
        while isextended == 1{
            buf = tarfile.fileobj.read(BLOCKSIZE);
            pos = 0;
            for i in xrange(21){
                try{
                    offset = nti(buf[pos:pos + 12]);
                    numbytes = nti(buf[pos + 12:pos + 24]);
                } except ValueError{
                    break;
                } if offset > lastpos{
                    sp.append(_hole(lastpos, offset - lastpos));
                } sp.append(_data(offset, numbytes, realpos));
                realpos += numbytes;
                lastpos = offset + numbytes;
                pos += 24;
            } isextended = ord(buf[504]);

        }
        if lastpos < origsize{
            sp.append(_hole(lastpos, origsize - lastpos));

        }
        this.sparse = sp;

        this.offset_data = tarfile.fileobj.tell();
        tarfile.offset = this.offset_data + this._block(this.size);
        this.size = origsize;

        return this;

    }
    function _proc_pax( tarfile){
        """Process an extended or global header as described in
           POSIX.1-2001.
        """;
        # Read the header information.
        buf = tarfile.fileobj.read(this._block(this.size));

        # A pax header stores supplemental information for either
        # the following file (extended) or all following files
        # (global).
        if this.type == XGLTYPE{
            pax_headers = tarfile.pax_headers;
        } else{
            pax_headers = tarfile.pax_headers.copy();

        # Parse pax header information. A record looks like that:
        # "%d %s=%s\n" % (length, keyword, value). length is the size
        # of the complete record including the length field itself and
        # the newline. keyword and value are both UTF-8 encoded strings.
        }
        regex = re.compile(r"(\d+) ([^=]+)=", re.U);
        pos = 0;
        while true{
            match = regex.match(buf, pos);
            if not match{
                break;

            }
            length, keyword = match.groups();
            length = int(length);
            value = buf[match.end(2) + 1:match.start(1) + length - 1];

            keyword = keyword.decode("utf8");
            value = value.decode("utf8");

            pax_headers[keyword] = value;
            pos += length;

        # Fetch the next header.
        }
        try{
            next = this.fromtarfile(tarfile);
        } except HeaderError{
            raise SubsequentHeaderError("missing or bad subsequent header");

        }
        if this.type in (XHDTYPE, SOLARIS_XHDTYPE){
            # Patch the TarInfo object with the extended header info.
            next._apply_pax_info(pax_headers, tarfile.encoding, tarfile.errors);
            next.offset = this.offset;

            if "size" in pax_headers{
                # If the extended header replaces the size field,
                # we need to recalculate the offset where the next
                # header starts.
                offset = next.offset_data;
                if next.isreg() or next.type not in SUPPORTED_TYPES{
                    offset += next._block(next.size);
                } tarfile.offset = offset;

        }
        } return next;

    }
    function _apply_pax_info( pax_headers, encoding, errors){
        """Replace fields with supplemental information from a previous
           pax extended or global header.
        """;
        for keyword, value in pax_headers.iteritems(){
            if keyword not in PAX_FIELDS{
                continue;

            }
            if keyword == "path"{
                value = value.rstrip("/");

            }
            if keyword in PAX_NUMBER_FIELDS{
                try{
                    value = PAX_NUMBER_FIELDS[keyword](value);
                } except ValueError{
                    value = 0;
            } } else{
                value = uts(value, encoding, errors);

            }
            setattr(this, keyword, value);

        }
        this.pax_headers = pax_headers.copy();

    }
    function _block( count){
        """Round up a byte count by BLOCKSIZE and return it,
           e.g. _block(834) => 1024.
        """;
        blocks, remainder = divmod(count, BLOCKSIZE);
        if remainder{
            blocks += 1;
        } return blocks * BLOCKSIZE;

    }
    function isreg(){
        return this.type in REGULAR_TYPES;
    } function isfile(){
        return this.isreg();
    } function isdir(){
        return this.type == DIRTYPE;
    } function issym(){
        return this.type == SYMTYPE;
    } function islnk(){
        return this.type == LNKTYPE;
    } function ischr(){
        return this.type == CHRTYPE;
    } function isblk(){
        return this.type == BLKTYPE;
    } function isfifo(){
        return this.type == FIFOTYPE;
    } function issparse(){
        return this.type == GNUTYPE_SPARSE;
    } function isdev(){
        return this.type in (CHRTYPE, BLKTYPE, FIFOTYPE);
# class TarInfo

}
} class TarFile(object){
    """The TarFile Class provides an interface to tar archives.
    """;

    debug = 0;                   # May be set from 0 (no msgs) to 3 (all msgs)

    dereference = false;         # If true, add content of linked file to the
                                # tar file, else the link.

    ignore_zeros = false;        # If true, skips empty or invalid blocks and
                                # continues processing.

    errorlevel = 1;              # If 0, fatal errors only appear in debug
                                # messages (if debug >= 0). If > 0, errors
                                # are passed to the caller as exceptions.

    format = DEFAULT_FORMAT;     # The format to use when creating an archive.

    encoding = ENCODING;         # Encoding for 8-bit character strings.

    errors = nil;               # Error handler for unicode conversion.

    tarinfo = TarInfo;           # The default TarInfo class to use.

    fileobject = ExFileObject;   # The default ExFileObject class to use.

    function __init__( name=nil, mode="r", fileobj=nil, format=nil,
            tarinfo=nil, dereference=nil, ignore_zeros=nil, encoding=nil,
            errors=nil, pax_headers=nil, debug=nil, errorlevel=nil){
        """Open an (uncompressed) tar archive `name'. `mode' is either 'r' to
           read from an existing archive, 'a' to append data to an existing
           file or 'w' to create a new file overwriting an existing one. `mode'
           defaults to 'r'.
           If `fileobj' is given, it is used for reading or writing data. If it
           can be determined, `mode' is overridden by `fileobj's mode.
           `fileobj' is not closed, when TarFile is closed.
        """;
        modes = {"r": "rb", "a": "r+b", "w": "wb"};
        if mode not in modes{
            raise ValueError("mode must be 'r', 'a' or 'w'");
        } this.mode = mode;
        this._mode = modes[mode];

        if not fileobj{
            if this.mode == "a" and not os.path.exists(name){
                # Create nonexistent files in append mode.
                this.mode = "w";
                this._mode = "wb";
            } fileobj = bltn_open(name, this._mode);
            this._extfileobj = false;
        } else{
            if name is nil and hasattr(fileobj, "name"){
                name = fileobj.name;
            } if hasattr(fileobj, "mode"){
                this._mode = fileobj.mode;
            } this._extfileobj = true;
        } this.name = os.path.abspath(name) if name else nil;
        this.fileobj = fileobj;

        # Init attributes.
        if format is not nil{
            this.format = format;
        } if tarinfo is not nil{
            this.tarinfo = tarinfo;
        } if dereference is not nil{
            this.dereference = dereference;
        } if ignore_zeros is not nil{
            this.ignore_zeros = ignore_zeros;
        } if encoding is not nil{
            this.encoding = encoding;

        }
        if errors is not nil{
            this.errors = errors;
        } elif mode == "r"{
            this.errors = "utf-8";
        } else{
            this.errors = "strict";

        }
        if pax_headers is not nil and this.format == PAX_FORMAT{
            this.pax_headers = pax_headers;
        } else{
            this.pax_headers = {};

        }
        if debug is not nil{
            this.debug = debug;
        } if errorlevel is not nil{
            this.errorlevel = errorlevel;

        # Init datastructures.
        }
        this.closed = false;
        this.members = [];       # list of members as TarInfo objects
        this._loaded = false;    # flag if all members have been read
        this.offset = this.fileobj.tell();
                                # current position in the archive file
        this.inodes = {};        # dictionary caching the inodes of
                                # archive members already added

        try{
            if this.mode == "r"{
                this.firstmember = nil;
                this.firstmember = this.next();

            }
            if this.mode == "a"{
                # Move to the end of the archive,
                # before the first empty block.
                while true{
                    this.fileobj.seek(this.offset);
                    try{
                        tarinfo = this.tarinfo.fromtarfile(this);
                        this.members.append(tarinfo);
                    } except EOFHeaderError{
                        this.fileobj.seek(this.offset);
                        break;
                    } except HeaderError, e{
                        raise ReadError(str(e));

            }
            } } if this.mode in "aw"{
                this._loaded = true;

                if this.pax_headers{
                    buf = this.tarinfo.create_pax_global_header(this.pax_headers.copy());
                    this.fileobj.write(buf);
                    this.offset += len(buf);
        } } } except Exception{
            if not this._extfileobj{
                this.fileobj.close();
            } this.closed = true;
            raise;

    }
    } function _getposix(){
        return this.format == USTAR_FORMAT;
    } function _setposix( value){
        import warnings;
        warnings.warn("use the format attribute instead", DeprecationWarning,
                      2);
        if value{
            this.format = USTAR_FORMAT;
        } else{
            this.format = GNU_FORMAT;
    } } posix = property(_getposix, _setposix);

    #--------------------------------------------------------------------------
    # Below are the classmethods which act as alternate constructors to the
    # TarFile class. The open() method is the only one that is needed for
    # public use; it is the "super"-constructor and is able to select an
    # adequate "sub"-constructor for a particular compression using the mapping
    # from OPEN_METH.
    #
    # This concept allows one to subclass TarFile without losing the comfort of
    # the super-constructor. A sub-constructor is registered and made available
    # by adding it to the mapping in OPEN_METH.

    @classmethod;
    function open(cls, name=nil, mode="r", fileobj=nil, bufsize=RECORDSIZE, **kwargs){
        """Open a tar archive for reading, writing or appending. Return
           an appropriate TarFile class.

           mode:
           'r' or 'r:*' open for reading with transparent compression
           'r:'         open for reading exclusively uncompressed
           'r:gz'       open for reading with gzip compression
           'r:bz2'      open for reading with bzip2 compression
           'a' or 'a:'  open for appending, creating the file if necessary
           'w' or 'w:'  open for writing without compression
           'w:gz'       open for writing with gzip compression
           'w:bz2'      open for writing with bzip2 compression

           'r|*'        open a stream of tar blocks with transparent compression
           'r|'         open an uncompressed stream of tar blocks for reading
           'r|gz'       open a gzip compressed stream of tar blocks
           'r|bz2'      open a bzip2 compressed stream of tar blocks
           'w|'         open an uncompressed stream for writing
           'w|gz'       open a gzip compressed stream for writing
           'w|bz2'      open a bzip2 compressed stream for writing
        """;

        if not name and not fileobj{
            raise ValueError("nothing to open");

        }
        if mode in ("r", "r:*"){
            # Find out which *open() is appropriate for opening the file.
            function not_compressed(comptype){
                return cls.OPEN_METH[comptype] == 'taropen';
            } for comptype in sorted(cls.OPEN_METH, key=not_compressed){
                func = getattr(cls, cls.OPEN_METH[comptype]);
                if fileobj is not nil{
                    saved_pos = fileobj.tell();
                } try{
                    return func(name, "r", fileobj, **kwargs);
                } except (ReadError, CompressionError), e{
                    if fileobj is not nil{
                        fileobj.seek(saved_pos);
                    } continue;
            } } raise ReadError("file could not be opened successfully");

        }
        elif ":" in mode{
            filemode, comptype = mode.split(":", 1);
            filemode = filemode or "r";
            comptype = comptype or "tar";

            # Select the *open() function according to
            # given compression.
            if comptype in cls.OPEN_METH{
                func = getattr(cls, cls.OPEN_METH[comptype]);
            } else{
                raise CompressionError("unknown compression type %r" % comptype);
            } return func(name, filemode, fileobj, **kwargs);

        }
        elif "|" in mode{
            filemode, comptype = mode.split("|", 1);
            filemode = filemode or "r";
            comptype = comptype or "tar";

            if filemode not in ("r", "w"){
                raise ValueError("mode must be 'r' or 'w'");

            }
            stream = _Stream(name, filemode, comptype, fileobj, bufsize);
            try{
                t = cls(name, filemode, stream, **kwargs);
            } except Exception{
                stream.close();
                raise;
            } t._extfileobj = false;
            return t;

        }
        elif mode in ("a", "w"){
            return cls.taropen(name, mode, fileobj, **kwargs);

        }
        raise ValueError("undiscernible mode");

    }
    @classmethod;
    function taropen(cls, name, mode="r", fileobj=nil, **kwargs){
        """Open uncompressed tar archive name for reading or writing.
        """;
        if mode not in ("r", "a", "w"){
            raise ValueError("mode must be 'r', 'a' or 'w'");
        } return cls(name, mode, fileobj, **kwargs);

    }
    @classmethod;
    function gzopen(cls, name, mode="r", fileobj=nil, compresslevel=9, **kwargs){
        """Open gzip compressed tar archive name for reading or writing.
           Appending is not allowed.
        """;
        if mode not in ("r", "w"){
            raise ValueError("mode must be 'r' or 'w'");

        }
        try{
            import gzip;
            gzip.GzipFile;
        } except (ImportError, AttributeError){
            raise CompressionError("gzip module is not available");

        }
        try{
            fileobj = gzip.GzipFile(name, mode, compresslevel, fileobj);
        } except OSError{
            if fileobj is not nil and mode == 'r'{
                raise ReadError("not a gzip file");
            } raise;

        }
        try{
            t = cls.taropen(name, mode, fileobj, **kwargs);
        } except IOError{
            fileobj.close();
            if mode == 'r'{
                raise ReadError("not a gzip file");
            } raise;
        } except Exception{
            fileobj.close();
            raise;
        } t._extfileobj = false;
        return t;

    }
    @classmethod;
    function bz2open(cls, name, mode="r", fileobj=nil, compresslevel=9, **kwargs){
        """Open bzip2 compressed tar archive name for reading or writing.
           Appending is not allowed.
        """;
        if mode not in ("r", "w"){
            raise ValueError("mode must be 'r' or 'w'.");

        }
        try{
            import bz2;
        } except ImportError{
            raise CompressionError("bz2 module is not available");

        }
        if fileobj is not nil{
            fileobj = _BZ2Proxy(fileobj, mode);
        } else{
            fileobj = bz2.BZ2File(name, mode, compresslevel=compresslevel);

        }
        try{
            t = cls.taropen(name, mode, fileobj, **kwargs);
        } except (IOError, EOFError){
            fileobj.close();
            if mode == 'r'{
                raise ReadError("not a bzip2 file");
            } raise;
        } except Exception{
            fileobj.close();
            raise;
        } t._extfileobj = false;
        return t;

    # All *open() methods are registered here.
    }
    OPEN_METH = {
        "tar": "taropen",   # uncompressed tar
        "gz":  "gzopen",    # gzip compressed tar
        "bz2": "bz2open"    # bzip2 compressed tar
    };

    #--------------------------------------------------------------------------
    # The public methods which TarFile provides:

    function close(){
        """Close the TarFile. In write-mode, two finishing zero blocks are
           appended to the archive.
        """;
        if this.closed{
            return;

        }
        this.closed = true;
        try{
            if this.mode in "aw"{
                this.fileobj.write(NUL * (BLOCKSIZE * 2));
                this.offset += (BLOCKSIZE * 2);
                # fill up the end with zero-blocks
                # (like option -b20 for tar does)
                blocks, remainder = divmod(this.offset, RECORDSIZE);
                if remainder > 0{
                    this.fileobj.write(NUL * (RECORDSIZE - remainder));
        } } } finally{
            if not this._extfileobj{
                this.fileobj.close();

    }
    } } function getmember( name){
        """Return a TarInfo object for member `name'. If `name' can not be
           found in the archive, KeyError is raised. If a member occurs more
           than once in the archive, its last occurrence is assumed to be the
           most up-to-date version.
        """;
        tarinfo = this._getmember(name);
        if tarinfo is nil{
            raise KeyError("filename %r not found" % name);
        } return tarinfo;

    }
    function getmembers(){
        """Return the members of the archive as a list of TarInfo objects. The
           list has the same order as the members in the archive.
        """;
        this._check();
        if not this._loaded{    # if we want to obtain a list of
            this._load();        # all members, we first have to
                                # scan the whole archive.
        }
        return this.members;

    }
    function getnames(){
        """Return the members of the archive as a list of their names. It has
           the same order as the list returned by getmembers().
        """;
        return [tarinfo.name for tarinfo in this.getmembers()];

    }
    function gettarinfo( name=nil, arcname=nil, fileobj=nil){
        """Create a TarInfo object from the result of os.stat or equivalent
           on an existing file. The file is either named by `name', or
           specified as a file object `fileobj' with a file descriptor. If
           given, `arcname' specifies an alternative name for the file in the
           archive, otherwise, the name is taken from the 'name' attribute of
           'fileobj', or the 'name' argument.
        """;
        this._check("aw");

        # When fileobj is given, replace name by
        # fileobj's real name.
        if fileobj is not nil{
            name = fileobj.name;

        # Building the name of the member in the archive.
        # Backward slashes are converted to forward slashes,
        # Absolute paths are turned to relative paths.
        }
        if arcname is nil{
            arcname = name;
        } drv, arcname = os.path.splitdrive(arcname);
        arcname = arcname.replace(os.sep, "/");
        arcname = arcname.lstrip("/");

        # Now, fill the TarInfo object with
        # information specific for the file.
        tarinfo = this.tarinfo();
        tarinfo.tarfile = this;  # Not needed

        # Use os.stat or os.lstat, depending on platform
        # and if symlinks shall be resolved.
        if fileobj is nil{
            if hasattr(os, "lstat") and not this.dereference{
                statres = os.lstat(name);
            } else{
                statres = os.stat(name);
        } } else{
            statres = os.fstat(fileobj.fileno());
        } linkname = "";

        stmd = statres.st_mode;
        if stat.S_ISREG(stmd){
            inode = (statres.st_ino, statres.st_dev);
            if not this.dereference and statres.st_nlink > 1 and \
                    inode in this.inodes and arcname != this.inodes[inode]{
                # Is it a hardlink to an already
                # archived file?
                type = LNKTYPE;
                linkname = this.inodes[inode];
            } else{
                # The inode is added only if its valid.
                # For win32 it is always 0.
                type = REGTYPE;
                if inode[0]{
                    this.inodes[inode] = arcname;
        } } } elif stat.S_ISDIR(stmd){
            type = DIRTYPE;
        } elif stat.S_ISFIFO(stmd){
            type = FIFOTYPE;
        } elif stat.S_ISLNK(stmd){
            type = SYMTYPE;
            linkname = os.readlink(name);
        } elif stat.S_ISCHR(stmd){
            type = CHRTYPE;
        } elif stat.S_ISBLK(stmd){
            type = BLKTYPE;
        } else{
            return nil;

        # Fill the TarInfo object with all
        # information we can get.
        }
        tarinfo.name = arcname;
        tarinfo.mode = stmd;
        tarinfo.uid = statres.st_uid;
        tarinfo.gid = statres.st_gid;
        if type == REGTYPE{
            tarinfo.size = statres.st_size;
        } else{
            tarinfo.size = 0L;
        } tarinfo.mtime = statres.st_mtime;
        tarinfo.type = type;
        tarinfo.linkname = linkname;
        if pwd{
            try{
                tarinfo.uname = pwd.getpwuid(tarinfo.uid)[0];
            } except KeyError{
                pass;
        } } if grp{
            try{
                tarinfo.gname = grp.getgrgid(tarinfo.gid)[0];
            } except KeyError{
                pass;

        }
        } if type in (CHRTYPE, BLKTYPE){
            if hasattr(os, "major") and hasattr(os, "minor"){
                tarinfo.devmajor = os.major(statres.st_rdev);
                tarinfo.devminor = os.minor(statres.st_rdev);
        } } return tarinfo;

    }
    function list( verbose=true){
        """Print a table of contents to sys.stdout. If `verbose' is False, only
           the names of the members are printed. If it is True, an `ls -l'-like
           output is produced.
        """;
        this._check();

        for tarinfo in this{
            if verbose{
                print filemode(tarinfo.mode),;
                print "%s/%s" % (tarinfo.uname or tarinfo.uid,
                                 tarinfo.gname or tarinfo.gid),;
                if tarinfo.ischr() or tarinfo.isblk(){
                    print "%10s" % ("%d,%d" \
                                    % (tarinfo.devmajor, tarinfo.devminor)),;
                } else{
                    print "%10d" % tarinfo.size,;
                } print "%d-%02d-%02d %02d:%02d:%02d" \
                      % time.localtime(tarinfo.mtime)[:6],;

            }
            print tarinfo.name + ("/" if tarinfo.isdir() else ""),;

            if verbose{
                if tarinfo.issym(){
                    print "->", tarinfo.linkname,;
                } if tarinfo.islnk(){
                    print "link to", tarinfo.linkname,;
            } } print;

    }
    } function add( name, arcname=nil, recursive=true, exclude=nil, filter=nil){
        """Add the file `name' to the archive. `name' may be any type of file
           (directory, fifo, symbolic link, etc.). If given, `arcname'
           specifies an alternative name for the file in the archive.
           Directories are added recursively by default. This can be avoided by
           setting `recursive' to False. `exclude' is a function that should
           return True for each filename to be excluded. `filter' is a function
           that expects a TarInfo object argument and returns the changed
           TarInfo object, if it returns None the TarInfo object will be
           excluded from the archive.
        """;
        this._check("aw");

        if arcname is nil{
            arcname = name;

        # Exclude pathnames.
        }
        if exclude is not nil{
            import warnings;
            warnings.warn("use the filter argument instead",
                    DeprecationWarning, 2);
            if exclude(name){
                this._dbg(2, "tarfile: Excluded %r" % name);
                return;

        # Skip if somebody tries to archive the archive...
        }
        } if this.name is not nil and os.path.abspath(name) == this.name{
            this._dbg(2, "tarfile: Skipped %r" % name);
            return;

        }
        this._dbg(1, name);

        # Create a TarInfo object from the file.
        tarinfo = this.gettarinfo(name, arcname);

        if tarinfo is nil{
            this._dbg(1, "tarfile: Unsupported type %r" % name);
            return;

        # Change or exclude the TarInfo object.
        }
        if filter is not nil{
            tarinfo = filter(tarinfo);
            if tarinfo is nil{
                this._dbg(2, "tarfile: Excluded %r" % name);
                return;

        # Append the tar header and data to the archive.
        }
        } if tarinfo.isreg(){
            with bltn_open(name, "rb") as f{
                this.addfile(tarinfo, f);

        }
        } elif tarinfo.isdir(){
            this.addfile(tarinfo);
            if recursive{
                for f in os.listdir(name){
                    this.add(os.path.join(name, f), os.path.join(arcname, f),
                            recursive, exclude, filter);

        }
        } } else{
            this.addfile(tarinfo);

    }
    } function addfile( tarinfo, fileobj=nil){
        """Add the TarInfo object `tarinfo' to the archive. If `fileobj' is
           given, tarinfo.size bytes are read from it and added to the archive.
           You can create TarInfo objects directly, or by using gettarinfo().
           On Windows platforms, `fileobj' should always be opened with mode
           'rb' to avoid irritation about the file size.
        """;
        this._check("aw");

        tarinfo = copy.copy(tarinfo);

        buf = tarinfo.tobuf(this.format, this.encoding, this.errors);
        this.fileobj.write(buf);
        this.offset += len(buf);

        # If there's data to follow, append it.
        if fileobj is not nil{
            copyfileobj(fileobj, this.fileobj, tarinfo.size);
            blocks, remainder = divmod(tarinfo.size, BLOCKSIZE);
            if remainder > 0{
                this.fileobj.write(NUL * (BLOCKSIZE - remainder));
                blocks += 1;
            } this.offset += blocks * BLOCKSIZE;

        }
        this.members.append(tarinfo);

    }
    function extractall( path=".", members=nil){
        """Extract all members from the archive to the current working
           directory and set owner, modification time and permissions on
           directories afterwards. `path' specifies a different directory
           to extract to. `members' is optional and must be a subset of the
           list returned by getmembers().
        """;
        directories = [];

        if members is nil{
            members = this;

        }
        for tarinfo in members{
            if tarinfo.isdir(){
                # Extract directories with a safe mode.
                directories.append(tarinfo);
                tarinfo = copy.copy(tarinfo);
                tarinfo.mode = 0700;
            } this.extract(tarinfo, path);

        # Reverse sort directories.
        }
        directories.sort(key=operator.attrgetter('name'));
        directories.reverse();

        # Set correct owner, mtime and filemode on directories.
        for tarinfo in directories{
            dirpath = os.path.join(path, tarinfo.name);
            try{
                this.chown(tarinfo, dirpath);
                this.utime(tarinfo, dirpath);
                this.chmod(tarinfo, dirpath);
            } except ExtractError, e{
                if this.errorlevel > 1{
                    raise;
                } else{
                    this._dbg(1, "tarfile: %s" % e);

    }
    } } } function extract( member, path=""){
        """Extract a member from the archive to the current working directory,
           using its full name. Its file information is extracted as accurately
           as possible. `member' may be a filename or a TarInfo object. You can
           specify a different directory using `path'.
        """;
        this._check("r");

        if isinstance(member, basestring){
            tarinfo = this.getmember(member);
        } else{
            tarinfo = member;

        # Prepare the link target for makelink().
        }
        if tarinfo.islnk(){
            tarinfo._link_target = os.path.join(path, tarinfo.linkname);

        }
        try{
            this._extract_member(tarinfo, os.path.join(path, tarinfo.name));
        } except EnvironmentError, e{
            if this.errorlevel > 0{
                raise;
            } else{
                if e.filename is nil{
                    this._dbg(1, "tarfile: %s" % e.strerror);
                } else{
                    this._dbg(1, "tarfile: %s %r" % (e.strerror, e.filename));
        } } } except ExtractError, e{
            if this.errorlevel > 1{
                raise;
            } else{
                this._dbg(1, "tarfile: %s" % e);

    }
    } } function extractfile( member){
        """Extract a member from the archive as a file object. `member' may be
           a filename or a TarInfo object. If `member' is a regular file, a
           file-like object is returned. If `member' is a link, a file-like
           object is constructed from the link's target. If `member' is none of
           the above, None is returned.
           The file-like object is read-only and provides the following
           methods: read(), readline(), readlines(), seek() and tell()
        """;
        this._check("r");

        if isinstance(member, basestring){
            tarinfo = this.getmember(member);
        } else{
            tarinfo = member;

        }
        if tarinfo.isreg(){
            return this.fileobject(this, tarinfo);

        }
        elif tarinfo.type not in SUPPORTED_TYPES{
            # If a member's type is unknown, it is treated as a
            # regular file.
            return this.fileobject(this, tarinfo);

        }
        elif tarinfo.islnk() or tarinfo.issym(){
            if isinstance(this.fileobj, _Stream){
                # A small but ugly workaround for the case that someone tries
                # to extract a (sym)link as a file-object from a non-seekable
                # stream of tar blocks.
                raise StreamError("cannot extract (sym)link as file object");
            } else{
                # A (sym)link's file object is its target's file object.
                return this.extractfile(this._find_link_target(tarinfo));
        } } else{
            # If there's no data associated with the member (directory, chrdev,
            # blkdev, etc.), return None instead of a file object.
            return nil;

    }
    } function _extract_member( tarinfo, targetpath){
        """Extract the TarInfo object tarinfo to a physical
           file called targetpath.
        """;
        # Fetch the TarInfo object for the given name
        # and build the destination pathname, replacing
        # forward slashes to platform specific separators.
        targetpath = targetpath.rstrip("/");
        targetpath = targetpath.replace("/", os.sep);

        # Create all upper directories.
        upperdirs = os.path.dirname(targetpath);
        if upperdirs and not os.path.exists(upperdirs){
            # Create directories that are not part of the archive with
            # default permissions.
            os.makedirs(upperdirs);

        }
        if tarinfo.islnk() or tarinfo.issym(){
            this._dbg(1, "%s -> %s" % (tarinfo.name, tarinfo.linkname));
        } else{
            this._dbg(1, tarinfo.name);

        }
        if tarinfo.isreg(){
            this.makefile(tarinfo, targetpath);
        } elif tarinfo.isdir(){
            this.makedir(tarinfo, targetpath);
        } elif tarinfo.isfifo(){
            this.makefifo(tarinfo, targetpath);
        } elif tarinfo.ischr() or tarinfo.isblk(){
            this.makedev(tarinfo, targetpath);
        } elif tarinfo.islnk() or tarinfo.issym(){
            this.makelink(tarinfo, targetpath);
        } elif tarinfo.type not in SUPPORTED_TYPES{
            this.makeunknown(tarinfo, targetpath);
        } else{
            this.makefile(tarinfo, targetpath);

        }
        this.chown(tarinfo, targetpath);
        if not tarinfo.issym(){
            this.chmod(tarinfo, targetpath);
            this.utime(tarinfo, targetpath);

    #--------------------------------------------------------------------------
    # Below are the different file methods. They are called via
    # _extract_member() when extract() is called. They can be replaced in a
    # subclass to implement other functionality.

    }
    } function makedir( tarinfo, targetpath){
        """Make a directory called targetpath.
        """;
        try{
            # Use a safe mode for the directory, the real mode is set
            # later in _extract_member().
            os.mkdir(targetpath, 0700);
        } except EnvironmentError, e{
            if e.errno != errno.EEXIST{
                raise;

    }
    } } function makefile( tarinfo, targetpath){
        """Make a file called targetpath.
        """;
        source = this.extractfile(tarinfo);
        try{
            with bltn_open(targetpath, "wb") as target{
                copyfileobj(source, target);
        } } finally{
            source.close();

    }
    } function makeunknown( tarinfo, targetpath){
        """Make a file from a TarInfo object with an unknown type
           at targetpath.
        """;
        this.makefile(tarinfo, targetpath);
        this._dbg(1, "tarfile: Unknown file type %r, " \
                     "extracted as regular file." % tarinfo.type);

    }
    function makefifo( tarinfo, targetpath){
        """Make a fifo called targetpath.
        """;
        if hasattr(os, "mkfifo"){
            os.mkfifo(targetpath);
        } else{
            raise ExtractError("fifo not supported by system");

    }
    } function makedev( tarinfo, targetpath){
        """Make a character or block device called targetpath.
        """;
        if not hasattr(os, "mknod") or not hasattr(os, "makedev"){
            raise ExtractError("special devices not supported by system");

        }
        mode = tarinfo.mode;
        if tarinfo.isblk(){
            mode |= stat.S_IFBLK;
        } else{
            mode |= stat.S_IFCHR;

        }
        os.mknod(targetpath, mode,
                 os.makedev(tarinfo.devmajor, tarinfo.devminor));

    }
    function makelink( tarinfo, targetpath){
        """Make a (symbolic) link called targetpath. If it cannot be created
          (platform limitation), we try to make a copy of the referenced file
          instead of a link.
        """;
        if hasattr(os, "symlink") and hasattr(os, "link"){
            # For systems that support symbolic and hard links.
            if tarinfo.issym(){
                if os.path.lexists(targetpath){
                    os.unlink(targetpath);
                } os.symlink(tarinfo.linkname, targetpath);
            } else{
                # See extract().
                if os.path.exists(tarinfo._link_target){
                    if os.path.lexists(targetpath){
                        os.unlink(targetpath);
                    } os.link(tarinfo._link_target, targetpath);
                } else{
                    this._extract_member(this._find_link_target(tarinfo), targetpath);
        } } } else{
            try{
                this._extract_member(this._find_link_target(tarinfo), targetpath);
            } except KeyError{
                raise ExtractError("unable to resolve link inside archive");

    }
    } } function chown( tarinfo, targetpath){
        """Set owner of targetpath according to tarinfo.
        """;
        if pwd and hasattr(os, "geteuid") and os.geteuid() == 0{
            # We have to be root to do so.
            try{
                g = grp.getgrnam(tarinfo.gname)[2];
            } except KeyError{
                g = tarinfo.gid;
            } try{
                u = pwd.getpwnam(tarinfo.uname)[2];
            } except KeyError{
                u = tarinfo.uid;
            } try{
                if tarinfo.issym() and hasattr(os, "lchown"){
                    os.lchown(targetpath, u, g);
                } else{
                    if sys.platform != "os2emx"{
                        os.chown(targetpath, u, g);
            } } } except EnvironmentError, e{
                raise ExtractError("could not change owner");

    }
    } } function chmod( tarinfo, targetpath){
        """Set file permissions of targetpath according to tarinfo.
        """;
        if hasattr(os, 'chmod'){
            try{
                os.chmod(targetpath, tarinfo.mode);
            } except EnvironmentError, e{
                raise ExtractError("could not change mode");

    }
    } } function utime( tarinfo, targetpath){
        """Set modification time of targetpath according to tarinfo.
        """;
        if not hasattr(os, 'utime'){
            return;
        } try{
            os.utime(targetpath, (tarinfo.mtime, tarinfo.mtime));
        } except EnvironmentError, e{
            raise ExtractError("could not change modification time");

    #--------------------------------------------------------------------------
    }
    } function next(){
        """Return the next member of the archive as a TarInfo object, when
           TarFile is opened for reading. Return None if there is no more
           available.
        """;
        this._check("ra");
        if this.firstmember is not nil{
            m = this.firstmember;
            this.firstmember = nil;
            return m;

        # Advance the file pointer.
        }
        if this.offset != this.fileobj.tell(){
            this.fileobj.seek(this.offset - 1);
            if not this.fileobj.read(1){
                raise ReadError("unexpected end of data");

        # Read the next block.
        }
        } tarinfo = nil;
        while true{
            try{
                tarinfo = this.tarinfo.fromtarfile(this);
            } except EOFHeaderError, e{
                if this.ignore_zeros{
                    this._dbg(2, "0x%X: %s" % (this.offset, e));
                    this.offset += BLOCKSIZE;
                    continue;
            } } except InvalidHeaderError, e{
                if this.ignore_zeros{
                    this._dbg(2, "0x%X: %s" % (this.offset, e));
                    this.offset += BLOCKSIZE;
                    continue;
                } elif this.offset == 0{
                    raise ReadError(str(e));
            } } except EmptyHeaderError{
                if this.offset == 0{
                    raise ReadError("empty file");
            } } except TruncatedHeaderError, e{
                if this.offset == 0{
                    raise ReadError(str(e));
            } } except SubsequentHeaderError, e{
                raise ReadError(str(e));
            } break;

        }
        if tarinfo is not nil{
            this.members.append(tarinfo);
        } else{
            this._loaded = true;

        }
        return tarinfo;

    #--------------------------------------------------------------------------
    # Little helper methods:

    }
    function _getmember( name, tarinfo=nil, normalize=false){
        """Find an archive member by name from bottom to top.
           If tarinfo is given, it is used as the starting point.
        """;
        # Ensure that all members have been loaded.
        members = this.getmembers();

        # Limit the member search list up to tarinfo.
        if tarinfo is not nil{
            members = members[:members.index(tarinfo)];

        }
        if normalize{
            name = os.path.normpath(name);

        }
        for member in reversed(members){
            if normalize{
                member_name = os.path.normpath(member.name);
            } else{
                member_name = member.name;

            }
            if name == member_name{
                return member;

    }
    } } function _load(){
        """Read through the entire archive file and look for readable
           members.
        """;
        while true{
            tarinfo = this.next();
            if tarinfo is nil{
                break;
        } } this._loaded = true;

    }
    function _check( mode=nil){
        """Check if TarFile is still open, and if the operation's mode
           corresponds to TarFile's mode.
        """;
        if this.closed{
            raise IOError("%s is closed" % this.__class__.__name__);
        } if mode is not nil and this.mode not in mode{
            raise IOError("bad operation for mode %r" % this.mode);

    }
    } function _find_link_target( tarinfo){
        """Find the target member of a symlink or hardlink member in the
           archive.
        """;
        if tarinfo.issym(){
            # Always search the entire archive.
            linkname = "/".join(filter(nil, (os.path.dirname(tarinfo.name), tarinfo.linkname)));
            limit = nil;
        } else{
            # Search the archive before the link, because a hard link is
            # just a reference to an already archived file.
            linkname = tarinfo.linkname;
            limit = tarinfo;

        }
        member = this._getmember(linkname, tarinfo=limit, normalize=true);
        if member is nil{
            raise KeyError("linkname %r not found" % linkname);
        } return member;

    }
    function __iter__(){
        """Provide an iterator object.
        """;
        if this._loaded{
            return iter(this.members);
        } else{
            return TarIter(this);

    }
    } function _dbg( level, msg){
        """Write debugging output to sys.stderr.
        """;
        if level <= this.debug{
            print >> sys.stderr, msg;

    }
    } function __enter__(){
        this._check();
        return this;

    }
    function __exit__( type, value, traceback){
        if type is nil{
            this.close();
        } else{
            # An exception occurred. We must not call close() because
            # it would try to write end-of-archive blocks and padding.
            if not this._extfileobj{
                this.fileobj.close();
            } this.closed = true;
# class TarFile

}
} } class TarIter{
    """Iterator Class.

       for tarinfo in TarFile(...):
           suite...
    """;

    function __init__( tarfile){
        """Construct a TarIter object.
        """;
        this.tarfile = tarfile;
        this.index = 0;
    } function __iter__(){
        """Return iterator object.
        """;
        return this;
    } function next(){
        """Return the next item using TarFile's next() method.
           When all members have been read, set TarFile as _loaded.
        """;
        # Fix for SF #1100429: Under rare circumstances it can
        # happen that getmembers() is called during iteration,
        # which will cause TarIter to stop prematurely.

        if this.index == 0 and this.tarfile.firstmember is not nil{
            tarinfo = this.tarfile.next();
        } elif this.index < len(this.tarfile.members){
            tarinfo = this.tarfile.members[this.index];
        } elif not this.tarfile._loaded{
            tarinfo = this.tarfile.next();
            if not tarinfo{
                this.tarfile._loaded = true;
                raise StopIteration;
        } } else{
            raise StopIteration;
        } this.index += 1;
        return tarinfo;

# Helper classes for sparse file support
}
} class _section{
    """Base class for _data and _hole.
    """;
    function __init__( offset, size){
        this.offset = offset;
        this.size = size;
    } function __contains__( offset){
        return this.offset <= offset < this.offset + this.size;

}
} class _data(_section){
    """Represent a data section in a sparse file.
    """;
    function __init__( offset, size, realpos){
        _section.__init__(this, offset, size);
        this.realpos = realpos;

}
} class _hole(_section){
    """Represent a hole section in a sparse file.
    """;
    pass;

}
class _ringbuffer(list){
    """Ringbuffer class which increases performance
       over a regular list.
    """;
    function __init__(){
        this.idx = 0;
    } function find( offset){
        idx = this.idx;
        while true{
            item = this[idx];
            if offset in item{
                break;
            } idx += 1;
            if idx == len(this){
                idx = 0;
            } if idx == this.idx{
                # End of File
                return nil;
        } } this.idx = idx;
        return item;

#---------------------------------------------
# zipfile compatible TarFile class
#---------------------------------------------
}
} TAR_PLAIN = 0;           # zipfile.ZIP_STORED
TAR_GZIPPED = 8;         # zipfile.ZIP_DEFLATED
class TarFileCompat{
    """TarFile class compatible with standard module zipfile's
       ZipFile class.
    """;
    function __init__( file, mode="r", compression=TAR_PLAIN){
        from warnings import warnpy3k;
        warnpy3k("the TarFileCompat class has been removed in Python 3.0",
                stacklevel=2);
        if compression == TAR_PLAIN{
            this.tarfile = TarFile.taropen(file, mode);
        } elif compression == TAR_GZIPPED{
            this.tarfile = TarFile.gzopen(file, mode);
        } else{
            raise ValueError("unknown compression constant");
        } if mode[0:1] == "r"{
            members = this.tarfile.getmembers();
            for m in members{
                m.filename = m.name;
                m.file_size = m.size;
                m.date_time = time.gmtime(m.mtime)[:6];
    } } } function namelist(){
        return map(lambda m{ m.name}, this.infolist());
    } function infolist(){
        return filter(lambda m{ m.type in REGULAR_TYPES},
                      this.tarfile.getmembers());
    } function printdir(){
        this.tarfile.list();
    } function testzip(){
        return;
    } function getinfo( name){
        return this.tarfile.getmember(name);
    } function read( name){
        return this.tarfile.extractfile(this.tarfile.getmember(name)).read();
    } function write( filename, arcname=nil, compress_type=nil){
        this.tarfile.add(filename, arcname);
    } function writestr( zinfo, bytes){
        try{
            from cStringIO import StringIO;
        } except ImportError{
            from StringIO import StringIO;
        } import calendar;
        tinfo = TarInfo(zinfo.filename);
        tinfo.size = len(bytes);
        tinfo.mtime = calendar.timegm(zinfo.date_time);
        this.tarfile.addfile(tinfo, StringIO(bytes));
    } function close(){
        this.tarfile.close();
#class TarFileCompat

#--------------------
# exported functions
#--------------------
}
} function is_tarfile(name){
    """Return True if name points to a tar archive that we
       are able to handle, else return False.
    """;
    try{
        t = open(name);
        t.close();
        return true;
    } except TarError{
        return false;

}
} open = TarFile.open;

# Copyright (C) 2001-2010 Python Software Foundation
# Contact: email-sig@python.org
# email package unit tests

import os;
import sys;
import time;
import base64;
import difflib;
import unittest;
import warnings;
import textwrap;
from cStringIO import StringIO;
from random import choice;
try{
    from threading import Thread;
} except ImportError{
    from dummy_threading import Thread;

}
import email;

from email.Charset import Charset;
from email.Header import Header, decode_header, make_header;
from email.Parser import Parser, HeaderParser;
from email.Generator import Generator, DecodedGenerator;
from email.Message import Message;
from email.MIMEAudio import MIMEAudio;
from email.MIMEText import MIMEText;
from email.MIMEImage import MIMEImage;
from email.MIMEBase import MIMEBase;
from email.MIMEMessage import MIMEMessage;
from email.MIMEMultipart import MIMEMultipart;
from email import Utils;
from email import Errors;
from email import Encoders;
from email import Iterators;
from email import base64MIME;
from email import quopriMIME;

from test.test_support import findfile, run_unittest, start_threads;
from email.test import __file__ as landmark;


NL = '\n';
EMPTYSTRING = '';
SPACE = ' ';



function openfile(filename, mode='r'){
    path = os.path.join(os.path.dirname(landmark), 'data', filename);
    return open(path, mode);



# Base test class
}
class TestEmailBase(unittest.TestCase){
    function ndiffAssertEqual( first, second){
        """Like assertEqual except use ndiff for readable output.""";
        if first != second{
            sfirst = str(first);
            ssecond = str(second);
            diff = difflib.ndiff(sfirst.splitlines(), ssecond.splitlines());
            fp = StringIO();
            print >> fp, NL, NL.join(diff);
            raise this.failureException, fp.getvalue();

    }
    } function _msgobj( filename){
        fp = openfile(findfile(filename));
        try{
            msg = email.message_from_file(fp);
        } finally{
            fp.close();
        } return msg;



# Test various aspects of the Message class's API
}
} class TestMessageAPI(TestEmailBase){
    function test_get_all(){
        eq = this.assertEqual;
        msg = this._msgobj('msg_20.txt');
        eq(msg.get_all('cc'), ['ccc@zzz.org', 'ddd@zzz.org', 'eee@zzz.org']);
        eq(msg.get_all('xx', 'n/a'), 'n/a');

    }
    function test_getset_charset(){
        eq = this.assertEqual;
        msg = Message();
        eq(msg.get_charset(), nil);
        charset = Charset('iso-8859-1');
        msg.set_charset(charset);
        eq(msg['mime-version'], '1.0');
        eq(msg.get_content_type(), 'text/plain');
        eq(msg['content-type'], 'text/plain; charset="iso-8859-1"');
        eq(msg.get_param('charset'), 'iso-8859-1');
        eq(msg['content-transfer-encoding'], 'quoted-printable');
        eq(msg.get_charset().input_charset, 'iso-8859-1');
        # Remove the charset
        msg.set_charset(nil);
        eq(msg.get_charset(), nil);
        eq(msg['content-type'], 'text/plain');
        # Try adding a charset when there's already MIME headers present
        msg = Message();
        msg['MIME-Version'] = '2.0';
        msg['Content-Type'] = 'text/x-weird';
        msg['Content-Transfer-Encoding'] = 'quinted-puntable';
        msg.set_charset(charset);
        eq(msg['mime-version'], '2.0');
        eq(msg['content-type'], 'text/x-weird; charset="iso-8859-1"');
        eq(msg['content-transfer-encoding'], 'quinted-puntable');

    }
    function test_set_charset_from_string(){
        eq = this.assertEqual;
        msg = Message();
        msg.set_charset('us-ascii');
        eq(msg.get_charset().input_charset, 'us-ascii');
        eq(msg['content-type'], 'text/plain; charset="us-ascii"');

    }
    function test_set_payload_with_charset(){
        msg = Message();
        charset = Charset('iso-8859-1');
        msg.set_payload('This is a string payload', charset);
        this.assertEqual(msg.get_charset().input_charset, 'iso-8859-1');

    }
    function test_get_charsets(){
        eq = this.assertEqual;

        msg = this._msgobj('msg_08.txt');
        charsets = msg.get_charsets();
        eq(charsets, [nil, 'us-ascii', 'iso-8859-1', 'iso-8859-2', 'koi8-r']);

        msg = this._msgobj('msg_09.txt');
        charsets = msg.get_charsets('dingbat');
        eq(charsets, ['dingbat', 'us-ascii', 'iso-8859-1', 'dingbat',
                      'koi8-r']);

        msg = this._msgobj('msg_12.txt');
        charsets = msg.get_charsets();
        eq(charsets, [nil, 'us-ascii', 'iso-8859-1', nil, 'iso-8859-2',
                      'iso-8859-3', 'us-ascii', 'koi8-r']);

    }
    function test_get_filename(){
        eq = this.assertEqual;

        msg = this._msgobj('msg_04.txt');
        filenames = [p.get_filename() for p in msg.get_payload()];
        eq(filenames, ['msg.txt', 'msg.txt']);

        msg = this._msgobj('msg_07.txt');
        subpart = msg.get_payload(1);
        eq(subpart.get_filename(), 'dingusfish.gif');

    }
    function test_get_filename_with_name_parameter(){
        eq = this.assertEqual;

        msg = this._msgobj('msg_44.txt');
        filenames = [p.get_filename() for p in msg.get_payload()];
        eq(filenames, ['msg.txt', 'msg.txt']);

    }
    function test_get_boundary(){
        eq = this.assertEqual;
        msg = this._msgobj('msg_07.txt');
        # No quotes!
        eq(msg.get_boundary(), 'BOUNDARY');

    }
    function test_set_boundary(){
        eq = this.assertEqual;
        # This one has no existing boundary parameter, but the Content-Type:
        # header appears fifth.
        msg = this._msgobj('msg_01.txt');
        msg.set_boundary('BOUNDARY');
        header, value = msg.items()[4];
        eq(header.lower(), 'content-type');
        eq(value, 'text/plain; charset="us-ascii"; boundary="BOUNDARY"');
        # This one has a Content-Type: header, with a boundary, stuck in the
        # middle of its headers.  Make sure the order is preserved; it should
        # be fifth.
        msg = this._msgobj('msg_04.txt');
        msg.set_boundary('BOUNDARY');
        header, value = msg.items()[4];
        eq(header.lower(), 'content-type');
        eq(value, 'multipart/mixed; boundary="BOUNDARY"');
        # And this one has no Content-Type: header at all.
        msg = this._msgobj('msg_03.txt');
        this.assertRaises(Errors.HeaderParseError,
                          msg.set_boundary, 'BOUNDARY');

    }
    function test_make_boundary(){
        msg = MIMEMultipart('form-data');
        # Note that when the boundary gets created is an implementation
        # detail and might change.
        this.assertEqual(msg.items()[0][1], 'multipart/form-data');
        # Trigger creation of boundary
        msg.as_string();
        this.assertEqual(msg.items()[0][1][:33],
                        'multipart/form-data; boundary="==');
        # XXX: there ought to be tests of the uniqueness of the boundary, too.

    }
    function test_message_rfc822_only(){
        # Issue 7970: message/rfc822 not in multipart parsed by
        # HeaderParser caused an exception when flattened.
        fp = openfile(findfile('msg_46.txt'));
        msgdata = fp.read();
        parser = email.Parser.HeaderParser();
        msg = parser.parsestr(msgdata);
        out = StringIO();
        gen = email.Generator.Generator(out, true, 0);
        gen.flatten(msg, false);
        this.assertEqual(out.getvalue(), msgdata);

    }
    function test_get_decoded_payload(){
        eq = this.assertEqual;
        msg = this._msgobj('msg_10.txt');
        # The outer message is a multipart
        eq(msg.get_payload(decode=true), nil);
        # Subpart 1 is 7bit encoded
        eq(msg.get_payload(0).get_payload(decode=true),
           'This is a 7bit encoded message.\n');
        # Subpart 2 is quopri
        eq(msg.get_payload(1).get_payload(decode=true),
           '\xa1This is a Quoted Printable encoded message!\n');
        # Subpart 3 is base64
        eq(msg.get_payload(2).get_payload(decode=true),
           'This is a Base64 encoded message.');
        # Subpart 4 is base64 with a trailing newline, which
        # used to be stripped (issue 7143).
        eq(msg.get_payload(3).get_payload(decode=true),
           'This is a Base64 encoded message.\n');
        # Subpart 5 has no Content-Transfer-Encoding: header.
        eq(msg.get_payload(4).get_payload(decode=true),
           'This has no Content-Transfer-Encoding: header.\n');

    }
    function test_get_decoded_uu_payload(){
        eq = this.assertEqual;
        msg = Message();
        msg.set_payload('begin 666 -\n+:&5L;&\\@=V]R;&0 \n \nend\n');
        for cte in ('x-uuencode', 'uuencode', 'uue', 'x-uue'){
            msg['content-transfer-encoding'] = cte;
            eq(msg.get_payload(decode=true), 'hello world');
        # Now try some bogus data
        }
        msg.set_payload('foo');
        eq(msg.get_payload(decode=true), 'foo');

    }
    function test_decode_bogus_uu_payload_quietly(){
        msg = Message();
        msg.set_payload('begin 664 foo.txt\n%<W1F=0000H \n \nend\n');
        msg['Content-Transfer-Encoding'] = 'x-uuencode';
        old_stderr = sys.stderr;
        try{
            sys.stderr = sfp = StringIO();
            # We don't care about the payload
            msg.get_payload(decode=true);
        } finally{
            sys.stderr = old_stderr;
        } this.assertEqual(sfp.getvalue(), '');

    }
    function test_decoded_generator(){
        eq = this.assertEqual;
        msg = this._msgobj('msg_07.txt');
        fp = openfile('msg_17.txt');
        try{
            text = fp.read();
        } finally{
            fp.close();
        } s = StringIO();
        g = DecodedGenerator(s);
        g.flatten(msg);
        eq(s.getvalue(), text);

    }
    function test__contains__(){
        msg = Message();
        msg['From'] = 'Me';
        msg['to'] = 'You';
        # Check for case insensitivity
        this.assertIn('from', msg);
        this.assertIn('From', msg);
        this.assertIn('FROM', msg);
        this.assertIn('to', msg);
        this.assertIn('To', msg);
        this.assertIn('TO', msg);

    }
    function test_as_string(){
        eq = this.assertEqual;
        msg = this._msgobj('msg_01.txt');
        fp = openfile('msg_01.txt');
        try{
            # BAW 30-Mar-2009 Evil be here.  So, the generator is broken with
            # respect to long line breaking.  It's also not idempotent when a
            # header from a parsed message is continued with tabs rather than
            # spaces.  Before we fixed bug 1974 it was reversedly broken,
            # i.e. headers that were continued with spaces got continued with
            # tabs.  For Python 2.x there's really no good fix and in Python
            # 3.x all this stuff is re-written to be right(er).  Chris Withers
            # convinced me that using space as the default continuation
            # character is less bad for more applications.
            text = fp.read().replace('\t', ' ');
        } finally{
            fp.close();
        } eq(text, msg.as_string());
        fullrepr = str(msg);
        lines = fullrepr.split('\n');
        this.assertTrue(lines[0].startswith('From '));
        eq(text, NL.join(lines[1:]));

    }
    function test_bad_param(){
        msg = email.message_from_string("Content-Type: blarg; baz; boo\n");
        this.assertEqual(msg.get_param('baz'), '');

    }
    function test_missing_filename(){
        msg = email.message_from_string("From: foo\n");
        this.assertEqual(msg.get_filename(), nil);

    }
    function test_bogus_filename(){
        msg = email.message_from_string(
        "Content-Disposition: blarg; filename\n");
        this.assertEqual(msg.get_filename(), '');

    }
    function test_missing_boundary(){
        msg = email.message_from_string("From: foo\n");
        this.assertEqual(msg.get_boundary(), nil);

    }
    function test_get_params(){
        eq = this.assertEqual;
        msg = email.message_from_string(
            'X-Header: foo=one; bar=two; baz=three\n');
        eq(msg.get_params(header='x-header'),
           [('foo', 'one'), ('bar', 'two'), ('baz', 'three')]);
        msg = email.message_from_string(
            'X-Header: foo; bar=one; baz=two\n');
        eq(msg.get_params(header='x-header'),
           [('foo', ''), ('bar', 'one'), ('baz', 'two')]);
        eq(msg.get_params(), nil);
        msg = email.message_from_string(
            'X-Header: foo; bar="one"; baz=two\n');
        eq(msg.get_params(header='x-header'),
           [('foo', ''), ('bar', 'one'), ('baz', 'two')]);

    }
    function test_get_param_liberal(){
        msg = Message();
        msg['Content-Type'] = 'Content-Type: Multipart/mixed; boundary = "CPIMSSMTPC06p5f3tG"';
        this.assertEqual(msg.get_param('boundary'), 'CPIMSSMTPC06p5f3tG');

    }
    function test_get_param(){
        eq = this.assertEqual;
        msg = email.message_from_string(
            "X-Header: foo=one; bar=two; baz=three\n");
        eq(msg.get_param('bar', header='x-header'), 'two');
        eq(msg.get_param('quuz', header='x-header'), nil);
        eq(msg.get_param('quuz'), nil);
        msg = email.message_from_string(
            'X-Header: foo; bar="one"; baz=two\n');
        eq(msg.get_param('foo', header='x-header'), '');
        eq(msg.get_param('bar', header='x-header'), 'one');
        eq(msg.get_param('baz', header='x-header'), 'two');
        # XXX: We are not RFC-2045 compliant!  We cannot parse:
        # msg["Content-Type"] = 'text/plain; weird="hey; dolly? [you] @ <\\"home\\">?"'
        # msg.get_param("weird")
        # yet.

    }
    function test_get_param_funky_continuation_lines(){
        msg = this._msgobj('msg_22.txt');
        this.assertEqual(msg.get_payload(1).get_param('name'), 'wibble.JPG');

    }
    function test_get_param_with_semis_in_quotes(){
        msg = email.message_from_string(
            'Content-Type: image/pjpeg; name="Jim&amp;&amp;Jill"\n');
        this.assertEqual(msg.get_param('name'), 'Jim&amp;&amp;Jill');
        this.assertEqual(msg.get_param('name', unquote=false),
                         '"Jim&amp;&amp;Jill"');

    }
    function test_get_param_with_quotes(){
        msg = email.message_from_string(
            'Content-Type: foo; bar*0="baz\\"foobar"; bar*1="\\"baz"');
        this.assertEqual(msg.get_param('bar'), 'baz"foobar"baz');
        msg = email.message_from_string(
            "Content-Type: foo; bar*0=\"baz\\\"foobar\"; bar*1=\"\\\"baz\"");
        this.assertEqual(msg.get_param('bar'), 'baz"foobar"baz');

    }
    function test_has_key(){
        msg = email.message_from_string('Header: exists');
        this.assertTrue(msg.has_key('header'));
        this.assertTrue(msg.has_key('Header'));
        this.assertTrue(msg.has_key('HEADER'));
        this.assertFalse(msg.has_key('headeri'));

    }
    function test_set_param(){
        eq = this.assertEqual;
        msg = Message();
        msg.set_param('charset', 'iso-2022-jp');
        eq(msg.get_param('charset'), 'iso-2022-jp');
        msg.set_param('importance', 'high value');
        eq(msg.get_param('importance'), 'high value');
        eq(msg.get_param('importance', unquote=false), '"high value"');
        eq(msg.get_params(), [('text/plain', ''),
                              ('charset', 'iso-2022-jp'),
                              ('importance', 'high value')]);
        eq(msg.get_params(unquote=false), [('text/plain', ''),
                                       ('charset', '"iso-2022-jp"'),
                                       ('importance', '"high value"')]);
        msg.set_param('charset', 'iso-9999-xx', header='X-Jimmy');
        eq(msg.get_param('charset', header='X-Jimmy'), 'iso-9999-xx');

    }
    function test_del_param(){
        eq = this.assertEqual;
        msg = this._msgobj('msg_05.txt');
        eq(msg.get_params(),
           [('multipart/report', ''), ('report-type', 'delivery-status'),
            ('boundary', 'D1690A7AC1.996856090/mail.example.com')]);
        old_val = msg.get_param("report-type");
        msg.del_param("report-type");
        eq(msg.get_params(),
           [('multipart/report', ''),
            ('boundary', 'D1690A7AC1.996856090/mail.example.com')]);
        msg.set_param("report-type", old_val);
        eq(msg.get_params(),
           [('multipart/report', ''),
            ('boundary', 'D1690A7AC1.996856090/mail.example.com'),
            ('report-type', old_val)]);

    }
    function test_del_param_on_other_header(){
        msg = Message();
        msg.add_header('Content-Disposition', 'attachment', filename='bud.gif');
        msg.del_param('filename', 'content-disposition');
        this.assertEqual(msg['content-disposition'], 'attachment');

    }
    function test_set_type(){
        eq = this.assertEqual;
        msg = Message();
        this.assertRaises(ValueError, msg.set_type, 'text');
        msg.set_type('text/plain');
        eq(msg['content-type'], 'text/plain');
        msg.set_param('charset', 'us-ascii');
        eq(msg['content-type'], 'text/plain; charset="us-ascii"');
        msg.set_type('text/html');
        eq(msg['content-type'], 'text/html; charset="us-ascii"');

    }
    function test_set_type_on_other_header(){
        msg = Message();
        msg['X-Content-Type'] = 'text/plain';
        msg.set_type('application/octet-stream', 'X-Content-Type');
        this.assertEqual(msg['x-content-type'], 'application/octet-stream');

    }
    function test_get_content_type_missing(){
        msg = Message();
        this.assertEqual(msg.get_content_type(), 'text/plain');

    }
    function test_get_content_type_missing_with_default_type(){
        msg = Message();
        msg.set_default_type('message/rfc822');
        this.assertEqual(msg.get_content_type(), 'message/rfc822');

    }
    function test_get_content_type_from_message_implicit(){
        msg = this._msgobj('msg_30.txt');
        this.assertEqual(msg.get_payload(0).get_content_type(),
                         'message/rfc822');

    }
    function test_get_content_type_from_message_explicit(){
        msg = this._msgobj('msg_28.txt');
        this.assertEqual(msg.get_payload(0).get_content_type(),
                         'message/rfc822');

    }
    function test_get_content_type_from_message_text_plain_implicit(){
        msg = this._msgobj('msg_03.txt');
        this.assertEqual(msg.get_content_type(), 'text/plain');

    }
    function test_get_content_type_from_message_text_plain_explicit(){
        msg = this._msgobj('msg_01.txt');
        this.assertEqual(msg.get_content_type(), 'text/plain');

    }
    function test_get_content_maintype_missing(){
        msg = Message();
        this.assertEqual(msg.get_content_maintype(), 'text');

    }
    function test_get_content_maintype_missing_with_default_type(){
        msg = Message();
        msg.set_default_type('message/rfc822');
        this.assertEqual(msg.get_content_maintype(), 'message');

    }
    function test_get_content_maintype_from_message_implicit(){
        msg = this._msgobj('msg_30.txt');
        this.assertEqual(msg.get_payload(0).get_content_maintype(), 'message');

    }
    function test_get_content_maintype_from_message_explicit(){
        msg = this._msgobj('msg_28.txt');
        this.assertEqual(msg.get_payload(0).get_content_maintype(), 'message');

    }
    function test_get_content_maintype_from_message_text_plain_implicit(){
        msg = this._msgobj('msg_03.txt');
        this.assertEqual(msg.get_content_maintype(), 'text');

    }
    function test_get_content_maintype_from_message_text_plain_explicit(){
        msg = this._msgobj('msg_01.txt');
        this.assertEqual(msg.get_content_maintype(), 'text');

    }
    function test_get_content_subtype_missing(){
        msg = Message();
        this.assertEqual(msg.get_content_subtype(), 'plain');

    }
    function test_get_content_subtype_missing_with_default_type(){
        msg = Message();
        msg.set_default_type('message/rfc822');
        this.assertEqual(msg.get_content_subtype(), 'rfc822');

    }
    function test_get_content_subtype_from_message_implicit(){
        msg = this._msgobj('msg_30.txt');
        this.assertEqual(msg.get_payload(0).get_content_subtype(), 'rfc822');

    }
    function test_get_content_subtype_from_message_explicit(){
        msg = this._msgobj('msg_28.txt');
        this.assertEqual(msg.get_payload(0).get_content_subtype(), 'rfc822');

    }
    function test_get_content_subtype_from_message_text_plain_implicit(){
        msg = this._msgobj('msg_03.txt');
        this.assertEqual(msg.get_content_subtype(), 'plain');

    }
    function test_get_content_subtype_from_message_text_plain_explicit(){
        msg = this._msgobj('msg_01.txt');
        this.assertEqual(msg.get_content_subtype(), 'plain');

    }
    function test_get_content_maintype_error(){
        msg = Message();
        msg['Content-Type'] = 'no-slash-in-this-string';
        this.assertEqual(msg.get_content_maintype(), 'text');

    }
    function test_get_content_subtype_error(){
        msg = Message();
        msg['Content-Type'] = 'no-slash-in-this-string';
        this.assertEqual(msg.get_content_subtype(), 'plain');

    }
    function test_replace_header(){
        eq = this.assertEqual;
        msg = Message();
        msg.add_header('First', 'One');
        msg.add_header('Second', 'Two');
        msg.add_header('Third', 'Three');
        eq(msg.keys(), ['First', 'Second', 'Third']);
        eq(msg.values(), ['One', 'Two', 'Three']);
        msg.replace_header('Second', 'Twenty');
        eq(msg.keys(), ['First', 'Second', 'Third']);
        eq(msg.values(), ['One', 'Twenty', 'Three']);
        msg.add_header('First', 'Eleven');
        msg.replace_header('First', 'One Hundred');
        eq(msg.keys(), ['First', 'Second', 'Third', 'First']);
        eq(msg.values(), ['One Hundred', 'Twenty', 'Three', 'Eleven']);
        this.assertRaises(KeyError, msg.replace_header, 'Fourth', 'Missing');

    }
    function test_broken_base64_payload(){
        x = 'AwDp0P7//y6LwKEAcPa/6Q=9';
        msg = Message();
        msg['content-type'] = 'audio/x-midi';
        msg['content-transfer-encoding'] = 'base64';
        msg.set_payload(x);
        this.assertEqual(msg.get_payload(decode=true), x);

    }
    function test_get_content_charset(){
        msg = Message();
        msg.set_charset('us-ascii');
        this.assertEqual('us-ascii', msg.get_content_charset());
        msg.set_charset(u'us-ascii');
        this.assertEqual('us-ascii', msg.get_content_charset());

    # Issue 5871: reject an attempt to embed a header inside a header value
    # (header injection attack).
    }
    function test_embedded_header_via_Header_rejected(){
        msg = Message();
        msg['Dummy'] = Header('dummy\nX-Injected-Header: test');
        this.assertRaises(Errors.HeaderParseError, msg.as_string);

    }
    function test_embedded_header_via_string_rejected(){
        msg = Message();
        msg['Dummy'] = 'dummy\nX-Injected-Header: test';
        this.assertRaises(Errors.HeaderParseError, msg.as_string);


# Test the email.Encoders module
}
} class TestEncoders(unittest.TestCase){
    function test_encode_empty_payload(){
        eq = this.assertEqual;
        msg = Message();
        msg.set_charset('us-ascii');
        eq(msg['content-transfer-encoding'], '7bit');

    }
    function test_default_cte(){
        eq = this.assertEqual;
        # 7bit data and the default us-ascii _charset
        msg = MIMEText('hello world');
        eq(msg['content-transfer-encoding'], '7bit');
        # Similar, but with 8bit data
        msg = MIMEText('hello \xf8 world');
        eq(msg['content-transfer-encoding'], '8bit');
        # And now with a different charset
        msg = MIMEText('hello \xf8 world', _charset='iso-8859-1');
        eq(msg['content-transfer-encoding'], 'quoted-printable');

    }
    function test_encode7or8bit(){
        # Make sure a charset whose input character set is 8bit but
        # whose output character set is 7bit gets a transfer-encoding
        # of 7bit.
        eq = this.assertEqual;
        msg = email.MIMEText.MIMEText('\xca\xb8', _charset='euc-jp');
        eq(msg['content-transfer-encoding'], '7bit');


# Test long header wrapping
}
} class TestLongHeaders(TestEmailBase){
    function test_split_long_continuation(){
        eq = this.ndiffAssertEqual;
        msg = email.message_from_string("""\
Subject: bug demonstration
\t12345678911234567892123456789312345678941234567895123456789612345678971234567898112345678911234567892123456789112345678911234567892123456789
\tmore text

test
""");
        sfp = StringIO();
        g = Generator(sfp);
        g.flatten(msg);
        eq(sfp.getvalue(), """\
Subject: bug demonstration
 12345678911234567892123456789312345678941234567895123456789612345678971234567898112345678911234567892123456789112345678911234567892123456789
 more text

test
""");

    }
    function test_another_long_almost_unsplittable_header(){
        eq = this.ndiffAssertEqual;
        hstr = """\
bug demonstration
\t12345678911234567892123456789312345678941234567895123456789612345678971234567898112345678911234567892123456789112345678911234567892123456789
\tmore text""";
        h = Header(hstr, continuation_ws='\t');
        eq(h.encode(), """\
bug demonstration
\t12345678911234567892123456789312345678941234567895123456789612345678971234567898112345678911234567892123456789112345678911234567892123456789
\tmore text""");
        h = Header(hstr);
        eq(h.encode(), """\
bug demonstration
 12345678911234567892123456789312345678941234567895123456789612345678971234567898112345678911234567892123456789112345678911234567892123456789
 more text""");

    }
    function test_long_nonstring(){
        eq = this.ndiffAssertEqual;
        g = Charset("iso-8859-1");
        cz = Charset("iso-8859-2");
        utf8 = Charset("utf-8");
        g_head = "Die Mieter treten hier ein werden mit einem Foerderband komfortabel den Korridor entlang, an s\xfcdl\xfcndischen Wandgem\xe4lden vorbei, gegen die rotierenden Klingen bef\xf6rdert. ";
        cz_head = "Finan\xe8ni metropole se hroutily pod tlakem jejich d\xf9vtipu.. ";
        utf8_head = u"\u6b63\u78ba\u306b\u8a00\u3046\u3068\u7ffb\u8a33\u306f\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002\u4e00\u90e8\u306f\u30c9\u30a4\u30c4\u8a9e\u3067\u3059\u304c\u3001\u3042\u3068\u306f\u3067\u305f\u3089\u3081\u3067\u3059\u3002\u5b9f\u969b\u306b\u306f\u300cWenn ist das Nunstuck git und Slotermeyer? Ja! Beiherhund das Oder die Flipperwaldt gersput.\u300d\u3068\u8a00\u3063\u3066\u3044\u307e\u3059\u3002".encode("utf-8");
        h = Header(g_head, g, header_name='Subject');
        h.append(cz_head, cz);
        h.append(utf8_head, utf8);
        msg = Message();
        msg['Subject'] = h;
        sfp = StringIO();
        g = Generator(sfp);
        g.flatten(msg);
        eq(sfp.getvalue(), """\
Subject: =?iso-8859-1?q?Die_Mieter_treten_hier_ein_werden_mit_einem_Foerd?=
 =?iso-8859-1?q?erband_komfortabel_den_Korridor_entlang=2C_an_s=FCdl=FCndi?=
 =?iso-8859-1?q?schen_Wandgem=E4lden_vorbei=2C_gegen_die_rotierenden_Kling?=
 =?iso-8859-1?q?en_bef=F6rdert=2E_?= =?iso-8859-2?q?Finan=E8ni_met?=
 =?iso-8859-2?q?ropole_se_hroutily_pod_tlakem_jejich_d=F9vtipu=2E=2E_?=
 =?utf-8?b?5q2j56K644Gr6KiA44GG44Go57+76Kiz44Gv44GV44KM44Gm44GE?=
 =?utf-8?b?44G+44Gb44KT44CC5LiA6YOo44Gv44OJ44Kk44OE6Kqe44Gn44GZ44GM44CB?=
 =?utf-8?b?44GC44Go44Gv44Gn44Gf44KJ44KB44Gn44GZ44CC5a6f6Zqb44Gr44Gv44CM?=
 =?utf-8?q?Wenn_ist_das_Nunstuck_git_und_Slotermeyer=3F_Ja!_Beiherhund_das?=
 =?utf-8?b?IE9kZXIgZGllIEZsaXBwZXJ3YWxkdCBnZXJzcHV0LuOAjeOBqOiogOOBow==?=
 =?utf-8?b?44Gm44GE44G+44GZ44CC?=

""");
        eq(h.encode(), """\
=?iso-8859-1?q?Die_Mieter_treten_hier_ein_werden_mit_einem_Foerd?=
 =?iso-8859-1?q?erband_komfortabel_den_Korridor_entlang=2C_an_s=FCdl=FCndi?=
 =?iso-8859-1?q?schen_Wandgem=E4lden_vorbei=2C_gegen_die_rotierenden_Kling?=
 =?iso-8859-1?q?en_bef=F6rdert=2E_?= =?iso-8859-2?q?Finan=E8ni_met?=
 =?iso-8859-2?q?ropole_se_hroutily_pod_tlakem_jejich_d=F9vtipu=2E=2E_?=
 =?utf-8?b?5q2j56K644Gr6KiA44GG44Go57+76Kiz44Gv44GV44KM44Gm44GE?=
 =?utf-8?b?44G+44Gb44KT44CC5LiA6YOo44Gv44OJ44Kk44OE6Kqe44Gn44GZ44GM44CB?=
 =?utf-8?b?44GC44Go44Gv44Gn44Gf44KJ44KB44Gn44GZ44CC5a6f6Zqb44Gr44Gv44CM?=
 =?utf-8?q?Wenn_ist_das_Nunstuck_git_und_Slotermeyer=3F_Ja!_Beiherhund_das?=
 =?utf-8?b?IE9kZXIgZGllIEZsaXBwZXJ3YWxkdCBnZXJzcHV0LuOAjeOBqOiogOOBow==?=
 =?utf-8?b?44Gm44GE44G+44GZ44CC?=""");

    }
    function test_long_header_encode(){
        eq = this.ndiffAssertEqual;
        h = Header('wasnipoop; giraffes="very-long-necked-animals"; '
                   'spooge="yummy"; hippos="gargantuan"; marshmallows="gooey"',
                   header_name='X-Foobar-Spoink-Defrobnit');
        eq(h.encode(), '''\
wasnipoop; giraffes="very-long-necked-animals";
 spooge="yummy"; hippos="gargantuan"; marshmallows="gooey"''');

    }
    function test_long_header_encode_with_tab_continuation(){
        eq = this.ndiffAssertEqual;
        h = Header('wasnipoop; giraffes="very-long-necked-animals"; '
                   'spooge="yummy"; hippos="gargantuan"; marshmallows="gooey"',
                   header_name='X-Foobar-Spoink-Defrobnit',
                   continuation_ws='\t');
        eq(h.encode(), '''\
wasnipoop; giraffes="very-long-necked-animals";
\tspooge="yummy"; hippos="gargantuan"; marshmallows="gooey"''');

    }
    function test_header_splitter(){
        eq = this.ndiffAssertEqual;
        msg = MIMEText('');
        # It'd be great if we could use add_header() here, but that doesn't
        # guarantee an order of the parameters.
        msg['X-Foobar-Spoink-Defrobnit'] = (
            'wasnipoop; giraffes="very-long-necked-animals"; '
            'spooge="yummy"; hippos="gargantuan"; marshmallows="gooey"');
        sfp = StringIO();
        g = Generator(sfp);
        g.flatten(msg);
        eq(sfp.getvalue(), '''\
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Foobar-Spoink-Defrobnit: wasnipoop; giraffes="very-long-necked-animals";
 spooge="yummy"; hippos="gargantuan"; marshmallows="gooey"

''');

    }
    function test_no_semis_header_splitter(){
        eq = this.ndiffAssertEqual;
        msg = Message();
        msg['From'] = 'test@dom.ain';
        msg['References'] = SPACE.join(['<%d@dom.ain>' % i for i in range(10)]);
        msg.set_payload('Test');
        sfp = StringIO();
        g = Generator(sfp);
        g.flatten(msg);
        eq(sfp.getvalue(), """\
From: test@dom.ain
References: <0@dom.ain> <1@dom.ain> <2@dom.ain> <3@dom.ain> <4@dom.ain>
 <5@dom.ain> <6@dom.ain> <7@dom.ain> <8@dom.ain> <9@dom.ain>

Test""");

    }
    function test_no_split_long_header(){
        eq = this.ndiffAssertEqual;
        hstr = 'References: ' + 'x' * 80;
        h = Header(hstr, continuation_ws='\t');
        eq(h.encode(), """\
References: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx""");

    }
    function test_splitting_multiple_long_lines(){
        eq = this.ndiffAssertEqual;
        hstr = """\
from babylon.socal-raves.org (localhost [127.0.0.1]); by babylon.socal-raves.org (Postfix) with ESMTP id B570E51B81; for <mailman-admin@babylon.socal-raves.org>; Sat, 2 Feb 2002 17:00:06 -0800 (PST)
\tfrom babylon.socal-raves.org (localhost [127.0.0.1]); by babylon.socal-raves.org (Postfix) with ESMTP id B570E51B81; for <mailman-admin@babylon.socal-raves.org>; Sat, 2 Feb 2002 17:00:06 -0800 (PST)
\tfrom babylon.socal-raves.org (localhost [127.0.0.1]); by babylon.socal-raves.org (Postfix) with ESMTP id B570E51B81; for <mailman-admin@babylon.socal-raves.org>; Sat, 2 Feb 2002 17:00:06 -0800 (PST)
""";
        h = Header(hstr, continuation_ws='\t');
        eq(h.encode(), """\
from babylon.socal-raves.org (localhost [127.0.0.1]);
\tby babylon.socal-raves.org (Postfix) with ESMTP id B570E51B81;
\tfor <mailman-admin@babylon.socal-raves.org>;
\tSat, 2 Feb 2002 17:00:06 -0800 (PST)
\tfrom babylon.socal-raves.org (localhost [127.0.0.1]);
\tby babylon.socal-raves.org (Postfix) with ESMTP id B570E51B81;
\tfor <mailman-admin@babylon.socal-raves.org>;
\tSat, 2 Feb 2002 17:00:06 -0800 (PST)
\tfrom babylon.socal-raves.org (localhost [127.0.0.1]);
\tby babylon.socal-raves.org (Postfix) with ESMTP id B570E51B81;
\tfor <mailman-admin@babylon.socal-raves.org>;
\tSat, 2 Feb 2002 17:00:06 -0800 (PST)""");

    }
    function test_splitting_first_line_only_is_long(){
        eq = this.ndiffAssertEqual;
        hstr = """\
from modemcable093.139-201-24.que.mc.videotron.ca ([24.201.139.93] helo=cthulhu.gerg.ca)
\tby kronos.mems-exchange.org with esmtp (Exim 4.05)
\tid 17k4h5-00034i-00
\tfor test@mems-exchange.org; Wed, 28 Aug 2002 11:25:20 -0400""";
        h = Header(hstr, maxlinelen=78, header_name='Received',
                   continuation_ws='\t');
        eq(h.encode(), """\
from modemcable093.139-201-24.que.mc.videotron.ca ([24.201.139.93]
\thelo=cthulhu.gerg.ca)
\tby kronos.mems-exchange.org with esmtp (Exim 4.05)
\tid 17k4h5-00034i-00
\tfor test@mems-exchange.org; Wed, 28 Aug 2002 11:25:20 -0400""");

    }
    function test_long_8bit_header(){
        eq = this.ndiffAssertEqual;
        msg = Message();
        h = Header('Britische Regierung gibt', 'iso-8859-1',
                    header_name='Subject');
        h.append('gr\xfcnes Licht f\xfcr Offshore-Windkraftprojekte');
        msg['Subject'] = h;
        eq(msg.as_string(), """\
Subject: =?iso-8859-1?q?Britische_Regierung_gibt?= =?iso-8859-1?q?gr=FCnes?=
 =?iso-8859-1?q?_Licht_f=FCr_Offshore-Windkraftprojekte?=

""");

    }
    function test_long_8bit_header_no_charset(){
        eq = this.ndiffAssertEqual;
        msg = Message();
        msg['Reply-To'] = 'Britische Regierung gibt gr\xfcnes Licht f\xfcr Offshore-Windkraftprojekte <a-very-long-address@example.com>';
        eq(msg.as_string(), """\
Reply-To: Britische Regierung gibt gr\xfcnes Licht f\xfcr Offshore-Windkraftprojekte <a-very-long-address@example.com>

""");

    }
    function test_long_to_header(){
        eq = this.ndiffAssertEqual;
        to = '"Someone Test #A" <someone@eecs.umich.edu>,<someone@eecs.umich.edu>,"Someone Test #B" <someone@umich.edu>, "Someone Test #C" <someone@eecs.umich.edu>, "Someone Test #D" <someone@eecs.umich.edu>';
        msg = Message();
        msg['To'] = to;
        eq(msg.as_string(0), '''\
To: "Someone Test #A" <someone@eecs.umich.edu>, <someone@eecs.umich.edu>,
 "Someone Test #B" <someone@umich.edu>,
 "Someone Test #C" <someone@eecs.umich.edu>,
 "Someone Test #D" <someone@eecs.umich.edu>

''');

    }
    function test_long_line_after_append(){
        eq = this.ndiffAssertEqual;
        s = 'This is an example of string which has almost the limit of header length.';
        h = Header(s);
        h.append('Add another line.');
        eq(h.encode(), """\
This is an example of string which has almost the limit of header length.
 Add another line.""");

    }
    function test_shorter_line_with_append(){
        eq = this.ndiffAssertEqual;
        s = 'This is a shorter line.';
        h = Header(s);
        h.append('Add another sentence. (Surprise?)');
        eq(h.encode(),
           'This is a shorter line. Add another sentence. (Surprise?)');

    }
    function test_long_field_name(){
        eq = this.ndiffAssertEqual;
        fn = 'X-Very-Very-Very-Long-Header-Name';
        gs = "Die Mieter treten hier ein werden mit einem Foerderband komfortabel den Korridor entlang, an s\xfcdl\xfcndischen Wandgem\xe4lden vorbei, gegen die rotierenden Klingen bef\xf6rdert. ";
        h = Header(gs, 'iso-8859-1', header_name=fn);
        # BAW: this seems broken because the first line is too long
        eq(h.encode(), """\
=?iso-8859-1?q?Die_Mieter_treten_hier_?=
 =?iso-8859-1?q?ein_werden_mit_einem_Foerderband_komfortabel_den_Korridor_?=
 =?iso-8859-1?q?entlang=2C_an_s=FCdl=FCndischen_Wandgem=E4lden_vorbei=2C_g?=
 =?iso-8859-1?q?egen_die_rotierenden_Klingen_bef=F6rdert=2E_?=""");

    }
    function test_long_received_header(){
        h = 'from FOO.TLD (vizworld.acl.foo.tld [123.452.678.9]) by hrothgar.la.mastaler.com (tmda-ofmipd) with ESMTP; Wed, 05 Mar 2003 18:10:18 -0700';
        msg = Message();
        msg['Received-1'] = Header(h, continuation_ws='\t');
        msg['Received-2'] = h;
        this.assertEqual(msg.as_string(), """\
Received-1: from FOO.TLD (vizworld.acl.foo.tld [123.452.678.9]) by
\throthgar.la.mastaler.com (tmda-ofmipd) with ESMTP;
\tWed, 05 Mar 2003 18:10:18 -0700
Received-2: from FOO.TLD (vizworld.acl.foo.tld [123.452.678.9]) by
 hrothgar.la.mastaler.com (tmda-ofmipd) with ESMTP;
 Wed, 05 Mar 2003 18:10:18 -0700

""");

    }
    function test_string_headerinst_eq(){
        h = '<15975.17901.207240.414604@sgigritzmann1.mathematik.tu-muenchen.de> (David Bremner\'s message of "Thu, 6 Mar 2003 13:58:21 +0100")';
        msg = Message();
        msg['Received'] = Header(h, header_name='Received',
                                 continuation_ws='\t');
        msg['Received'] = h;
        this.ndiffAssertEqual(msg.as_string(), """\
Received: <15975.17901.207240.414604@sgigritzmann1.mathematik.tu-muenchen.de>
\t(David Bremner's message of "Thu, 6 Mar 2003 13:58:21 +0100")
Received: <15975.17901.207240.414604@sgigritzmann1.mathematik.tu-muenchen.de>
 (David Bremner's message of "Thu, 6 Mar 2003 13:58:21 +0100")

""");

    }
    function test_long_unbreakable_lines_with_continuation(){
        eq = this.ndiffAssertEqual;
        msg = Message();
        t = """\
 iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAGFBMVEUAAAAkHiJeRUIcGBi9
 locQDQ4zJykFBAXJfWDjAAACYUlEQVR4nF2TQY/jIAyFc6lydlG5x8Nyp1Y69wj1PN2I5gzp""";
        msg['Face-1'] = t;
        msg['Face-2'] = Header(t, header_name='Face-2');
        eq(msg.as_string(), """\
Face-1: iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAGFBMVEUAAAAkHiJeRUIcGBi9
 locQDQ4zJykFBAXJfWDjAAACYUlEQVR4nF2TQY/jIAyFc6lydlG5x8Nyp1Y69wj1PN2I5gzp
Face-2: iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAGFBMVEUAAAAkHiJeRUIcGBi9
 locQDQ4zJykFBAXJfWDjAAACYUlEQVR4nF2TQY/jIAyFc6lydlG5x8Nyp1Y69wj1PN2I5gzp

""");

    }
    function test_another_long_multiline_header(){
        eq = this.ndiffAssertEqual;
        m = '''\
Received: from siimage.com ([172.25.1.3]) by zima.siliconimage.com with Microsoft SMTPSVC(5.0.2195.4905);
 Wed, 16 Oct 2002 07:41:11 -0700''';
        msg = email.message_from_string(m);
        eq(msg.as_string(), '''\
Received: from siimage.com ([172.25.1.3]) by zima.siliconimage.com with
 Microsoft SMTPSVC(5.0.2195.4905); Wed, 16 Oct 2002 07:41:11 -0700

''');

    }
    function test_long_lines_with_different_header(){
        eq = this.ndiffAssertEqual;
        h = """\
List-Unsubscribe: <https://lists.sourceforge.net/lists/listinfo/spamassassin-talk>,
        <mailto:spamassassin-talk-request@lists.sourceforge.net?subject=unsubscribe>""";
        msg = Message();
        msg['List'] = h;
        msg['List'] = Header(h, header_name='List');
        eq(msg.as_string(), """\
List: List-Unsubscribe: <https://lists.sourceforge.net/lists/listinfo/spamassassin-talk>,
 <mailto:spamassassin-talk-request@lists.sourceforge.net?subject=unsubscribe>
List: List-Unsubscribe: <https://lists.sourceforge.net/lists/listinfo/spamassassin-talk>,
 <mailto:spamassassin-talk-request@lists.sourceforge.net?subject=unsubscribe>

""");



# Test mangling of "From " lines in the body of a message
}
} class TestFromMangling(unittest.TestCase){
    function setUp(){
        this.msg = Message();
        this.msg['From'] = 'aaa@bbb.org';
        this.msg.set_payload("""\
From the desk of A.A.A.:
Blah blah blah
""");

    }
    function test_mangled_from(){
        s = StringIO();
        g = Generator(s, mangle_from_=true);
        g.flatten(this.msg);
        this.assertEqual(s.getvalue(), """\
From: aaa@bbb.org

>From the desk of A.A.A.:
Blah blah blah
""");

    }
    function test_dont_mangle_from(){
        s = StringIO();
        g = Generator(s, mangle_from_=false);
        g.flatten(this.msg);
        this.assertEqual(s.getvalue(), """\
From: aaa@bbb.org

From the desk of A.A.A.:
Blah blah blah
""");

    }
    function test_mangle_from_in_preamble_and_epilog(){
        s = StringIO();
        g = Generator(s, mangle_from_=true);
        msg = email.message_from_string(textwrap.dedent("""\
            From: foo@bar.com
            Mime-Version: 1.0
            Content-Type: multipart/mixed; boundary=XXX

            From somewhere unknown

            --XXX
            Content-Type: text/plain

            foo

            --XXX--

            From somewhere unknowable
            """));
        g.flatten(msg);
        this.assertEqual(len([1 for x in s.getvalue().split('\n')
                                  if x.startswith('>From ')]), 2);


# Test the basic MIMEAudio class
}
} class TestMIMEAudio(unittest.TestCase){
    function setUp(){
        # Make sure we pick up the audiotest.au that lives in email/test/data.
        # In Python, there's an audiotest.au living in Lib/test but that isn't
        # included in some binary distros that don't include the test
        # package.  The trailing empty string on the .join() is significant
        # since findfile() will do a dirname().
        datadir = os.path.join(os.path.dirname(landmark), 'data', '');
        fp = open(findfile('audiotest.au', datadir), 'rb');
        try{
            this._audiodata = fp.read();
        } finally{
            fp.close();
        } this._au = MIMEAudio(this._audiodata);

    }
    function test_guess_minor_type(){
        this.assertEqual(this._au.get_content_type(), 'audio/basic');

    }
    function test_encoding(){
        payload = this._au.get_payload();
        this.assertEqual(base64.decodestring(payload), this._audiodata);

    }
    function test_checkSetMinor(){
        au = MIMEAudio(this._audiodata, 'fish');
        this.assertEqual(au.get_content_type(), 'audio/fish');

    }
    function test_add_header(){
        eq = this.assertEqual;
        this._au.add_header('Content-Disposition', 'attachment',
                            filename='audiotest.au');
        eq(this._au['content-disposition'],
           'attachment; filename="audiotest.au"');
        eq(this._au.get_params(header='content-disposition'),
           [('attachment', ''), ('filename', 'audiotest.au')]);
        eq(this._au.get_param('filename', header='content-disposition'),
           'audiotest.au');
        missing = [];
        eq(this._au.get_param('attachment', header='content-disposition'), '');
        this.assertIs(this._au.get_param('foo', failobj=missing,
                                         header='content-disposition'), missing);
        # Try some missing stuff
        this.assertIs(this._au.get_param('foobar', missing), missing);
        this.assertIs(this._au.get_param('attachment', missing,
                                         header='foobar'), missing);



# Test the basic MIMEImage class
}
} class TestMIMEImage(unittest.TestCase){
    function setUp(){
        fp = openfile('PyBanner048.gif');
        try{
            this._imgdata = fp.read();
        } finally{
            fp.close();
        } this._im = MIMEImage(this._imgdata);

    }
    function test_guess_minor_type(){
        this.assertEqual(this._im.get_content_type(), 'image/gif');

    }
    function test_encoding(){
        payload = this._im.get_payload();
        this.assertEqual(base64.decodestring(payload), this._imgdata);

    }
    function test_checkSetMinor(){
        im = MIMEImage(this._imgdata, 'fish');
        this.assertEqual(im.get_content_type(), 'image/fish');

    }
    function test_add_header(){
        eq = this.assertEqual;
        this._im.add_header('Content-Disposition', 'attachment',
                            filename='dingusfish.gif');
        eq(this._im['content-disposition'],
           'attachment; filename="dingusfish.gif"');
        eq(this._im.get_params(header='content-disposition'),
           [('attachment', ''), ('filename', 'dingusfish.gif')]);
        eq(this._im.get_param('filename', header='content-disposition'),
           'dingusfish.gif');
        missing = [];
        eq(this._im.get_param('attachment', header='content-disposition'), '');
        this.assertIs(this._im.get_param('foo', failobj=missing,
                                         header='content-disposition'), missing);
        # Try some missing stuff
        this.assertIs(this._im.get_param('foobar', missing), missing);
        this.assertIs(this._im.get_param('attachment', missing,
                                         header='foobar'), missing);



# Test the basic MIMEText class
}
} class TestMIMEText(unittest.TestCase){
    function setUp(){
        this._msg = MIMEText('hello there');

    }
    function test_types(){
        eq = this.assertEqual;
        eq(this._msg.get_content_type(), 'text/plain');
        eq(this._msg.get_param('charset'), 'us-ascii');
        missing = [];
        this.assertIs(this._msg.get_param('foobar', missing), missing);
        this.assertIs(this._msg.get_param('charset', missing, header='foobar'),
                      missing);

    }
    function test_payload(){
        this.assertEqual(this._msg.get_payload(), 'hello there');
        this.assertFalse(this._msg.is_multipart());

    }
    function test_charset(){
        eq = this.assertEqual;
        msg = MIMEText('hello there', _charset='us-ascii');
        eq(msg.get_charset().input_charset, 'us-ascii');
        eq(msg['content-type'], 'text/plain; charset="us-ascii"');

    }
    function test_7bit_unicode_input(){
        eq = this.assertEqual;
        msg = MIMEText(u'hello there', _charset='us-ascii');
        eq(msg.get_charset().input_charset, 'us-ascii');
        eq(msg['content-type'], 'text/plain; charset="us-ascii"');

    }
    function test_7bit_unicode_input_no_charset(){
        eq = this.assertEqual;
        msg = MIMEText(u'hello there');
        eq(msg.get_charset(), 'us-ascii');
        eq(msg['content-type'], 'text/plain; charset="us-ascii"');
        this.assertIn('hello there', msg.as_string());

    }
    function test_8bit_unicode_input(){
        teststr = u'\u043a\u0438\u0440\u0438\u043b\u0438\u0446\u0430';
        eq = this.assertEqual;
        msg = MIMEText(teststr, _charset='utf-8');
        eq(msg.get_charset().output_charset, 'utf-8');
        eq(msg['content-type'], 'text/plain; charset="utf-8"');
        eq(msg.get_payload(decode=true), teststr.encode('utf-8'));

    }
    function test_8bit_unicode_input_no_charset(){
        teststr = u'\u043a\u0438\u0440\u0438\u043b\u0438\u0446\u0430';
        this.assertRaises(UnicodeEncodeError, MIMEText, teststr);



# Test complicated multipart/* messages
}
} class TestMultipart(TestEmailBase){
    function setUp(){
        fp = openfile('PyBanner048.gif');
        try{
            data = fp.read();
        } finally{
            fp.close();

        }
        container = MIMEBase('multipart', 'mixed', boundary='BOUNDARY');
        image = MIMEImage(data, name='dingusfish.gif');
        image.add_header('content-disposition', 'attachment',
                         filename='dingusfish.gif');
        intro = MIMEText('''\
Hi there,

This is the dingus fish.
''');
        container.attach(intro);
        container.attach(image);
        container['From'] = 'Barry <barry@digicool.com>';
        container['To'] = 'Dingus Lovers <cravindogs@cravindogs.com>';
        container['Subject'] = 'Here is your dingus fish';

        now = 987809702.54848599;
        timetuple = time.localtime(now);
        if timetuple[-1] == 0{
            tzsecs = time.timezone;
        } else{
            tzsecs = time.altzone;
        } if tzsecs > 0{
            sign = '-';
        } else{
            sign = '+';
        } tzoffset = ' %s%04d' % (sign, tzsecs // 36);
        container['Date'] = time.strftime(
            '%a, %d %b %Y %H:%M:%S',
            time.localtime(now)) + tzoffset;
        this._msg = container;
        this._im = image;
        this._txt = intro;

    }
    function test_hierarchy(){
        # convenience
        eq = this.assertEqual;
        raises = this.assertRaises;
        # tests
        m = this._msg;
        this.assertTrue(m.is_multipart());
        eq(m.get_content_type(), 'multipart/mixed');
        eq(len(m.get_payload()), 2);
        raises(IndexError, m.get_payload, 2);
        m0 = m.get_payload(0);
        m1 = m.get_payload(1);
        this.assertIs(m0, this._txt);
        this.assertIs(m1, this._im);
        eq(m.get_payload(), [m0, m1]);
        this.assertFalse(m0.is_multipart());
        this.assertFalse(m1.is_multipart());

    }
    function test_empty_multipart_idempotent(){
        text = """\
Content-Type: multipart/mixed; boundary="BOUNDARY"
MIME-Version: 1.0
Subject: A subject
To: aperson@dom.ain
From: bperson@dom.ain


--BOUNDARY


--BOUNDARY--
""";
        msg = Parser().parsestr(text);
        this.ndiffAssertEqual(text, msg.as_string());

    }
    function test_no_parts_in_a_multipart_with_none_epilogue(){
        outer = MIMEBase('multipart', 'mixed');
        outer['Subject'] = 'A subject';
        outer['To'] = 'aperson@dom.ain';
        outer['From'] = 'bperson@dom.ain';
        outer.set_boundary('BOUNDARY');
        this.ndiffAssertEqual(outer.as_string(), '''\
Content-Type: multipart/mixed; boundary="BOUNDARY"
MIME-Version: 1.0
Subject: A subject
To: aperson@dom.ain
From: bperson@dom.ain

--BOUNDARY

--BOUNDARY--
''');

    }
    function test_no_parts_in_a_multipart_with_empty_epilogue(){
        outer = MIMEBase('multipart', 'mixed');
        outer['Subject'] = 'A subject';
        outer['To'] = 'aperson@dom.ain';
        outer['From'] = 'bperson@dom.ain';
        outer.preamble = '';
        outer.epilogue = '';
        outer.set_boundary('BOUNDARY');
        this.ndiffAssertEqual(outer.as_string(), '''\
Content-Type: multipart/mixed; boundary="BOUNDARY"
MIME-Version: 1.0
Subject: A subject
To: aperson@dom.ain
From: bperson@dom.ain


--BOUNDARY

--BOUNDARY--
''');

    }
    function test_one_part_in_a_multipart(){
        eq = this.ndiffAssertEqual;
        outer = MIMEBase('multipart', 'mixed');
        outer['Subject'] = 'A subject';
        outer['To'] = 'aperson@dom.ain';
        outer['From'] = 'bperson@dom.ain';
        outer.set_boundary('BOUNDARY');
        msg = MIMEText('hello world');
        outer.attach(msg);
        eq(outer.as_string(), '''\
Content-Type: multipart/mixed; boundary="BOUNDARY"
MIME-Version: 1.0
Subject: A subject
To: aperson@dom.ain
From: bperson@dom.ain

--BOUNDARY
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit

hello world
--BOUNDARY--
''');

    }
    function test_seq_parts_in_a_multipart_with_empty_preamble(){
        eq = this.ndiffAssertEqual;
        outer = MIMEBase('multipart', 'mixed');
        outer['Subject'] = 'A subject';
        outer['To'] = 'aperson@dom.ain';
        outer['From'] = 'bperson@dom.ain';
        outer.preamble = '';
        msg = MIMEText('hello world');
        outer.attach(msg);
        outer.set_boundary('BOUNDARY');
        eq(outer.as_string(), '''\
Content-Type: multipart/mixed; boundary="BOUNDARY"
MIME-Version: 1.0
Subject: A subject
To: aperson@dom.ain
From: bperson@dom.ain


--BOUNDARY
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit

hello world
--BOUNDARY--
''');


    }
    function test_seq_parts_in_a_multipart_with_none_preamble(){
        eq = this.ndiffAssertEqual;
        outer = MIMEBase('multipart', 'mixed');
        outer['Subject'] = 'A subject';
        outer['To'] = 'aperson@dom.ain';
        outer['From'] = 'bperson@dom.ain';
        outer.preamble = nil;
        msg = MIMEText('hello world');
        outer.attach(msg);
        outer.set_boundary('BOUNDARY');
        eq(outer.as_string(), '''\
Content-Type: multipart/mixed; boundary="BOUNDARY"
MIME-Version: 1.0
Subject: A subject
To: aperson@dom.ain
From: bperson@dom.ain

--BOUNDARY
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit

hello world
--BOUNDARY--
''');


    }
    function test_seq_parts_in_a_multipart_with_none_epilogue(){
        eq = this.ndiffAssertEqual;
        outer = MIMEBase('multipart', 'mixed');
        outer['Subject'] = 'A subject';
        outer['To'] = 'aperson@dom.ain';
        outer['From'] = 'bperson@dom.ain';
        outer.epilogue = nil;
        msg = MIMEText('hello world');
        outer.attach(msg);
        outer.set_boundary('BOUNDARY');
        eq(outer.as_string(), '''\
Content-Type: multipart/mixed; boundary="BOUNDARY"
MIME-Version: 1.0
Subject: A subject
To: aperson@dom.ain
From: bperson@dom.ain

--BOUNDARY
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit

hello world
--BOUNDARY--
''');


    }
    function test_seq_parts_in_a_multipart_with_empty_epilogue(){
        eq = this.ndiffAssertEqual;
        outer = MIMEBase('multipart', 'mixed');
        outer['Subject'] = 'A subject';
        outer['To'] = 'aperson@dom.ain';
        outer['From'] = 'bperson@dom.ain';
        outer.epilogue = '';
        msg = MIMEText('hello world');
        outer.attach(msg);
        outer.set_boundary('BOUNDARY');
        eq(outer.as_string(), '''\
Content-Type: multipart/mixed; boundary="BOUNDARY"
MIME-Version: 1.0
Subject: A subject
To: aperson@dom.ain
From: bperson@dom.ain

--BOUNDARY
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit

hello world
--BOUNDARY--
''');


    }
    function test_seq_parts_in_a_multipart_with_nl_epilogue(){
        eq = this.ndiffAssertEqual;
        outer = MIMEBase('multipart', 'mixed');
        outer['Subject'] = 'A subject';
        outer['To'] = 'aperson@dom.ain';
        outer['From'] = 'bperson@dom.ain';
        outer.epilogue = '\n';
        msg = MIMEText('hello world');
        outer.attach(msg);
        outer.set_boundary('BOUNDARY');
        eq(outer.as_string(), '''\
Content-Type: multipart/mixed; boundary="BOUNDARY"
MIME-Version: 1.0
Subject: A subject
To: aperson@dom.ain
From: bperson@dom.ain

--BOUNDARY
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit

hello world
--BOUNDARY--

''');

    }
    function test_message_external_body(){
        eq = this.assertEqual;
        msg = this._msgobj('msg_36.txt');
        eq(len(msg.get_payload()), 2);
        msg1 = msg.get_payload(1);
        eq(msg1.get_content_type(), 'multipart/alternative');
        eq(len(msg1.get_payload()), 2);
        for subpart in msg1.get_payload(){
            eq(subpart.get_content_type(), 'message/external-body');
            eq(len(subpart.get_payload()), 1);
            subsubpart = subpart.get_payload(0);
            eq(subsubpart.get_content_type(), 'text/plain');

    }
    } function test_double_boundary(){
        # msg_37.txt is a multipart that contains two dash-boundary's in a
        # row.  Our interpretation of RFC 2046 calls for ignoring the second
        # and subsequent boundaries.
        msg = this._msgobj('msg_37.txt');
        this.assertEqual(len(msg.get_payload()), 3);

    }
    function test_nested_inner_contains_outer_boundary(){
        eq = this.ndiffAssertEqual;
        # msg_38.txt has an inner part that contains outer boundaries.  My
        # interpretation of RFC 2046 (based on sections 5.1 and 5.1.2) say
        # these are illegal and should be interpreted as unterminated inner
        # parts.
        msg = this._msgobj('msg_38.txt');
        sfp = StringIO();
        Iterators._structure(msg, sfp);
        eq(sfp.getvalue(), """\
multipart/mixed
    multipart/mixed
        multipart/alternative
            text/plain
        text/plain
    text/plain
    text/plain
""");

    }
    function test_nested_with_same_boundary(){
        eq = this.ndiffAssertEqual;
        # msg 39.txt is similarly evil in that it's got inner parts that use
        # the same boundary as outer parts.  Again, I believe the way this is
        # parsed is closest to the spirit of RFC 2046
        msg = this._msgobj('msg_39.txt');
        sfp = StringIO();
        Iterators._structure(msg, sfp);
        eq(sfp.getvalue(), """\
multipart/mixed
    multipart/mixed
        multipart/alternative
        application/octet-stream
        application/octet-stream
    text/plain
""");

    }
    function test_boundary_in_non_multipart(){
        msg = this._msgobj('msg_40.txt');
        this.assertEqual(msg.as_string(), '''\
MIME-Version: 1.0
Content-Type: text/html; boundary="--961284236552522269"

----961284236552522269
Content-Type: text/html;
Content-Transfer-Encoding: 7Bit

<html></html>

----961284236552522269--
''');

    }
    function test_boundary_with_leading_space(){
        eq = this.assertEqual;
        msg = email.message_from_string('''\
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="    XXXX"

--    XXXX
Content-Type: text/plain


--    XXXX
Content-Type: text/plain

--    XXXX--
''');
        this.assertTrue(msg.is_multipart());
        eq(msg.get_boundary(), '    XXXX');
        eq(len(msg.get_payload()), 2);

    }
    function test_boundary_without_trailing_newline(){
        m = Parser().parsestr("""\
Content-Type: multipart/mixed; boundary="===============0012394164=="
MIME-Version: 1.0

--===============0012394164==
Content-Type: image/file1.jpg
MIME-Version: 1.0
Content-Transfer-Encoding: base64

YXNkZg==
--===============0012394164==--""");
        this.assertEqual(m.get_payload(0).get_payload(), 'YXNkZg==');



# Test some badly formatted messages
}
} class TestNonConformant(TestEmailBase){
    function test_parse_missing_minor_type(){
        eq = this.assertEqual;
        msg = this._msgobj('msg_14.txt');
        eq(msg.get_content_type(), 'text/plain');
        eq(msg.get_content_maintype(), 'text');
        eq(msg.get_content_subtype(), 'plain');

    }
    function test_same_boundary_inner_outer(){
        msg = this._msgobj('msg_15.txt');
        # XXX We can probably eventually do better
        inner = msg.get_payload(0);
        this.assertTrue(hasattr(inner, 'defects'));
        this.assertEqual(len(inner.defects), 1);
        this.assertIsInstance(inner.defects[0],
                              Errors.StartBoundaryNotFoundDefect);

    }
    function test_multipart_no_boundary(){
        msg = this._msgobj('msg_25.txt');
        this.assertIsInstance(msg.get_payload(), str);
        this.assertEqual(len(msg.defects), 2);
        this.assertIsInstance(msg.defects[0],
                              Errors.NoBoundaryInMultipartDefect);
        this.assertIsInstance(msg.defects[1],
                              Errors.MultipartInvariantViolationDefect);

    }
    function test_invalid_content_type(){
        eq = this.assertEqual;
        neq = this.ndiffAssertEqual;
        msg = Message();
        # RFC 2045, $5.2 says invalid yields text/plain
        msg['Content-Type'] = 'text';
        eq(msg.get_content_maintype(), 'text');
        eq(msg.get_content_subtype(), 'plain');
        eq(msg.get_content_type(), 'text/plain');
        # Clear the old value and try something /really/ invalid
        del msg['content-type'];
        msg['Content-Type'] = 'foo';
        eq(msg.get_content_maintype(), 'text');
        eq(msg.get_content_subtype(), 'plain');
        eq(msg.get_content_type(), 'text/plain');
        # Still, make sure that the message is idempotently generated
        s = StringIO();
        g = Generator(s);
        g.flatten(msg);
        neq(s.getvalue(), 'Content-Type: foo\n\n');

    }
    function test_no_start_boundary(){
        eq = this.ndiffAssertEqual;
        msg = this._msgobj('msg_31.txt');
        eq(msg.get_payload(), """\
--BOUNDARY
Content-Type: text/plain

message 1

--BOUNDARY
Content-Type: text/plain

message 2

--BOUNDARY--
""");

    }
    function test_no_separating_blank_line(){
        eq = this.ndiffAssertEqual;
        msg = this._msgobj('msg_35.txt');
        eq(msg.as_string(), """\
From: aperson@dom.ain
To: bperson@dom.ain
Subject: here's something interesting

counter to RFC 2822, there's no separating newline here
""");

    }
    function test_lying_multipart(){
        msg = this._msgobj('msg_41.txt');
        this.assertTrue(hasattr(msg, 'defects'));
        this.assertEqual(len(msg.defects), 2);
        this.assertIsInstance(msg.defects[0],
                              Errors.NoBoundaryInMultipartDefect);
        this.assertIsInstance(msg.defects[1],
                              Errors.MultipartInvariantViolationDefect);

    }
    function test_missing_start_boundary(){
        outer = this._msgobj('msg_42.txt');
        # The message structure is:
        #
        # multipart/mixed
        #    text/plain
        #    message/rfc822
        #        multipart/mixed [*]
        #
        # [*] This message is missing its start boundary
        bad = outer.get_payload(1).get_payload(0);
        this.assertEqual(len(bad.defects), 1);
        this.assertIsInstance(bad.defects[0],
                              Errors.StartBoundaryNotFoundDefect);

    }
    function test_first_line_is_continuation_header(){
        eq = this.assertEqual;
        m = ' Line 1\nLine 2\nLine 3';
        msg = email.message_from_string(m);
        eq(msg.keys(), []);
        eq(msg.get_payload(), 'Line 2\nLine 3');
        eq(len(msg.defects), 1);
        this.assertIsInstance(msg.defects[0],
                              Errors.FirstHeaderLineIsContinuationDefect);
        eq(msg.defects[0].line, ' Line 1\n');




# Test RFC 2047 header encoding and decoding
}
} class TestRFC2047(unittest.TestCase){
    function test_rfc2047_multiline(){
        eq = this.assertEqual;
        s = """Re: =?mac-iceland?q?r=8Aksm=9Arg=8Cs?= baz
 foo bar =?mac-iceland?q?r=8Aksm=9Arg=8Cs?=""";
        dh = decode_header(s);
        eq(dh, [
            ('Re:', nil),
            ('r\x8aksm\x9arg\x8cs', 'mac-iceland'),
            ('baz foo bar', nil),
            ('r\x8aksm\x9arg\x8cs', 'mac-iceland')]);
        eq(str(make_header(dh)),
           """Re: =?mac-iceland?q?r=8Aksm=9Arg=8Cs?= baz foo bar
 =?mac-iceland?q?r=8Aksm=9Arg=8Cs?=""");

    }
    function test_whitespace_eater_unicode(){
        eq = this.assertEqual;
        s = '=?ISO-8859-1?Q?Andr=E9?= Pirard <pirard@dom.ain>';
        dh = decode_header(s);
        eq(dh, [('Andr\xe9', 'iso-8859-1'), ('Pirard <pirard@dom.ain>', nil)]);
        hu = unicode(make_header(dh)).encode('latin-1');
        eq(hu, 'Andr\xe9 Pirard <pirard@dom.ain>');

    }
    function test_whitespace_eater_unicode_2(){
        eq = this.assertEqual;
        s = 'The =?iso-8859-1?b?cXVpY2sgYnJvd24gZm94?= jumped over the =?iso-8859-1?b?bGF6eSBkb2c=?=';
        dh = decode_header(s);
        eq(dh, [('The', nil), ('quick brown fox', 'iso-8859-1'),
                ('jumped over the', nil), ('lazy dog', 'iso-8859-1')]);
        hu = make_header(dh).__unicode__();
        eq(hu, u'The quick brown fox jumped over the lazy dog');

    }
    function test_rfc2047_without_whitespace(){
        s = 'Sm=?ISO-8859-1?B?9g==?=rg=?ISO-8859-1?B?5Q==?=sbord';
        dh = decode_header(s);
        this.assertEqual(dh, [(s, nil)]);

    }
    function test_rfc2047_with_whitespace(){
        s = 'Sm =?ISO-8859-1?B?9g==?= rg =?ISO-8859-1?B?5Q==?= sbord';
        dh = decode_header(s);
        this.assertEqual(dh, [('Sm', nil), ('\xf6', 'iso-8859-1'),
                              ('rg', nil), ('\xe5', 'iso-8859-1'),
                              ('sbord', nil)]);

    }
    function test_rfc2047_B_bad_padding(){
        s = '=?iso-8859-1?B?%s?=';
        data = [                                # only test complete bytes
            ('dm==', 'v'), ('dm=', 'v'), ('dm', 'v'),
            ('dmk=', 'vi'), ('dmk', 'vi')
          ];
        for q, a in data{
            dh = decode_header(s % q);
            this.assertEqual(dh, [(a, 'iso-8859-1')]);

    }
    } function test_rfc2047_Q_invalid_digits(){
        # issue 10004.
        s = '=?iso-8859-1?Q?andr=e9=zz?=';
        this.assertEqual(decode_header(s),
                        [(b'andr\xe9=zz', 'iso-8859-1')]);


# Test the MIMEMessage class
}
} class TestMIMEMessage(TestEmailBase){
    function setUp(){
        fp = openfile('msg_11.txt');
        try{
            this._text = fp.read();
        } finally{
            fp.close();

    }
    } function test_type_error(){
        this.assertRaises(TypeError, MIMEMessage, 'a plain string');

    }
    function test_valid_argument(){
        eq = this.assertEqual;
        subject = 'A sub-message';
        m = Message();
        m['Subject'] = subject;
        r = MIMEMessage(m);
        eq(r.get_content_type(), 'message/rfc822');
        payload = r.get_payload();
        this.assertIsInstance(payload, list);
        eq(len(payload), 1);
        subpart = payload[0];
        this.assertIs(subpart, m);
        eq(subpart['subject'], subject);

    }
    function test_bad_multipart(){
        eq = this.assertEqual;
        msg1 = Message();
        msg1['Subject'] = 'subpart 1';
        msg2 = Message();
        msg2['Subject'] = 'subpart 2';
        r = MIMEMessage(msg1);
        this.assertRaises(Errors.MultipartConversionError, r.attach, msg2);

    }
    function test_generate(){
        # First craft the message to be encapsulated
        m = Message();
        m['Subject'] = 'An enclosed message';
        m.set_payload('Here is the body of the message.\n');
        r = MIMEMessage(m);
        r['Subject'] = 'The enclosing message';
        s = StringIO();
        g = Generator(s);
        g.flatten(r);
        this.assertEqual(s.getvalue(), """\
Content-Type: message/rfc822
MIME-Version: 1.0
Subject: The enclosing message

Subject: An enclosed message

Here is the body of the message.
""");

    }
    function test_parse_message_rfc822(){
        eq = this.assertEqual;
        msg = this._msgobj('msg_11.txt');
        eq(msg.get_content_type(), 'message/rfc822');
        payload = msg.get_payload();
        this.assertIsInstance(payload, list);
        eq(len(payload), 1);
        submsg = payload[0];
        this.assertIsInstance(submsg, Message);
        eq(submsg['subject'], 'An enclosed message');
        eq(submsg.get_payload(), 'Here is the body of the message.\n');

    }
    function test_dsn(){
        eq = this.assertEqual;
        # msg 16 is a Delivery Status Notification, see RFC 1894
        msg = this._msgobj('msg_16.txt');
        eq(msg.get_content_type(), 'multipart/report');
        this.assertTrue(msg.is_multipart());
        eq(len(msg.get_payload()), 3);
        # Subpart 1 is a text/plain, human readable section
        subpart = msg.get_payload(0);
        eq(subpart.get_content_type(), 'text/plain');
        eq(subpart.get_payload(), """\
This report relates to a message you sent with the following header fields:

  Message-id: <002001c144a6$8752e060$56104586@oxy.edu>
  Date: Sun, 23 Sep 2001 20:10:55 -0700
  From: "Ian T. Henry" <henryi@oxy.edu>
  To: SoCal Raves <scr@socal-raves.org>
  Subject: [scr] yeah for Ians!!

Your message cannot be delivered to the following recipients:

  Recipient address: jangel1@cougar.noc.ucla.edu
  Reason: recipient reached disk quota

""");
        # Subpart 2 contains the machine parsable DSN information.  It
        # consists of two blocks of headers, represented by two nested Message
        # objects.
        subpart = msg.get_payload(1);
        eq(subpart.get_content_type(), 'message/delivery-status');
        eq(len(subpart.get_payload()), 2);
        # message/delivery-status should treat each block as a bunch of
        # headers, i.e. a bunch of Message objects.
        dsn1 = subpart.get_payload(0);
        this.assertIsInstance(dsn1, Message);
        eq(dsn1['original-envelope-id'], '0GK500B4HD0888@cougar.noc.ucla.edu');
        eq(dsn1.get_param('dns', header='reporting-mta'), '');
        # Try a missing one <wink>
        eq(dsn1.get_param('nsd', header='reporting-mta'), nil);
        dsn2 = subpart.get_payload(1);
        this.assertIsInstance(dsn2, Message);
        eq(dsn2['action'], 'failed');
        eq(dsn2.get_params(header='original-recipient'),
           [('rfc822', ''), ('jangel1@cougar.noc.ucla.edu', '')]);
        eq(dsn2.get_param('rfc822', header='final-recipient'), '');
        # Subpart 3 is the original message
        subpart = msg.get_payload(2);
        eq(subpart.get_content_type(), 'message/rfc822');
        payload = subpart.get_payload();
        this.assertIsInstance(payload, list);
        eq(len(payload), 1);
        subsubpart = payload[0];
        this.assertIsInstance(subsubpart, Message);
        eq(subsubpart.get_content_type(), 'text/plain');
        eq(subsubpart['message-id'],
           '<002001c144a6$8752e060$56104586@oxy.edu>');

    }
    function test_epilogue(){
        eq = this.ndiffAssertEqual;
        fp = openfile('msg_21.txt');
        try{
            text = fp.read();
        } finally{
            fp.close();
        } msg = Message();
        msg['From'] = 'aperson@dom.ain';
        msg['To'] = 'bperson@dom.ain';
        msg['Subject'] = 'Test';
        msg.preamble = 'MIME message';
        msg.epilogue = 'End of MIME message\n';
        msg1 = MIMEText('One');
        msg2 = MIMEText('Two');
        msg.add_header('Content-Type', 'multipart/mixed', boundary='BOUNDARY');
        msg.attach(msg1);
        msg.attach(msg2);
        sfp = StringIO();
        g = Generator(sfp);
        g.flatten(msg);
        eq(sfp.getvalue(), text);

    }
    function test_no_nl_preamble(){
        eq = this.ndiffAssertEqual;
        msg = Message();
        msg['From'] = 'aperson@dom.ain';
        msg['To'] = 'bperson@dom.ain';
        msg['Subject'] = 'Test';
        msg.preamble = 'MIME message';
        msg.epilogue = '';
        msg1 = MIMEText('One');
        msg2 = MIMEText('Two');
        msg.add_header('Content-Type', 'multipart/mixed', boundary='BOUNDARY');
        msg.attach(msg1);
        msg.attach(msg2);
        eq(msg.as_string(), """\
From: aperson@dom.ain
To: bperson@dom.ain
Subject: Test
Content-Type: multipart/mixed; boundary="BOUNDARY"

MIME message
--BOUNDARY
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit

One
--BOUNDARY
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit

Two
--BOUNDARY--
""");

    }
    function test_default_type(){
        eq = this.assertEqual;
        fp = openfile('msg_30.txt');
        try{
            msg = email.message_from_file(fp);
        } finally{
            fp.close();
        } container1 = msg.get_payload(0);
        eq(container1.get_default_type(), 'message/rfc822');
        eq(container1.get_content_type(), 'message/rfc822');
        container2 = msg.get_payload(1);
        eq(container2.get_default_type(), 'message/rfc822');
        eq(container2.get_content_type(), 'message/rfc822');
        container1a = container1.get_payload(0);
        eq(container1a.get_default_type(), 'text/plain');
        eq(container1a.get_content_type(), 'text/plain');
        container2a = container2.get_payload(0);
        eq(container2a.get_default_type(), 'text/plain');
        eq(container2a.get_content_type(), 'text/plain');

    }
    function test_default_type_with_explicit_container_type(){
        eq = this.assertEqual;
        fp = openfile('msg_28.txt');
        try{
            msg = email.message_from_file(fp);
        } finally{
            fp.close();
        } container1 = msg.get_payload(0);
        eq(container1.get_default_type(), 'message/rfc822');
        eq(container1.get_content_type(), 'message/rfc822');
        container2 = msg.get_payload(1);
        eq(container2.get_default_type(), 'message/rfc822');
        eq(container2.get_content_type(), 'message/rfc822');
        container1a = container1.get_payload(0);
        eq(container1a.get_default_type(), 'text/plain');
        eq(container1a.get_content_type(), 'text/plain');
        container2a = container2.get_payload(0);
        eq(container2a.get_default_type(), 'text/plain');
        eq(container2a.get_content_type(), 'text/plain');

    }
    function test_default_type_non_parsed(){
        eq = this.assertEqual;
        neq = this.ndiffAssertEqual;
        # Set up container
        container = MIMEMultipart('digest', 'BOUNDARY');
        container.epilogue = '';
        # Set up subparts
        subpart1a = MIMEText('message 1\n');
        subpart2a = MIMEText('message 2\n');
        subpart1 = MIMEMessage(subpart1a);
        subpart2 = MIMEMessage(subpart2a);
        container.attach(subpart1);
        container.attach(subpart2);
        eq(subpart1.get_content_type(), 'message/rfc822');
        eq(subpart1.get_default_type(), 'message/rfc822');
        eq(subpart2.get_content_type(), 'message/rfc822');
        eq(subpart2.get_default_type(), 'message/rfc822');
        neq(container.as_string(0), '''\
Content-Type: multipart/digest; boundary="BOUNDARY"
MIME-Version: 1.0

--BOUNDARY
Content-Type: message/rfc822
MIME-Version: 1.0

Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit

message 1

--BOUNDARY
Content-Type: message/rfc822
MIME-Version: 1.0

Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit

message 2

--BOUNDARY--
''');
        del subpart1['content-type'];
        del subpart1['mime-version'];
        del subpart2['content-type'];
        del subpart2['mime-version'];
        eq(subpart1.get_content_type(), 'message/rfc822');
        eq(subpart1.get_default_type(), 'message/rfc822');
        eq(subpart2.get_content_type(), 'message/rfc822');
        eq(subpart2.get_default_type(), 'message/rfc822');
        neq(container.as_string(0), '''\
Content-Type: multipart/digest; boundary="BOUNDARY"
MIME-Version: 1.0

--BOUNDARY

Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit

message 1

--BOUNDARY

Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit

message 2

--BOUNDARY--
''');

    }
    function test_mime_attachments_in_constructor(){
        eq = this.assertEqual;
        text1 = MIMEText('');
        text2 = MIMEText('');
        msg = MIMEMultipart(_subparts=(text1, text2));
        eq(len(msg.get_payload()), 2);
        eq(msg.get_payload(0), text1);
        eq(msg.get_payload(1), text2);

    }
    function test_default_multipart_constructor(){
        msg = MIMEMultipart();
        this.assertTrue(msg.is_multipart());


# A general test of parser->model->generator idempotency.  IOW, read a message
# in, parse it into a message object tree, then without touching the tree,
# regenerate the plain text.  The original text and the transformed text
# should be identical.  Note: that we ignore the Unix-From since that may
# contain a changed date.
}
} class TestIdempotent(TestEmailBase){
    function _msgobj( filename){
        fp = openfile(filename);
        try{
            data = fp.read();
        } finally{
            fp.close();
        } msg = email.message_from_string(data);
        return msg, data;

    }
    function _idempotent( msg, text){
        eq = this.ndiffAssertEqual;
        s = StringIO();
        g = Generator(s, maxheaderlen=0);
        g.flatten(msg);
        eq(text, s.getvalue());

    }
    function test_parse_text_message(){
        eq = this.assertEqual;
        msg, text = this._msgobj('msg_01.txt');
        eq(msg.get_content_type(), 'text/plain');
        eq(msg.get_content_maintype(), 'text');
        eq(msg.get_content_subtype(), 'plain');
        eq(msg.get_params()[1], ('charset', 'us-ascii'));
        eq(msg.get_param('charset'), 'us-ascii');
        eq(msg.preamble, nil);
        eq(msg.epilogue, nil);
        this._idempotent(msg, text);

    }
    function test_parse_untyped_message(){
        eq = this.assertEqual;
        msg, text = this._msgobj('msg_03.txt');
        eq(msg.get_content_type(), 'text/plain');
        eq(msg.get_params(), nil);
        eq(msg.get_param('charset'), nil);
        this._idempotent(msg, text);

    }
    function test_simple_multipart(){
        msg, text = this._msgobj('msg_04.txt');
        this._idempotent(msg, text);

    }
    function test_MIME_digest(){
        msg, text = this._msgobj('msg_02.txt');
        this._idempotent(msg, text);

    }
    function test_long_header(){
        msg, text = this._msgobj('msg_27.txt');
        this._idempotent(msg, text);

    }
    function test_MIME_digest_with_part_headers(){
        msg, text = this._msgobj('msg_28.txt');
        this._idempotent(msg, text);

    }
    function test_mixed_with_image(){
        msg, text = this._msgobj('msg_06.txt');
        this._idempotent(msg, text);

    }
    function test_multipart_report(){
        msg, text = this._msgobj('msg_05.txt');
        this._idempotent(msg, text);

    }
    function test_dsn(){
        msg, text = this._msgobj('msg_16.txt');
        this._idempotent(msg, text);

    }
    function test_preamble_epilogue(){
        msg, text = this._msgobj('msg_21.txt');
        this._idempotent(msg, text);

    }
    function test_multipart_one_part(){
        msg, text = this._msgobj('msg_23.txt');
        this._idempotent(msg, text);

    }
    function test_multipart_no_parts(){
        msg, text = this._msgobj('msg_24.txt');
        this._idempotent(msg, text);

    }
    function test_no_start_boundary(){
        msg, text = this._msgobj('msg_31.txt');
        this._idempotent(msg, text);

    }
    function test_rfc2231_charset(){
        msg, text = this._msgobj('msg_32.txt');
        this._idempotent(msg, text);

    }
    function test_more_rfc2231_parameters(){
        msg, text = this._msgobj('msg_33.txt');
        this._idempotent(msg, text);

    }
    function test_text_plain_in_a_multipart_digest(){
        msg, text = this._msgobj('msg_34.txt');
        this._idempotent(msg, text);

    }
    function test_nested_multipart_mixeds(){
        msg, text = this._msgobj('msg_12a.txt');
        this._idempotent(msg, text);

    }
    function test_message_external_body_idempotent(){
        msg, text = this._msgobj('msg_36.txt');
        this._idempotent(msg, text);

    }
    function test_content_type(){
        eq = this.assertEqual;
        # Get a message object and reset the seek pointer for other tests
        msg, text = this._msgobj('msg_05.txt');
        eq(msg.get_content_type(), 'multipart/report');
        # Test the Content-Type: parameters
        params = {};
        for pk, pv in msg.get_params(){
            params[pk] = pv;
        } eq(params['report-type'], 'delivery-status');
        eq(params['boundary'], 'D1690A7AC1.996856090/mail.example.com');
        eq(msg.preamble, 'This is a MIME-encapsulated message.\n');
        eq(msg.epilogue, '\n');
        eq(len(msg.get_payload()), 3);
        # Make sure the subparts are what we expect
        msg1 = msg.get_payload(0);
        eq(msg1.get_content_type(), 'text/plain');
        eq(msg1.get_payload(), 'Yadda yadda yadda\n');
        msg2 = msg.get_payload(1);
        eq(msg2.get_content_type(), 'text/plain');
        eq(msg2.get_payload(), 'Yadda yadda yadda\n');
        msg3 = msg.get_payload(2);
        eq(msg3.get_content_type(), 'message/rfc822');
        this.assertIsInstance(msg3, Message);
        payload = msg3.get_payload();
        this.assertIsInstance(payload, list);
        eq(len(payload), 1);
        msg4 = payload[0];
        this.assertIsInstance(msg4, Message);
        eq(msg4.get_payload(), 'Yadda yadda yadda\n');

    }
    function test_parser(){
        eq = this.assertEqual;
        msg, text = this._msgobj('msg_06.txt');
        # Check some of the outer headers
        eq(msg.get_content_type(), 'message/rfc822');
        # Make sure the payload is a list of exactly one sub-Message, and that
        # that submessage has a type of text/plain
        payload = msg.get_payload();
        this.assertIsInstance(payload, list);
        eq(len(payload), 1);
        msg1 = payload[0];
        this.assertIsInstance(msg1, Message);
        eq(msg1.get_content_type(), 'text/plain');
        this.assertIsInstance(msg1.get_payload(), str);
        eq(msg1.get_payload(), '\n');



# Test various other bits of the package's functionality
}
} class TestMiscellaneous(TestEmailBase){
    function test_message_from_string(){
        fp = openfile('msg_01.txt');
        try{
            text = fp.read();
        } finally{
            fp.close();
        } msg = email.message_from_string(text);
        s = StringIO();
        # Don't wrap/continue long headers since we're trying to test
        # idempotency.
        g = Generator(s, maxheaderlen=0);
        g.flatten(msg);
        this.assertEqual(text, s.getvalue());

    }
    function test_message_from_file(){
        fp = openfile('msg_01.txt');
        try{
            text = fp.read();
            fp.seek(0);
            msg = email.message_from_file(fp);
            s = StringIO();
            # Don't wrap/continue long headers since we're trying to test
            # idempotency.
            g = Generator(s, maxheaderlen=0);
            g.flatten(msg);
            this.assertEqual(text, s.getvalue());
        } finally{
            fp.close();

    }
    } function test_message_from_string_with_class(){
        fp = openfile('msg_01.txt');
        try{
            text = fp.read();
        } finally{
            fp.close();
        # Create a subclass
        }
        class MyMessage(Message){
            pass;

        }
        msg = email.message_from_string(text, MyMessage);
        this.assertIsInstance(msg, MyMessage);
        # Try something more complicated
        fp = openfile('msg_02.txt');
        try{
            text = fp.read();
        } finally{
            fp.close();
        } msg = email.message_from_string(text, MyMessage);
        for subpart in msg.walk(){
            this.assertIsInstance(subpart, MyMessage);

    }
    } function test_message_from_file_with_class(){
        # Create a subclass
        class MyMessage(Message){
            pass;

        }
        fp = openfile('msg_01.txt');
        try{
            msg = email.message_from_file(fp, MyMessage);
        } finally{
            fp.close();
        } this.assertIsInstance(msg, MyMessage);
        # Try something more complicated
        fp = openfile('msg_02.txt');
        try{
            msg = email.message_from_file(fp, MyMessage);
        } finally{
            fp.close();
        } for subpart in msg.walk(){
            this.assertIsInstance(subpart, MyMessage);

    }
    } function test__all__(){
        module = __import__('email');
        all = module.__all__;
        all.sort();
        this.assertEqual(all, [
            # Old names
            'Charset', 'Encoders', 'Errors', 'Generator',
            'Header', 'Iterators', 'MIMEAudio', 'MIMEBase',
            'MIMEImage', 'MIMEMessage', 'MIMEMultipart',
            'MIMENonMultipart', 'MIMEText', 'Message',
            'Parser', 'Utils', 'base64MIME',
            # new names
            'base64mime', 'charset', 'encoders', 'errors', 'generator',
            'header', 'iterators', 'message', 'message_from_file',
            'message_from_string', 'mime', 'parser',
            'quopriMIME', 'quoprimime', 'utils',
            ]);

    }
    function test_formatdate(){
        now = time.time();
        this.assertEqual(Utils.parsedate(Utils.formatdate(now))[:6],
                         time.gmtime(now)[:6]);

    }
    function test_formatdate_localtime(){
        now = time.time();
        this.assertEqual(
            Utils.parsedate(Utils.formatdate(now, localtime=true))[:6],
            time.localtime(now)[:6]);

    }
    function test_formatdate_usegmt(){
        now = time.time();
        this.assertEqual(
            Utils.formatdate(now, localtime=false),
            time.strftime('%a, %d %b %Y %H:%M:%S -0000', time.gmtime(now)));
        this.assertEqual(
            Utils.formatdate(now, localtime=false, usegmt=true),
            time.strftime('%a, %d %b %Y %H:%M:%S GMT', time.gmtime(now)));

    }
    function test_parsedate_none(){
        this.assertEqual(Utils.parsedate(''), nil);

    }
    function test_parsedate_compact(){
        # The FWS after the comma is optional
        this.assertEqual(Utils.parsedate('Wed,3 Apr 2002 14:58:26 +0800'),
                         Utils.parsedate('Wed, 3 Apr 2002 14:58:26 +0800'));

    }
    function test_parsedate_no_dayofweek(){
        eq = this.assertEqual;
        eq(Utils.parsedate_tz('25 Feb 2003 13:47:26 -0800'),
           (2003, 2, 25, 13, 47, 26, 0, 1, -1, -28800));

    }
    function test_parsedate_compact_no_dayofweek(){
        eq = this.assertEqual;
        eq(Utils.parsedate_tz('5 Feb 2003 13:47:26 -0800'),
           (2003, 2, 5, 13, 47, 26, 0, 1, -1, -28800));

    }
    function test_parsedate_acceptable_to_time_functions(){
        eq = this.assertEqual;
        timetup = Utils.parsedate('5 Feb 2003 13:47:26 -0800');
        t = int(time.mktime(timetup));
        eq(time.localtime(t)[:6], timetup[:6]);
        eq(int(time.strftime('%Y', timetup)), 2003);
        timetup = Utils.parsedate_tz('5 Feb 2003 13:47:26 -0800');
        t = int(time.mktime(timetup[:9]));
        eq(time.localtime(t)[:6], timetup[:6]);
        eq(int(time.strftime('%Y', timetup[:9])), 2003);

    }
    function test_mktime_tz(){
        this.assertEqual(Utils.mktime_tz((1970, 1, 1, 0, 0, 0,
                                          -1, -1, -1, 0)), 0);
        this.assertEqual(Utils.mktime_tz((1970, 1, 1, 0, 0, 0,
                                          -1, -1, -1, 1234)), -1234);

    }
    function test_parsedate_y2k(){
        """Test for parsing a date with a two-digit year.

        Parsing a date with a two-digit year should return the correct
        four-digit year. RFC822 allows two-digit years, but RFC2822 (which
        obsoletes RFC822) requires four-digit years.

        """;
        this.assertEqual(Utils.parsedate_tz('25 Feb 03 13:47:26 -0800'),
                         Utils.parsedate_tz('25 Feb 2003 13:47:26 -0800'));
        this.assertEqual(Utils.parsedate_tz('25 Feb 71 13:47:26 -0800'),
                         Utils.parsedate_tz('25 Feb 1971 13:47:26 -0800'));

    }
    function test_parseaddr_empty(){
        this.assertEqual(Utils.parseaddr('<>'), ('', ''));
        this.assertEqual(Utils.formataddr(Utils.parseaddr('<>')), '');

    }
    function test_noquote_dump(){
        this.assertEqual(
            Utils.formataddr(('A Silly Person', 'person@dom.ain')),
            'A Silly Person <person@dom.ain>');

    }
    function test_escape_dump(){
        this.assertEqual(
            Utils.formataddr(('A (Very) Silly Person', 'person@dom.ain')),
            r'"A \(Very\) Silly Person" <person@dom.ain>');
        a = r'A \(Special\) Person';
        b = 'person@dom.ain';
        this.assertEqual(Utils.parseaddr(Utils.formataddr((a, b))), (a, b));

    }
    function test_escape_backslashes(){
        this.assertEqual(
            Utils.formataddr(('Arthur \Backslash\ Foobar', 'person@dom.ain')),
            r'"Arthur \\Backslash\\ Foobar" <person@dom.ain>');
        a = r'Arthur \Backslash\ Foobar';
        b = 'person@dom.ain';
        this.assertEqual(Utils.parseaddr(Utils.formataddr((a, b))), (a, b));

    }
    function test_name_with_dot(){
        x = 'John X. Doe <jxd@example.com>';
        y = '"John X. Doe" <jxd@example.com>';
        a, b = ('John X. Doe', 'jxd@example.com');
        this.assertEqual(Utils.parseaddr(x), (a, b));
        this.assertEqual(Utils.parseaddr(y), (a, b));
        # formataddr() quotes the name if there's a dot in it
        this.assertEqual(Utils.formataddr((a, b)), y);

    }
    function test_parseaddr_preserves_quoted_pairs_in_addresses(){
        # issue 10005.  Note that in the third test the second pair of
        # backslashes is not actually a quoted pair because it is not inside a
        # comment or quoted string: the address being parsed has a quoted
        # string containing a quoted backslash, followed by 'example' and two
        # backslashes, followed by another quoted string containing a space and
        # the word 'example'.  parseaddr copies those two backslashes
        # literally.  Per rfc5322 this is not technically correct since a \ may
        # not appear in an address outside of a quoted string.  It is probably
        # a sensible Postel interpretation, though.
        eq = this.assertEqual;
        eq(Utils.parseaddr('""example" example"@example.com'),
          ('', '""example" example"@example.com'));
        eq(Utils.parseaddr('"\\"example\\" example"@example.com'),
          ('', '"\\"example\\" example"@example.com'));
        eq(Utils.parseaddr('"\\\\"example\\\\" example"@example.com'),
          ('', '"\\\\"example\\\\" example"@example.com'));

    }
    function test_multiline_from_comment(){
        x = """\
Foo
\tBar <foo@example.com>""";
        this.assertEqual(Utils.parseaddr(x), ('Foo Bar', 'foo@example.com'));

    }
    function test_quote_dump(){
        this.assertEqual(
            Utils.formataddr(('A Silly; Person', 'person@dom.ain')),
            r'"A Silly; Person" <person@dom.ain>');

    }
    function test_fix_eols(){
        eq = this.assertEqual;
        eq(Utils.fix_eols('hello'), 'hello');
        eq(Utils.fix_eols('hello\n'), 'hello\r\n');
        eq(Utils.fix_eols('hello\r'), 'hello\r\n');
        eq(Utils.fix_eols('hello\r\n'), 'hello\r\n');
        eq(Utils.fix_eols('hello\n\r'), 'hello\r\n\r\n');

    }
    function test_charset_richcomparisons(){
        eq = this.assertEqual;
        ne = this.assertNotEqual;
        cset1 = Charset();
        cset2 = Charset();
        eq(cset1, 'us-ascii');
        eq(cset1, 'US-ASCII');
        eq(cset1, 'Us-AsCiI');
        eq('us-ascii', cset1);
        eq('US-ASCII', cset1);
        eq('Us-AsCiI', cset1);
        ne(cset1, 'usascii');
        ne(cset1, 'USASCII');
        ne(cset1, 'UsAsCiI');
        ne('usascii', cset1);
        ne('USASCII', cset1);
        ne('UsAsCiI', cset1);
        eq(cset1, cset2);
        eq(cset2, cset1);

    }
    function test_getaddresses(){
        eq = this.assertEqual;
        eq(Utils.getaddresses(['aperson@dom.ain (Al Person)',
                               'Bud Person <bperson@dom.ain>']),
           [('Al Person', 'aperson@dom.ain'),
            ('Bud Person', 'bperson@dom.ain')]);

    }
    function test_getaddresses_nasty(){
        eq = this.assertEqual;
        eq(Utils.getaddresses(['foo: ;']), [('', '')]);
        eq(Utils.getaddresses(
           ['[]*-- =~$']),
           [('', ''), ('', ''), ('', '*--')]);
        eq(Utils.getaddresses(
           ['foo: ;', '"Jason R. Mastaler" <jason@dom.ain>']),
           [('', ''), ('Jason R. Mastaler', 'jason@dom.ain')]);

    }
    function test_getaddresses_embedded_comment(){
        """Test proper handling of a nested comment""";
        eq = this.assertEqual;
        addrs = Utils.getaddresses(['User ((nested comment)) <foo@bar.com>']);
        eq(addrs[0][1], 'foo@bar.com');

    }
    function test_make_msgid_collisions(){
        # Test make_msgid uniqueness, even with multiple threads
        class MsgidsThread(Thread){
            function run(){
                # generate msgids for 3 seconds
                this.msgids = [];
                append = this.msgids.append;
                make_msgid = Utils.make_msgid;
                clock = time.time;
                tfin = clock() + 3.0;
                while clock() < tfin{
                    append(make_msgid());

        }
        } } threads = [MsgidsThread() for i in range(5)];
        with start_threads(threads){
            pass;
        } all_ids = sum([t.msgids for t in threads], []);
        this.assertEqual(len(set(all_ids)), len(all_ids));

    }
    function test_utils_quote_unquote(){
        eq = this.assertEqual;
        msg = Message();
        msg.add_header('content-disposition', 'attachment',
                       filename='foo\\wacky"name');
        eq(msg.get_filename(), 'foo\\wacky"name');

    }
    function test_get_body_encoding_with_bogus_charset(){
        charset = Charset('not a charset');
        this.assertEqual(charset.get_body_encoding(), 'base64');

    }
    function test_get_body_encoding_with_uppercase_charset(){
        eq = this.assertEqual;
        msg = Message();
        msg['Content-Type'] = 'text/plain; charset=UTF-8';
        eq(msg['content-type'], 'text/plain; charset=UTF-8');
        charsets = msg.get_charsets();
        eq(len(charsets), 1);
        eq(charsets[0], 'utf-8');
        charset = Charset(charsets[0]);
        eq(charset.get_body_encoding(), 'base64');
        msg.set_payload('hello world', charset=charset);
        eq(msg.get_payload(), 'aGVsbG8gd29ybGQ=\n');
        eq(msg.get_payload(decode=true), 'hello world');
        eq(msg['content-transfer-encoding'], 'base64');
        # Try another one
        msg = Message();
        msg['Content-Type'] = 'text/plain; charset="US-ASCII"';
        charsets = msg.get_charsets();
        eq(len(charsets), 1);
        eq(charsets[0], 'us-ascii');
        charset = Charset(charsets[0]);
        eq(charset.get_body_encoding(), Encoders.encode_7or8bit);
        msg.set_payload('hello world', charset=charset);
        eq(msg.get_payload(), 'hello world');
        eq(msg['content-transfer-encoding'], '7bit');

    }
    function test_charsets_case_insensitive(){
        lc = Charset('us-ascii');
        uc = Charset('US-ASCII');
        this.assertEqual(lc.get_body_encoding(), uc.get_body_encoding());

    }
    function test_partial_falls_inside_message_delivery_status(){
        eq = this.ndiffAssertEqual;
        # The Parser interface provides chunks of data to FeedParser in 8192
        # byte gulps.  SF bug #1076485 found one of those chunks inside
        # message/delivery-status header block, which triggered an
        # unreadline() of NeedMoreData.
        msg = this._msgobj('msg_43.txt');
        sfp = StringIO();
        Iterators._structure(msg, sfp);
        eq(sfp.getvalue(), """\
multipart/report
    text/plain
    message/delivery-status
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
        text/plain
    text/rfc822-headers
""");



# Test the iterator/generators
}
} class TestIterators(TestEmailBase){
    function test_body_line_iterator(){
        eq = this.assertEqual;
        neq = this.ndiffAssertEqual;
        # First a simple non-multipart message
        msg = this._msgobj('msg_01.txt');
        it = Iterators.body_line_iterator(msg);
        lines = list(it);
        eq(len(lines), 6);
        neq(EMPTYSTRING.join(lines), msg.get_payload());
        # Now a more complicated multipart
        msg = this._msgobj('msg_02.txt');
        it = Iterators.body_line_iterator(msg);
        lines = list(it);
        eq(len(lines), 43);
        fp = openfile('msg_19.txt');
        try{
            neq(EMPTYSTRING.join(lines), fp.read());
        } finally{
            fp.close();

    }
    } function test_typed_subpart_iterator(){
        eq = this.assertEqual;
        msg = this._msgobj('msg_04.txt');
        it = Iterators.typed_subpart_iterator(msg, 'text');
        lines = [];
        subparts = 0;
        for subpart in it{
            subparts += 1;
            lines.append(subpart.get_payload());
        } eq(subparts, 2);
        eq(EMPTYSTRING.join(lines), """\
a simple kind of mirror
to reflect upon our own
a simple kind of mirror
to reflect upon our own
""");

    }
    function test_typed_subpart_iterator_default_type(){
        eq = this.assertEqual;
        msg = this._msgobj('msg_03.txt');
        it = Iterators.typed_subpart_iterator(msg, 'text', 'plain');
        lines = [];
        subparts = 0;
        for subpart in it{
            subparts += 1;
            lines.append(subpart.get_payload());
        } eq(subparts, 1);
        eq(EMPTYSTRING.join(lines), """\

Hi,

Do you like this message?

-Me
""");

    }
    function test_pushCR_LF(){
        '''FeedParser BufferedSubFile.push() assumed it received complete
           line endings.  A CR ending one push() followed by a LF starting
           the next push() added an empty line.
        ''';
        imt = [
            ("a\r \n",  2),
            ("b",       0),
            ("c\n",     1),
            ("",        0),
            ("d\r\n",   1),
            ("e\r",     0),
            ("\nf",     1),
            ("\r\n",    1),
          ];
        from email.feedparser import BufferedSubFile, NeedMoreData;
        bsf = BufferedSubFile();
        om = [];
        nt = 0;
        for il, n in imt{
            bsf.push(il);
            nt += n;
            n1 = 0;
            for ol in iter(bsf.readline, NeedMoreData){
                om.append(ol);
                n1 += 1;
            } this.assertEqual(n, n1);
        } this.assertEqual(len(om), nt);
        this.assertEqual(''.join([il for il, n in imt]), ''.join(om));

    }
    function test_push_random(){
        from email.feedparser import BufferedSubFile, NeedMoreData;

        n = 10000;
        chunksize = 5;
        chars = 'abcd \t\r\n';

        s = ''.join(choice(chars) for i in range(n)) + '\n';
        target = s.splitlines(true);

        bsf = BufferedSubFile();
        lines = [];
        for i in range(0, len(s), chunksize){
            chunk = s[i:i+chunksize];
            bsf.push(chunk);
            lines.extend(iter(bsf.readline, NeedMoreData));
        } this.assertEqual(lines, target);


}
} class TestFeedParsers(TestEmailBase){

    function parse( chunks){
        from email.feedparser import FeedParser;
        feedparser = FeedParser();
        for chunk in chunks{
            feedparser.feed(chunk);
        } return feedparser.close();

    }
    function test_newlines(){
        m = this.parse(['a:\nb:\rc:\r\nd:\n']);
        this.assertEqual(m.keys(), ['a', 'b', 'c', 'd']);
        m = this.parse(['a:\nb:\rc:\r\nd:']);
        this.assertEqual(m.keys(), ['a', 'b', 'c', 'd']);
        m = this.parse(['a:\rb', 'c:\n']);
        this.assertEqual(m.keys(), ['a', 'bc']);
        m = this.parse(['a:\r', 'b:\n']);
        this.assertEqual(m.keys(), ['a', 'b']);
        m = this.parse(['a:\r', '\nb:\n']);
        this.assertEqual(m.keys(), ['a', 'b']);

    }
    function test_long_lines(){
        # Expected peak memory use on 32-bit platform: 4*N*M bytes.
        M, N = 1000, 20000;
        m = this.parse(['a:b\n\n'] + ['x'*M] * N);
        this.assertEqual(m.items(), [('a', 'b')]);
        this.assertEqual(m.get_payload(), 'x'*M*N);
        m = this.parse(['a:b\r\r'] + ['x'*M] * N);
        this.assertEqual(m.items(), [('a', 'b')]);
        this.assertEqual(m.get_payload(), 'x'*M*N);
        m = this.parse(['a:\r', 'b: '] + ['x'*M] * N);
        this.assertEqual(m.items(), [('a', ''), ('b', 'x'*M*N)]);


}
} class TestParsers(TestEmailBase){
    function test_header_parser(){
        eq = this.assertEqual;
        # Parse only the headers of a complex multipart MIME document
        fp = openfile('msg_02.txt');
        try{
            msg = HeaderParser().parse(fp);
        } finally{
            fp.close();
        } eq(msg['from'], 'ppp-request@zzz.org');
        eq(msg['to'], 'ppp@zzz.org');
        eq(msg.get_content_type(), 'multipart/mixed');
        this.assertFalse(msg.is_multipart());
        this.assertIsInstance(msg.get_payload(), str);

    }
    function test_whitespace_continuation(){
        eq = this.assertEqual;
        # This message contains a line after the Subject: header that has only
        # whitespace, but it is not empty!
        msg = email.message_from_string("""\
From: aperson@dom.ain
To: bperson@dom.ain
Subject: the next line has a space on it
\x20
Date: Mon, 8 Apr 2002 15:09:19 -0400
Message-ID: spam

Here's the message body
""");
        eq(msg['subject'], 'the next line has a space on it\n ');
        eq(msg['message-id'], 'spam');
        eq(msg.get_payload(), "Here's the message body\n");

    }
    function test_whitespace_continuation_last_header(){
        eq = this.assertEqual;
        # Like the previous test, but the subject line is the last
        # header.
        msg = email.message_from_string("""\
From: aperson@dom.ain
To: bperson@dom.ain
Date: Mon, 8 Apr 2002 15:09:19 -0400
Message-ID: spam
Subject: the next line has a space on it
\x20

Here's the message body
""");
        eq(msg['subject'], 'the next line has a space on it\n ');
        eq(msg['message-id'], 'spam');
        eq(msg.get_payload(), "Here's the message body\n");

    }
    function test_crlf_separation(){
        eq = this.assertEqual;
        fp = openfile('msg_26.txt', mode='rb');
        try{
            msg = Parser().parse(fp);
        } finally{
            fp.close();
        } eq(len(msg.get_payload()), 2);
        part1 = msg.get_payload(0);
        eq(part1.get_content_type(), 'text/plain');
        eq(part1.get_payload(), 'Simple email with attachment.\r\n\r\n');
        part2 = msg.get_payload(1);
        eq(part2.get_content_type(), 'application/riscos');

    }
    function test_multipart_digest_with_extra_mime_headers(){
        eq = this.assertEqual;
        neq = this.ndiffAssertEqual;
        fp = openfile('msg_28.txt');
        try{
            msg = email.message_from_file(fp);
        } finally{
            fp.close();
        # Structure is:
        # multipart/digest
        #   message/rfc822
        #     text/plain
        #   message/rfc822
        #     text/plain
        }
        eq(msg.is_multipart(), 1);
        eq(len(msg.get_payload()), 2);
        part1 = msg.get_payload(0);
        eq(part1.get_content_type(), 'message/rfc822');
        eq(part1.is_multipart(), 1);
        eq(len(part1.get_payload()), 1);
        part1a = part1.get_payload(0);
        eq(part1a.is_multipart(), 0);
        eq(part1a.get_content_type(), 'text/plain');
        neq(part1a.get_payload(), 'message 1\n');
        # next message/rfc822
        part2 = msg.get_payload(1);
        eq(part2.get_content_type(), 'message/rfc822');
        eq(part2.is_multipart(), 1);
        eq(len(part2.get_payload()), 1);
        part2a = part2.get_payload(0);
        eq(part2a.is_multipart(), 0);
        eq(part2a.get_content_type(), 'text/plain');
        neq(part2a.get_payload(), 'message 2\n');

    }
    function test_three_lines(){
        # A bug report by Andrew McNamara
        lines = ['From: Andrew Person <aperson@dom.ain',
                 'Subject: Test',
                 'Date: Tue, 20 Aug 2002 16:43:45 +1000'];
        msg = email.message_from_string(NL.join(lines));
        this.assertEqual(msg['date'], 'Tue, 20 Aug 2002 16:43:45 +1000');

    }
    function test_strip_line_feed_and_carriage_return_in_headers(){
        eq = this.assertEqual;
        # For [ 1002475 ] email message parser doesn't handle \r\n correctly
        value1 = 'text';
        value2 = 'more text';
        m = 'Header: %s\r\nNext-Header: %s\r\n\r\nBody\r\n\r\n' % (
            value1, value2);
        msg = email.message_from_string(m);
        eq(msg.get('Header'), value1);
        eq(msg.get('Next-Header'), value2);

    }
    function test_rfc2822_header_syntax(){
        eq = this.assertEqual;
        m = '>From: foo\nFrom: bar\n!"#QUX;~: zoo\n\nbody';
        msg = email.message_from_string(m);
        eq(len(msg.keys()), 3);
        keys = msg.keys();
        keys.sort();
        eq(keys, ['!"#QUX;~', '>From', 'From']);
        eq(msg.get_payload(), 'body');

    }
    function test_rfc2822_space_not_allowed_in_header(){
        eq = this.assertEqual;
        m = '>From foo@example.com 11:25:53\nFrom: bar\n!"#QUX;~: zoo\n\nbody';
        msg = email.message_from_string(m);
        eq(len(msg.keys()), 0);

    }
    function test_rfc2822_one_character_header(){
        eq = this.assertEqual;
        m = 'A: first header\nB: second header\nCC: third header\n\nbody';
        msg = email.message_from_string(m);
        headers = msg.keys();
        headers.sort();
        eq(headers, ['A', 'B', 'CC']);
        eq(msg.get_payload(), 'body');

    }
    function test_CRLFLF_at_end_of_part(){
        # issue 5610: feedparser should not eat two chars from body part ending
        # with "\r\n\n".
        m = (
            "From: foo@bar.com\n"
            "To: baz\n"
            "Mime-Version: 1.0\n"
            "Content-Type: multipart/mixed; boundary=BOUNDARY\n"
            "\n"
            "--BOUNDARY\n"
            "Content-Type: text/plain\n"
            "\n"
            "body ending with CRLF newline\r\n"
            "\n"
            "--BOUNDARY--\n"
          );
        msg = email.message_from_string(m);
        this.assertTrue(msg.get_payload(0).get_payload().endswith('\r\n'));


}
} class TestBase64(unittest.TestCase){
    function test_len(){
        eq = this.assertEqual;
        eq(base64MIME.base64_len('hello'),
           len(base64MIME.encode('hello', eol='')));
        for size in range(15){
            if   size == 0 { bsize = 0;}
            elif size <= 3 { bsize = 4;}
            elif size <= 6 { bsize = 8;}
            elif size <= 9 { bsize = 12;}
            elif size <= 12{ bsize = 16;}
            else           { bsize = 20;}
            eq(base64MIME.base64_len('x'*size), bsize);

    }
    } function test_decode(){
        eq = this.assertEqual;
        eq(base64MIME.decode(''), '');
        eq(base64MIME.decode('aGVsbG8='), 'hello');
        eq(base64MIME.decode('aGVsbG8=', 'X'), 'hello');
        eq(base64MIME.decode('aGVsbG8NCndvcmxk\n', 'X'), 'helloXworld');

    }
    function test_encode(){
        eq = this.assertEqual;
        eq(base64MIME.encode(''), '');
        eq(base64MIME.encode('hello'), 'aGVsbG8=\n');
        # Test the binary flag
        eq(base64MIME.encode('hello\n'), 'aGVsbG8K\n');
        eq(base64MIME.encode('hello\n', 0), 'aGVsbG8NCg==\n');
        # Test the maxlinelen arg
        eq(base64MIME.encode('xxxx ' * 20, maxlinelen=40), """\
eHh4eCB4eHh4IHh4eHggeHh4eCB4eHh4IHh4eHgg
eHh4eCB4eHh4IHh4eHggeHh4eCB4eHh4IHh4eHgg
eHh4eCB4eHh4IHh4eHggeHh4eCB4eHh4IHh4eHgg
eHh4eCB4eHh4IA==
""");
        # Test the eol argument
        eq(base64MIME.encode('xxxx ' * 20, maxlinelen=40, eol='\r\n'), """\
eHh4eCB4eHh4IHh4eHggeHh4eCB4eHh4IHh4eHgg\r
eHh4eCB4eHh4IHh4eHggeHh4eCB4eHh4IHh4eHgg\r
eHh4eCB4eHh4IHh4eHggeHh4eCB4eHh4IHh4eHgg\r
eHh4eCB4eHh4IA==\r
""");

    }
    function test_header_encode(){
        eq = this.assertEqual;
        he = base64MIME.header_encode;
        eq(he('hello'), '=?iso-8859-1?b?aGVsbG8=?=');
        eq(he('hello\nworld'), '=?iso-8859-1?b?aGVsbG8NCndvcmxk?=');
        # Test the charset option
        eq(he('hello', charset='iso-8859-2'), '=?iso-8859-2?b?aGVsbG8=?=');
        # Test the keep_eols flag
        eq(he('hello\nworld', keep_eols=true),
           '=?iso-8859-1?b?aGVsbG8Kd29ybGQ=?=');
        # Test the maxlinelen argument
        eq(he('xxxx ' * 20, maxlinelen=40), """\
=?iso-8859-1?b?eHh4eCB4eHh4IHh4eHggeHg=?=
 =?iso-8859-1?b?eHggeHh4eCB4eHh4IHh4eHg=?=
 =?iso-8859-1?b?IHh4eHggeHh4eCB4eHh4IHg=?=
 =?iso-8859-1?b?eHh4IHh4eHggeHh4eCB4eHg=?=
 =?iso-8859-1?b?eCB4eHh4IHh4eHggeHh4eCA=?=
 =?iso-8859-1?b?eHh4eCB4eHh4IHh4eHgg?=""");
        # Test the eol argument
        eq(he('xxxx ' * 20, maxlinelen=40, eol='\r\n'), """\
=?iso-8859-1?b?eHh4eCB4eHh4IHh4eHggeHg=?=\r
 =?iso-8859-1?b?eHggeHh4eCB4eHh4IHh4eHg=?=\r
 =?iso-8859-1?b?IHh4eHggeHh4eCB4eHh4IHg=?=\r
 =?iso-8859-1?b?eHh4IHh4eHggeHh4eCB4eHg=?=\r
 =?iso-8859-1?b?eCB4eHh4IHh4eHggeHh4eCA=?=\r
 =?iso-8859-1?b?eHh4eCB4eHh4IHh4eHgg?=""");



}
} class TestQuopri(unittest.TestCase){
    function setUp(){
        this.hlit = [chr(x) for x in range(ord('a'), ord('z')+1)] + \
                    [chr(x) for x in range(ord('A'), ord('Z')+1)] + \
                    [chr(x) for x in range(ord('0'), ord('9')+1)] + \
                    ['!', '*', '+', '-', '/', ' '];
        this.hnon = [chr(x) for x in range(256) if chr(x) not in this.hlit];
        assert len(this.hlit) + len(this.hnon) == 256;
        this.blit = [chr(x) for x in range(ord(' '), ord('~')+1)] + ['\t'];
        this.blit.remove('=');
        this.bnon = [chr(x) for x in range(256) if chr(x) not in this.blit];
        assert len(this.blit) + len(this.bnon) == 256;

    }
    function test_header_quopri_check(){
        for c in this.hlit{
            this.assertFalse(quopriMIME.header_quopri_check(c));
        } for c in this.hnon{
            this.assertTrue(quopriMIME.header_quopri_check(c));

    }
    } function test_body_quopri_check(){
        for c in this.blit{
            this.assertFalse(quopriMIME.body_quopri_check(c));
        } for c in this.bnon{
            this.assertTrue(quopriMIME.body_quopri_check(c));

    }
    } function test_header_quopri_len(){
        eq = this.assertEqual;
        hql = quopriMIME.header_quopri_len;
        enc = quopriMIME.header_encode;
        for s in ('hello', 'h@e@l@l@o@'){
            # Empty charset and no line-endings.  7 == RFC chrome
            eq(hql(s), len(enc(s, charset='', eol=''))-7);
        } for c in this.hlit{
            eq(hql(c), 1);
        } for c in this.hnon{
            eq(hql(c), 3);

    }
    } function test_body_quopri_len(){
        eq = this.assertEqual;
        bql = quopriMIME.body_quopri_len;
        for c in this.blit{
            eq(bql(c), 1);
        } for c in this.bnon{
            eq(bql(c), 3);

    }
    } function test_quote_unquote_idempotent(){
        for x in range(256){
            c = chr(x);
            this.assertEqual(quopriMIME.unquote(quopriMIME.quote(c)), c);

    }
    } function test_header_encode(){
        eq = this.assertEqual;
        he = quopriMIME.header_encode;
        eq(he('hello'), '=?iso-8859-1?q?hello?=');
        eq(he('hello\nworld'), '=?iso-8859-1?q?hello=0D=0Aworld?=');
        # Test the charset option
        eq(he('hello', charset='iso-8859-2'), '=?iso-8859-2?q?hello?=');
        # Test the keep_eols flag
        eq(he('hello\nworld', keep_eols=true), '=?iso-8859-1?q?hello=0Aworld?=');
        # Test a non-ASCII character
        eq(he('hello\xc7there'), '=?iso-8859-1?q?hello=C7there?=');
        # Test the maxlinelen argument
        eq(he('xxxx ' * 20, maxlinelen=40), """\
=?iso-8859-1?q?xxxx_xxxx_xxxx_xxxx_xx?=
 =?iso-8859-1?q?xx_xxxx_xxxx_xxxx_xxxx?=
 =?iso-8859-1?q?_xxxx_xxxx_xxxx_xxxx_x?=
 =?iso-8859-1?q?xxx_xxxx_xxxx_xxxx_xxx?=
 =?iso-8859-1?q?x_xxxx_xxxx_?=""");
        # Test the eol argument
        eq(he('xxxx ' * 20, maxlinelen=40, eol='\r\n'), """\
=?iso-8859-1?q?xxxx_xxxx_xxxx_xxxx_xx?=\r
 =?iso-8859-1?q?xx_xxxx_xxxx_xxxx_xxxx?=\r
 =?iso-8859-1?q?_xxxx_xxxx_xxxx_xxxx_x?=\r
 =?iso-8859-1?q?xxx_xxxx_xxxx_xxxx_xxx?=\r
 =?iso-8859-1?q?x_xxxx_xxxx_?=""");

    }
    function test_decode(){
        eq = this.assertEqual;
        eq(quopriMIME.decode(''), '');
        eq(quopriMIME.decode('hello'), 'hello');
        eq(quopriMIME.decode('hello', 'X'), 'hello');
        eq(quopriMIME.decode('hello\nworld', 'X'), 'helloXworld');

    }
    function test_encode(){
        eq = this.assertEqual;
        eq(quopriMIME.encode(''), '');
        eq(quopriMIME.encode('hello'), 'hello');
        # Test the binary flag
        eq(quopriMIME.encode('hello\r\nworld'), 'hello\nworld');
        eq(quopriMIME.encode('hello\r\nworld', 0), 'hello\nworld');
        # Test the maxlinelen arg
        eq(quopriMIME.encode('xxxx ' * 20, maxlinelen=40), """\
xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx=
 xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxx=
x xxxx xxxx xxxx xxxx=20""");
        # Test the eol argument
        eq(quopriMIME.encode('xxxx ' * 20, maxlinelen=40, eol='\r\n'), """\
xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx=\r
 xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxx=\r
x xxxx xxxx xxxx xxxx=20""");
        eq(quopriMIME.encode("""\
one line

two line"""), """\
one line

two line""");



# Test the Charset class
}
} class TestCharset(unittest.TestCase){
    function tearDown(){
        from email import Charset as CharsetModule;
        try{
            del CharsetModule.CHARSETS['fake'];
        } except KeyError{
            pass;

    }
    } function test_idempotent(){
        eq = this.assertEqual;
        # Make sure us-ascii = no Unicode conversion
        c = Charset('us-ascii');
        s = 'Hello World!';
        sp = c.to_splittable(s);
        eq(s, c.from_splittable(sp));
        # test 8-bit idempotency with us-ascii
        s = '\xa4\xa2\xa4\xa4\xa4\xa6\xa4\xa8\xa4\xaa';
        sp = c.to_splittable(s);
        eq(s, c.from_splittable(sp));

    }
    function test_body_encode(){
        eq = this.assertEqual;
        # Try a charset with QP body encoding
        c = Charset('iso-8859-1');
        eq('hello w=F6rld', c.body_encode('hello w\xf6rld'));
        # Try a charset with Base64 body encoding
        c = Charset('utf-8');
        eq('aGVsbG8gd29ybGQ=\n', c.body_encode('hello world'));
        # Try a charset with None body encoding
        c = Charset('us-ascii');
        eq('hello world', c.body_encode('hello world'));
        # Try the convert argument, where input codec != output codec
        c = Charset('euc-jp');
        # With apologies to Tokio Kikuchi ;)
        try{
            eq('\x1b$B5FCO;~IW\x1b(B',
               c.body_encode('\xb5\xc6\xc3\xcf\xbb\xfe\xc9\xd7'));
            eq('\xb5\xc6\xc3\xcf\xbb\xfe\xc9\xd7',
               c.body_encode('\xb5\xc6\xc3\xcf\xbb\xfe\xc9\xd7', false));
        } except LookupError{
            # We probably don't have the Japanese codecs installed
            pass;
        # Testing SF bug #625509, which we have to fake, since there are no
        # built-in encodings where the header encoding is QP but the body
        # encoding is not.
        }
        from email import Charset as CharsetModule;
        CharsetModule.add_charset('fake', CharsetModule.QP, nil);
        c = Charset('fake');
        eq('hello w\xf6rld', c.body_encode('hello w\xf6rld'));

    }
    function test_unicode_charset_name(){
        charset = Charset(u'us-ascii');
        this.assertEqual(str(charset), 'us-ascii');
        this.assertRaises(Errors.CharsetError, Charset, 'asc\xffii');

    }
    function test_codecs_aliases_accepted(){
        charset = Charset('utf8');
        this.assertEqual(str(charset), 'utf-8');


# Test multilingual MIME headers.
}
} class TestHeader(TestEmailBase){
    function test_simple(){
        eq = this.ndiffAssertEqual;
        h = Header('Hello World!');
        eq(h.encode(), 'Hello World!');
        h.append(' Goodbye World!');
        eq(h.encode(), 'Hello World!  Goodbye World!');

    }
    function test_simple_surprise(){
        eq = this.ndiffAssertEqual;
        h = Header('Hello World!');
        eq(h.encode(), 'Hello World!');
        h.append('Goodbye World!');
        eq(h.encode(), 'Hello World! Goodbye World!');

    }
    function test_header_needs_no_decoding(){
        h = 'no decoding needed';
        this.assertEqual(decode_header(h), [(h, nil)]);

    }
    function test_long(){
        h = Header("I am the very model of a modern Major-General; I've information vegetable, animal, and mineral; I know the kings of England, and I quote the fights historical from Marathon to Waterloo, in order categorical; I'm very well acquainted, too, with matters mathematical; I understand equations, both the simple and quadratical; about binomial theorem I'm teeming with a lot o' news, with many cheerful facts about the square of the hypotenuse.",
                   maxlinelen=76);
        for l in h.encode(splitchars=' ').split('\n '){
            this.assertLessEqual(len(l), 76);

    }
    } function test_multilingual(){
        eq = this.ndiffAssertEqual;
        g = Charset("iso-8859-1");
        cz = Charset("iso-8859-2");
        utf8 = Charset("utf-8");
        g_head = "Die Mieter treten hier ein werden mit einem Foerderband komfortabel den Korridor entlang, an s\xfcdl\xfcndischen Wandgem\xe4lden vorbei, gegen die rotierenden Klingen bef\xf6rdert. ";
        cz_head = "Finan\xe8ni metropole se hroutily pod tlakem jejich d\xf9vtipu.. ";
        utf8_head = u"\u6b63\u78ba\u306b\u8a00\u3046\u3068\u7ffb\u8a33\u306f\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002\u4e00\u90e8\u306f\u30c9\u30a4\u30c4\u8a9e\u3067\u3059\u304c\u3001\u3042\u3068\u306f\u3067\u305f\u3089\u3081\u3067\u3059\u3002\u5b9f\u969b\u306b\u306f\u300cWenn ist das Nunstuck git und Slotermeyer? Ja! Beiherhund das Oder die Flipperwaldt gersput.\u300d\u3068\u8a00\u3063\u3066\u3044\u307e\u3059\u3002".encode("utf-8");
        h = Header(g_head, g);
        h.append(cz_head, cz);
        h.append(utf8_head, utf8);
        enc = h.encode();
        eq(enc, """\
=?iso-8859-1?q?Die_Mieter_treten_hier_ein_werden_mit_einem_Foerderband_ko?=
 =?iso-8859-1?q?mfortabel_den_Korridor_entlang=2C_an_s=FCdl=FCndischen_Wan?=
 =?iso-8859-1?q?dgem=E4lden_vorbei=2C_gegen_die_rotierenden_Klingen_bef=F6?=
 =?iso-8859-1?q?rdert=2E_?= =?iso-8859-2?q?Finan=E8ni_metropole_se_hroutily?=
 =?iso-8859-2?q?_pod_tlakem_jejich_d=F9vtipu=2E=2E_?= =?utf-8?b?5q2j56K6?=
 =?utf-8?b?44Gr6KiA44GG44Go57+76Kiz44Gv44GV44KM44Gm44GE44G+44Gb44KT44CC?=
 =?utf-8?b?5LiA6YOo44Gv44OJ44Kk44OE6Kqe44Gn44GZ44GM44CB44GC44Go44Gv44Gn?=
 =?utf-8?b?44Gf44KJ44KB44Gn44GZ44CC5a6f6Zqb44Gr44Gv44CMV2VubiBpc3QgZGFz?=
 =?utf-8?q?_Nunstuck_git_und_Slotermeyer=3F_Ja!_Beiherhund_das_Oder_die_Fl?=
 =?utf-8?b?aXBwZXJ3YWxkdCBnZXJzcHV0LuOAjeOBqOiogOOBo+OBpuOBhOOBvuOBmQ==?=
 =?utf-8?b?44CC?=""");
        eq(decode_header(enc),
           [(g_head, "iso-8859-1"), (cz_head, "iso-8859-2"),
            (utf8_head, "utf-8")]);
        ustr = unicode(h);
        eq(ustr.encode('utf-8'),
           'Die Mieter treten hier ein werden mit einem Foerderband '
           'komfortabel den Korridor entlang, an s\xc3\xbcdl\xc3\xbcndischen '
           'Wandgem\xc3\xa4lden vorbei, gegen die rotierenden Klingen '
           'bef\xc3\xb6rdert. Finan\xc4\x8dni metropole se hroutily pod '
           'tlakem jejich d\xc5\xafvtipu.. \xe6\xad\xa3\xe7\xa2\xba\xe3\x81'
           '\xab\xe8\xa8\x80\xe3\x81\x86\xe3\x81\xa8\xe7\xbf\xbb\xe8\xa8\xb3'
           '\xe3\x81\xaf\xe3\x81\x95\xe3\x82\x8c\xe3\x81\xa6\xe3\x81\x84\xe3'
           '\x81\xbe\xe3\x81\x9b\xe3\x82\x93\xe3\x80\x82\xe4\xb8\x80\xe9\x83'
           '\xa8\xe3\x81\xaf\xe3\x83\x89\xe3\x82\xa4\xe3\x83\x84\xe8\xaa\x9e'
           '\xe3\x81\xa7\xe3\x81\x99\xe3\x81\x8c\xe3\x80\x81\xe3\x81\x82\xe3'
           '\x81\xa8\xe3\x81\xaf\xe3\x81\xa7\xe3\x81\x9f\xe3\x82\x89\xe3\x82'
           '\x81\xe3\x81\xa7\xe3\x81\x99\xe3\x80\x82\xe5\xae\x9f\xe9\x9a\x9b'
           '\xe3\x81\xab\xe3\x81\xaf\xe3\x80\x8cWenn ist das Nunstuck git '
           'und Slotermeyer? Ja! Beiherhund das Oder die Flipperwaldt '
           'gersput.\xe3\x80\x8d\xe3\x81\xa8\xe8\xa8\x80\xe3\x81\xa3\xe3\x81'
           '\xa6\xe3\x81\x84\xe3\x81\xbe\xe3\x81\x99\xe3\x80\x82');
        # Test make_header()
        newh = make_header(decode_header(enc));
        eq(newh, enc);

    }
    function test_header_ctor_default_args(){
        eq = this.ndiffAssertEqual;
        h = Header();
        eq(h, '');
        h.append('foo', Charset('iso-8859-1'));
        eq(h, '=?iso-8859-1?q?foo?=');

    }
    function test_explicit_maxlinelen(){
        eq = this.ndiffAssertEqual;
        hstr = 'A very long line that must get split to something other than at the 76th character boundary to test the non-default behavior';
        h = Header(hstr);
        eq(h.encode(), '''\
A very long line that must get split to something other than at the 76th
 character boundary to test the non-default behavior''');
        h = Header(hstr, header_name='Subject');
        eq(h.encode(), '''\
A very long line that must get split to something other than at the
 76th character boundary to test the non-default behavior''');
        h = Header(hstr, maxlinelen=1024, header_name='Subject');
        eq(h.encode(), hstr);

    }
    function test_us_ascii_header(){
        eq = this.assertEqual;
        s = 'hello';
        x = decode_header(s);
        eq(x, [('hello', nil)]);
        h = make_header(x);
        eq(s, h.encode());

    }
    function test_string_charset(){
        eq = this.assertEqual;
        h = Header();
        h.append('hello', 'iso-8859-1');
        eq(h, '=?iso-8859-1?q?hello?=');

##    def test_unicode_error(self):
##        raises = self.assertRaises
##        raises(UnicodeError, Header, u'[P\xf6stal]', 'us-ascii')
##        raises(UnicodeError, Header, '[P\xf6stal]', 'us-ascii')
##        h = Header()
##        raises(UnicodeError, h.append, u'[P\xf6stal]', 'us-ascii')
##        raises(UnicodeError, h.append, '[P\xf6stal]', 'us-ascii')
##        raises(UnicodeError, Header, u'\u83ca\u5730\u6642\u592b', 'iso-8859-1')

    }
    function test_utf8_shortest(){
        eq = this.assertEqual;
        h = Header(u'p\xf6stal', 'utf-8');
        eq(h.encode(), '=?utf-8?q?p=C3=B6stal?=');
        h = Header(u'\u83ca\u5730\u6642\u592b', 'utf-8');
        eq(h.encode(), '=?utf-8?b?6I+K5Zyw5pmC5aSr?=');

    }
    function test_bad_8bit_header(){
        raises = this.assertRaises;
        eq = this.assertEqual;
        x = 'Ynwp4dUEbay Auction Semiar- No Charge \x96 Earn Big';
        raises(UnicodeError, Header, x);
        h = Header();
        raises(UnicodeError, h.append, x);
        eq(str(Header(x, errors='replace')), x);
        h.append(x, errors='replace');
        eq(str(h), x);

    }
    function test_encoded_adjacent_nonencoded(){
        eq = this.assertEqual;
        h = Header();
        h.append('hello', 'iso-8859-1');
        h.append('world');
        s = h.encode();
        eq(s, '=?iso-8859-1?q?hello?= world');
        h = make_header(decode_header(s));
        eq(h.encode(), s);

    }
    function test_whitespace_eater(){
        eq = this.assertEqual;
        s = 'Subject: =?koi8-r?b?8NLP18XSy8EgzsEgxsnOwczYztk=?= =?koi8-r?q?=CA?= zz.';
        parts = decode_header(s);
        eq(parts, [('Subject:', nil), ('\xf0\xd2\xcf\xd7\xc5\xd2\xcb\xc1 \xce\xc1 \xc6\xc9\xce\xc1\xcc\xd8\xce\xd9\xca', 'koi8-r'), ('zz.', nil)]);
        hdr = make_header(parts);
        eq(hdr.encode(),
           'Subject: =?koi8-r?b?8NLP18XSy8EgzsEgxsnOwczYztnK?= zz.');

    }
    function test_broken_base64_header(){
        raises = this.assertRaises;
        s = 'Subject: =?EUC-KR?B?CSixpLDtKSC/7Liuvsax4iC6uLmwMcijIKHaILzSwd/H0SC8+LCjwLsgv7W/+Mj3I ?=';
        raises(Errors.HeaderParseError, decode_header, s);

    # Issue 1078919
    }
    function test_ascii_add_header(){
        msg = Message();
        msg.add_header('Content-Disposition', 'attachment',
                       filename='bud.gif');
        this.assertEqual('attachment; filename="bud.gif"',
            msg['Content-Disposition']);

    }
    function test_nonascii_add_header_via_triple(){
        msg = Message();
        msg.add_header('Content-Disposition', 'attachment',
            filename=('iso-8859-1', '', 'Fu\xdfballer.ppt'));
        this.assertEqual(
            'attachment; filename*="iso-8859-1\'\'Fu%DFballer.ppt"',
            msg['Content-Disposition']);

    }
    function test_encode_unaliased_charset(){
        # Issue 1379416: when the charset has no output conversion,
        # output was accidentally getting coerced to unicode.
        res = Header('abc','iso-8859-2').encode();
        this.assertEqual(res, '=?iso-8859-2?q?abc?=');
        this.assertIsInstance(res, str);

# Test RFC 2231 header parameters (en/de)coding
}
} class TestRFC2231(TestEmailBase){
    function test_get_param(){
        eq = this.assertEqual;
        msg = this._msgobj('msg_29.txt');
        eq(msg.get_param('title'),
           ('us-ascii', 'en', 'This is even more ***fun*** isn\'t it!'));
        eq(msg.get_param('title', unquote=false),
           ('us-ascii', 'en', '"This is even more ***fun*** isn\'t it!"'));

    }
    function test_set_param(){
        eq = this.assertEqual;
        msg = Message();
        msg.set_param('title', 'This is even more ***fun*** isn\'t it!',
                      charset='us-ascii');
        eq(msg.get_param('title'),
           ('us-ascii', '', 'This is even more ***fun*** isn\'t it!'));
        msg.set_param('title', 'This is even more ***fun*** isn\'t it!',
                      charset='us-ascii', language='en');
        eq(msg.get_param('title'),
           ('us-ascii', 'en', 'This is even more ***fun*** isn\'t it!'));
        msg = this._msgobj('msg_01.txt');
        msg.set_param('title', 'This is even more ***fun*** isn\'t it!',
                      charset='us-ascii', language='en');
        this.ndiffAssertEqual(msg.as_string(), """\
Return-Path: <bbb@zzz.org>
Delivered-To: bbb@zzz.org
Received: by mail.zzz.org (Postfix, from userid 889)
 id 27CEAD38CC; Fri,  4 May 2001 14:05:44 -0400 (EDT)
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Message-ID: <15090.61304.110929.45684@aaa.zzz.org>
From: bbb@ddd.com (John X. Doe)
To: bbb@zzz.org
Subject: This is a test message
Date: Fri, 4 May 2001 14:05:44 -0400
Content-Type: text/plain; charset=us-ascii;
 title*="us-ascii'en'This%20is%20even%20more%20%2A%2A%2Afun%2A%2A%2A%20isn%27t%20it%21"


Hi,

Do you like this message?

-Me
""");

    }
    function test_del_param(){
        eq = this.ndiffAssertEqual;
        msg = this._msgobj('msg_01.txt');
        msg.set_param('foo', 'bar', charset='us-ascii', language='en');
        msg.set_param('title', 'This is even more ***fun*** isn\'t it!',
            charset='us-ascii', language='en');
        msg.del_param('foo', header='Content-Type');
        eq(msg.as_string(), """\
Return-Path: <bbb@zzz.org>
Delivered-To: bbb@zzz.org
Received: by mail.zzz.org (Postfix, from userid 889)
 id 27CEAD38CC; Fri,  4 May 2001 14:05:44 -0400 (EDT)
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Message-ID: <15090.61304.110929.45684@aaa.zzz.org>
From: bbb@ddd.com (John X. Doe)
To: bbb@zzz.org
Subject: This is a test message
Date: Fri, 4 May 2001 14:05:44 -0400
Content-Type: text/plain; charset="us-ascii";
 title*="us-ascii'en'This%20is%20even%20more%20%2A%2A%2Afun%2A%2A%2A%20isn%27t%20it%21"


Hi,

Do you like this message?

-Me
""");

    }
    function test_rfc2231_get_content_charset(){
        eq = this.assertEqual;
        msg = this._msgobj('msg_32.txt');
        eq(msg.get_content_charset(), 'us-ascii');

    }
    function test_rfc2231_no_language_or_charset(){
        m = '''\
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="file____C__DOCUMENTS_20AND_20SETTINGS_FABIEN_LOCAL_20SETTINGS_TEMP_nsmail.htm"
Content-Type: text/html; NAME*0=file____C__DOCUMENTS_20AND_20SETTINGS_FABIEN_LOCAL_20SETTINGS_TEM; NAME*1=P_nsmail.htm

''';
        msg = email.message_from_string(m);
        param = msg.get_param('NAME');
        this.assertNotIsInstance(param, tuple);
        this.assertEqual(
            param,
            'file____C__DOCUMENTS_20AND_20SETTINGS_FABIEN_LOCAL_20SETTINGS_TEMP_nsmail.htm');

    }
    function test_rfc2231_no_language_or_charset_in_filename(){
        m = '''\
Content-Disposition: inline;
\tfilename*0*="''This%20is%20even%20more%20";
\tfilename*1*="%2A%2A%2Afun%2A%2A%2A%20";
\tfilename*2="is it not.pdf"

''';
        msg = email.message_from_string(m);
        this.assertEqual(msg.get_filename(),
                         'This is even more ***fun*** is it not.pdf');

    }
    function test_rfc2231_no_language_or_charset_in_filename_encoded(){
        m = '''\
Content-Disposition: inline;
\tfilename*0*="''This%20is%20even%20more%20";
\tfilename*1*="%2A%2A%2Afun%2A%2A%2A%20";
\tfilename*2="is it not.pdf"

''';
        msg = email.message_from_string(m);
        this.assertEqual(msg.get_filename(),
                         'This is even more ***fun*** is it not.pdf');

    }
    function test_rfc2231_partly_encoded(){
        m = '''\
Content-Disposition: inline;
\tfilename*0="''This%20is%20even%20more%20";
\tfilename*1*="%2A%2A%2Afun%2A%2A%2A%20";
\tfilename*2="is it not.pdf"

''';
        msg = email.message_from_string(m);
        this.assertEqual(
            msg.get_filename(),
            'This%20is%20even%20more%20***fun*** is it not.pdf');

    }
    function test_rfc2231_partly_nonencoded(){
        m = '''\
Content-Disposition: inline;
\tfilename*0="This%20is%20even%20more%20";
\tfilename*1="%2A%2A%2Afun%2A%2A%2A%20";
\tfilename*2="is it not.pdf"

''';
        msg = email.message_from_string(m);
        this.assertEqual(
            msg.get_filename(),
            'This%20is%20even%20more%20%2A%2A%2Afun%2A%2A%2A%20is it not.pdf');

    }
    function test_rfc2231_no_language_or_charset_in_boundary(){
        m = '''\
Content-Type: multipart/alternative;
\tboundary*0*="''This%20is%20even%20more%20";
\tboundary*1*="%2A%2A%2Afun%2A%2A%2A%20";
\tboundary*2="is it not.pdf"

''';
        msg = email.message_from_string(m);
        this.assertEqual(msg.get_boundary(),
                         'This is even more ***fun*** is it not.pdf');

    }
    function test_rfc2231_no_language_or_charset_in_charset(){
        # This is a nonsensical charset value, but tests the code anyway
        m = '''\
Content-Type: text/plain;
\tcharset*0*="This%20is%20even%20more%20";
\tcharset*1*="%2A%2A%2Afun%2A%2A%2A%20";
\tcharset*2="is it not.pdf"

''';
        msg = email.message_from_string(m);
        this.assertEqual(msg.get_content_charset(),
                         'this is even more ***fun*** is it not.pdf');

    }
    function test_rfc2231_bad_encoding_in_filename(){
        m = '''\
Content-Disposition: inline;
\tfilename*0*="bogus'xx'This%20is%20even%20more%20";
\tfilename*1*="%2A%2A%2Afun%2A%2A%2A%20";
\tfilename*2="is it not.pdf"

''';
        msg = email.message_from_string(m);
        this.assertEqual(msg.get_filename(),
                         'This is even more ***fun*** is it not.pdf');

    }
    function test_rfc2231_bad_encoding_in_charset(){
        m = """\
Content-Type: text/plain; charset*=bogus''utf-8%E2%80%9D

""";
        msg = email.message_from_string(m);
        # This should return None because non-ascii characters in the charset
        # are not allowed.
        this.assertEqual(msg.get_content_charset(), nil);

    }
    function test_rfc2231_bad_character_in_charset(){
        m = """\
Content-Type: text/plain; charset*=ascii''utf-8%E2%80%9D

""";
        msg = email.message_from_string(m);
        # This should return None because non-ascii characters in the charset
        # are not allowed.
        this.assertEqual(msg.get_content_charset(), nil);

    }
    function test_rfc2231_bad_character_in_filename(){
        m = '''\
Content-Disposition: inline;
\tfilename*0*="ascii'xx'This%20is%20even%20more%20";
\tfilename*1*="%2A%2A%2Afun%2A%2A%2A%20";
\tfilename*2*="is it not.pdf%E2"

''';
        msg = email.message_from_string(m);
        this.assertEqual(msg.get_filename(),
                         u'This is even more ***fun*** is it not.pdf\ufffd');

    }
    function test_rfc2231_unknown_encoding(){
        m = """\
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename*=X-UNKNOWN''myfile.txt

""";
        msg = email.message_from_string(m);
        this.assertEqual(msg.get_filename(), 'myfile.txt');

    }
    function test_rfc2231_single_tick_in_filename_extended(){
        eq = this.assertEqual;
        m = """\
Content-Type: application/x-foo;
\tname*0*=\"Frank's\"; name*1*=\" Document\"

""";
        msg = email.message_from_string(m);
        charset, language, s = msg.get_param('name');
        eq(charset, nil);
        eq(language, nil);
        eq(s, "Frank's Document");

    }
    function test_rfc2231_single_tick_in_filename(){
        m = """\
Content-Type: application/x-foo; name*0=\"Frank's\"; name*1=\" Document\"

""";
        msg = email.message_from_string(m);
        param = msg.get_param('name');
        this.assertNotIsInstance(param, tuple);
        this.assertEqual(param, "Frank's Document");

    }
    function test_rfc2231_tick_attack_extended(){
        eq = this.assertEqual;
        m = """\
Content-Type: application/x-foo;
\tname*0*=\"us-ascii'en-us'Frank's\"; name*1*=\" Document\"

""";
        msg = email.message_from_string(m);
        charset, language, s = msg.get_param('name');
        eq(charset, 'us-ascii');
        eq(language, 'en-us');
        eq(s, "Frank's Document");

    }
    function test_rfc2231_tick_attack(){
        m = """\
Content-Type: application/x-foo;
\tname*0=\"us-ascii'en-us'Frank's\"; name*1=\" Document\"

""";
        msg = email.message_from_string(m);
        param = msg.get_param('name');
        this.assertNotIsInstance(param, tuple);
        this.assertEqual(param, "us-ascii'en-us'Frank's Document");

    }
    function test_rfc2231_no_extended_values(){
        eq = this.assertEqual;
        m = """\
Content-Type: application/x-foo; name=\"Frank's Document\"

""";
        msg = email.message_from_string(m);
        eq(msg.get_param('name'), "Frank's Document");

    }
    function test_rfc2231_encoded_then_unencoded_segments(){
        eq = this.assertEqual;
        m = """\
Content-Type: application/x-foo;
\tname*0*=\"us-ascii'en-us'My\";
\tname*1=\" Document\";
\tname*2*=\" For You\"

""";
        msg = email.message_from_string(m);
        charset, language, s = msg.get_param('name');
        eq(charset, 'us-ascii');
        eq(language, 'en-us');
        eq(s, 'My Document For You');

    }
    function test_rfc2231_unencoded_then_encoded_segments(){
        eq = this.assertEqual;
        m = """\
Content-Type: application/x-foo;
\tname*0=\"us-ascii'en-us'My\";
\tname*1*=\" Document\";
\tname*2*=\" For You\"

""";
        msg = email.message_from_string(m);
        charset, language, s = msg.get_param('name');
        eq(charset, 'us-ascii');
        eq(language, 'en-us');
        eq(s, 'My Document For You');



# Tests to ensure that signed parts of an email are completely preserved, as
# required by RFC1847 section 2.1.  Note that these are incomplete, because the
# email package does not currently always preserve the body.  See issue 1670765.
}
} class TestSigned(TestEmailBase){

    function _msg_and_obj( filename){
        fp = openfile(findfile(filename));
        try{
            original = fp.read();
            msg = email.message_from_string(original);
        } finally{
            fp.close();
        } return original, msg;

    }
    function _signed_parts_eq( original, result){
        # Extract the first mime part of each message
        import re;
        repart = re.compile(r'^--([^\n]+)\n(.*?)\n--\1$', re.S | re.M);
        inpart = repart.search(original).group(2);
        outpart = repart.search(result).group(2);
        this.assertEqual(outpart, inpart);

    }
    function test_long_headers_as_string(){
        original, msg = this._msg_and_obj('msg_45.txt');
        result = msg.as_string();
        this._signed_parts_eq(original, result);

    }
    function test_long_headers_flatten(){
        original, msg = this._msg_and_obj('msg_45.txt');
        fp = StringIO();
        Generator(fp).flatten(msg);
        result = fp.getvalue();
        this._signed_parts_eq(original, result);



}
} function _testclasses(){
    mod = sys.modules[__name__];
    return [getattr(mod, name) for name in dir(mod) if name.startswith('Test')];


}
function suite(){
    suite = unittest.TestSuite();
    for testclass in _testclasses(){
        suite.addTest(unittest.makeSuite(testclass));
    } return suite;


}
function test_main(){
    for testclass in _testclasses(){
        run_unittest(testclass);



}
} if __name__ == '__main__'{
    unittest.main(defaultTest='suite');

}
"""Read/write support for Maildir, mbox, MH, Babyl, and MMDF mailboxes.""";

# Notes for authors of new mailbox subclasses:
#
# Remember to fsync() changes to disk before closing a modified file
# or returning from a flush() method.  See functions _sync_flush() and
# _sync_close().

import sys;
import os;
import time;
import calendar;
import socket;
import errno;
import copy;
import email;
import email.message;
import email.generator;
import StringIO;
try{
    if sys.platform == 'os2emx'{
        # OS/2 EMX fcntl() not adequate
        raise ImportError;
    } import fcntl;
} except ImportError{
    fcntl = nil;

}
import warnings;
with warnings.catch_warnings(){
    if sys.py3kwarning{
        warnings.filterwarnings("ignore", ".*rfc822 has been removed",
                                DeprecationWarning);
    } import rfc822;

}
__all__ = [ 'Mailbox', 'Maildir', 'mbox', 'MH', 'Babyl', 'MMDF',
            'Message', 'MaildirMessage', 'mboxMessage', 'MHMessage',
            'BabylMessage', 'MMDFMessage', 'UnixMailbox',
            'PortableUnixMailbox', 'MmdfMailbox', 'MHMailbox', 'BabylMailbox' ];

class Mailbox{
    """A group of messages in a particular place.""";

    function __init__( path, factory=nil, create=true){
        """Initialize a Mailbox instance.""";
        this._path = os.path.abspath(os.path.expanduser(path));
        this._factory = factory;

    }
    function add( message){
        """Add message and return assigned key.""";
        raise NotImplementedError('Method must be implemented by subclass');

    }
    function remove( key){
        """Remove the keyed message; raise KeyError if it doesn't exist.""";
        raise NotImplementedError('Method must be implemented by subclass');

    }
    function __delitem__( key){
        this.remove(key);

    }
    function discard( key){
        """If the keyed message exists, remove it.""";
        try{
            this.remove(key);
        } except KeyError{
            pass;

    }
    } function __setitem__( key, message){
        """Replace the keyed message; raise KeyError if it doesn't exist.""";
        raise NotImplementedError('Method must be implemented by subclass');

    }
    function get( key, default=nil){
        """Return the keyed message, or default if it doesn't exist.""";
        try{
            return this.__getitem__(key);
        } except KeyError{
            return default;

    }
    } function __getitem__( key){
        """Return the keyed message; raise KeyError if it doesn't exist.""";
        if not this._factory{
            return this.get_message(key);
        } else{
            return this._factory(this.get_file(key));

    }
    } function get_message( key){
        """Return a Message representation or raise a KeyError.""";
        raise NotImplementedError('Method must be implemented by subclass');

    }
    function get_string( key){
        """Return a string representation or raise a KeyError.""";
        raise NotImplementedError('Method must be implemented by subclass');

    }
    function get_file( key){
        """Return a file-like representation or raise a KeyError.""";
        raise NotImplementedError('Method must be implemented by subclass');

    }
    function iterkeys(){
        """Return an iterator over keys.""";
        raise NotImplementedError('Method must be implemented by subclass');

    }
    function keys(){
        """Return a list of keys.""";
        return list(this.iterkeys());

    }
    function itervalues(){
        """Return an iterator over all messages.""";
        for key in this.iterkeys(){
            try{
                value = this[key];
            } except KeyError{
                continue;
            } yield value;

    }
    } function __iter__(){
        return this.itervalues();

    }
    function values(){
        """Return a list of messages. Memory intensive.""";
        return list(this.itervalues());

    }
    function iteritems(){
        """Return an iterator over (key, message) tuples.""";
        for key in this.iterkeys(){
            try{
                value = this[key];
            } except KeyError{
                continue;
            } yield (key, value);

    }
    } function items(){
        """Return a list of (key, message) tuples. Memory intensive.""";
        return list(this.iteritems());

    }
    function has_key( key){
        """Return True if the keyed message exists, False otherwise.""";
        raise NotImplementedError('Method must be implemented by subclass');

    }
    function __contains__( key){
        return this.has_key(key);

    }
    function __len__(){
        """Return a count of messages in the mailbox.""";
        raise NotImplementedError('Method must be implemented by subclass');

    }
    function clear(){
        """Delete all messages.""";
        for key in this.iterkeys(){
            this.discard(key);

    }
    } function pop( key, default=nil){
        """Delete the keyed message and return it, or default.""";
        try{
            result = this[key];
        } except KeyError{
            return default;
        } this.discard(key);
        return result;

    }
    function popitem(){
        """Delete an arbitrary (key, message) pair and return it.""";
        for key in this.iterkeys(){
            return (key, this.pop(key));     # This is only run once.
        } else{
            raise KeyError('No messages in mailbox');

    }
    } function update( arg=nil){
        """Change the messages that correspond to certain keys.""";
        if hasattr(arg, 'iteritems'){
            source = arg.iteritems();
        } elif hasattr(arg, 'items'){
            source = arg.items();
        } else{
            source = arg;
        } bad_key = false;
        for key, message in source{
            try{
                this[key] = message;
            } except KeyError{
                bad_key = true;
        } } if bad_key{
            raise KeyError('No message with key(s)');

    }
    } function flush(){
        """Write any pending changes to the disk.""";
        raise NotImplementedError('Method must be implemented by subclass');

    }
    function lock(){
        """Lock the mailbox.""";
        raise NotImplementedError('Method must be implemented by subclass');

    }
    function unlock(){
        """Unlock the mailbox if it is locked.""";
        raise NotImplementedError('Method must be implemented by subclass');

    }
    function close(){
        """Flush and close the mailbox.""";
        raise NotImplementedError('Method must be implemented by subclass');

    # Whether each message must end in a newline
    }
    _append_newline = false;

    function _dump_message( message, target, mangle_from_=false){
        # Most files are opened in binary mode to allow predictable seeking.
        # To get native line endings on disk, the user-friendly \n line endings
        # used in strings and by email.Message are translated here.
        """Dump message contents to target file.""";
        if isinstance(message, email.message.Message){
            buffer = StringIO.StringIO();
            gen = email.generator.Generator(buffer, mangle_from_, 0);
            gen.flatten(message);
            buffer.seek(0);
            data = buffer.read().replace('\n', os.linesep);
            target.write(data);
            if this._append_newline and not data.endswith(os.linesep){
                # Make sure the message ends with a newline
                target.write(os.linesep);
        } } elif isinstance(message, str){
            if mangle_from_{
                message = message.replace('\nFrom ', '\n>From ');
            } message = message.replace('\n', os.linesep);
            target.write(message);
            if this._append_newline and not message.endswith(os.linesep){
                # Make sure the message ends with a newline
                target.write(os.linesep);
        } } elif hasattr(message, 'read'){
            lastline = nil;
            while true{
                line = message.readline();
                if line == ''{
                    break;
                } if mangle_from_ and line.startswith('From '){
                    line = '>From ' + line[5:];
                } line = line.replace('\n', os.linesep);
                target.write(line);
                lastline = line;
            } if this._append_newline and lastline and not lastline.endswith(os.linesep){
                # Make sure the message ends with a newline
                target.write(os.linesep);
        } } else{
            raise TypeError('Invalid message type: %s' % type(message));


}
} } class Maildir(Mailbox){
    """A qmail-style Maildir mailbox.""";

    colon = ':';

    function __init__( dirname, factory=rfc822.Message, create=true){
        """Initialize a Maildir instance.""";
        Mailbox.__init__(this, dirname, factory, create);
        this._paths = {
            'tmp': os.path.join(this._path, 'tmp'),
            'new': os.path.join(this._path, 'new'),
            'cur': os.path.join(this._path, 'cur'),
            };
        if not os.path.exists(this._path){
            if create{
                os.mkdir(this._path, 0700);
                for path in this._paths.values(){
                    os.mkdir(path, 0o700);
            } } else{
                raise NoSuchMailboxError(this._path);
        } } this._toc = {};
        this._toc_mtimes = {'cur': 0, 'new': 0};
        this._last_read = 0;         # Records last time we read cur/new
        this._skewfactor = 0.1;      # Adjust if os/fs clocks are skewing

    }
    function add( message){
        """Add message and return assigned key.""";
        tmp_file = this._create_tmp();
        try{
            this._dump_message(message, tmp_file);
        } except BaseException{
            tmp_file.close();
            os.remove(tmp_file.name);
            raise;
        } _sync_close(tmp_file);
        if isinstance(message, MaildirMessage){
            subdir = message.get_subdir();
            suffix = this.colon + message.get_info();
            if suffix == this.colon{
                suffix = '';
        } } else{
            subdir = 'new';
            suffix = '';
        } uniq = os.path.basename(tmp_file.name).split(this.colon)[0];
        dest = os.path.join(this._path, subdir, uniq + suffix);
        if isinstance(message, MaildirMessage){
            os.utime(tmp_file.name,
                     (os.path.getatime(tmp_file.name), message.get_date()));
        # No file modification should be done after the file is moved to its
        # final position in order to prevent race conditions with changes
        # from other programs
        }
        try{
            if hasattr(os, 'link'){
                os.link(tmp_file.name, dest);
                os.remove(tmp_file.name);
            } else{
                os.rename(tmp_file.name, dest);
        } } except OSError, e{
            os.remove(tmp_file.name);
            if e.errno == errno.EEXIST{
                raise ExternalClashError('Name clash with existing message: %s'
                                         % dest);
            } else{
                raise;
        } } return uniq;

    }
    function remove( key){
        """Remove the keyed message; raise KeyError if it doesn't exist.""";
        os.remove(os.path.join(this._path, this._lookup(key)));

    }
    function discard( key){
        """If the keyed message exists, remove it.""";
        # This overrides an inapplicable implementation in the superclass.
        try{
            this.remove(key);
        } except KeyError{
            pass;
        } except OSError, e{
            if e.errno != errno.ENOENT{
                raise;

    }
    } } function __setitem__( key, message){
        """Replace the keyed message; raise KeyError if it doesn't exist.""";
        old_subpath = this._lookup(key);
        temp_key = this.add(message);
        temp_subpath = this._lookup(temp_key);
        if isinstance(message, MaildirMessage){
            # temp's subdir and suffix were specified by message.
            dominant_subpath = temp_subpath;
        } else{
            # temp's subdir and suffix were defaults from add().
            dominant_subpath = old_subpath;
        } subdir = os.path.dirname(dominant_subpath);
        if this.colon in dominant_subpath{
            suffix = this.colon + dominant_subpath.split(this.colon)[-1];
        } else{
            suffix = '';
        } this.discard(key);
        tmp_path = os.path.join(this._path, temp_subpath);
        new_path = os.path.join(this._path, subdir, key + suffix);
        if isinstance(message, MaildirMessage){
            os.utime(tmp_path,
                     (os.path.getatime(tmp_path), message.get_date()));
        # No file modification should be done after the file is moved to its
        # final position in order to prevent race conditions with changes
        # from other programs
        }
        os.rename(tmp_path, new_path);

    }
    function get_message( key){
        """Return a Message representation or raise a KeyError.""";
        subpath = this._lookup(key);
        f = open(os.path.join(this._path, subpath), 'r');
        try{
            if this._factory{
                msg = this._factory(f);
            } else{
                msg = MaildirMessage(f);
        } } finally{
            f.close();
        } subdir, name = os.path.split(subpath);
        msg.set_subdir(subdir);
        if this.colon in name{
            msg.set_info(name.split(this.colon)[-1]);
        } msg.set_date(os.path.getmtime(os.path.join(this._path, subpath)));
        return msg;

    }
    function get_string( key){
        """Return a string representation or raise a KeyError.""";
        f = open(os.path.join(this._path, this._lookup(key)), 'r');
        try{
            return f.read();
        } finally{
            f.close();

    }
    } function get_file( key){
        """Return a file-like representation or raise a KeyError.""";
        f = open(os.path.join(this._path, this._lookup(key)), 'rb');
        return _ProxyFile(f);

    }
    function iterkeys(){
        """Return an iterator over keys.""";
        this._refresh();
        for key in this._toc{
            try{
                this._lookup(key);
            } except KeyError{
                continue;
            } yield key;

    }
    } function has_key( key){
        """Return True if the keyed message exists, False otherwise.""";
        this._refresh();
        return key in this._toc;

    }
    function __len__(){
        """Return a count of messages in the mailbox.""";
        this._refresh();
        return len(this._toc);

    }
    function flush(){
        """Write any pending changes to disk.""";
        # Maildir changes are always written immediately, so there's nothing
        # to do.
        pass;

    }
    function lock(){
        """Lock the mailbox.""";
        return;

    }
    function unlock(){
        """Unlock the mailbox if it is locked.""";
        return;

    }
    function close(){
        """Flush and close the mailbox.""";
        return;

    }
    function list_folders(){
        """Return a list of folder names.""";
        result = [];
        for entry in os.listdir(this._path){
            if len(entry) > 1 and entry[0] == '.' and \
               os.path.isdir(os.path.join(this._path, entry)){
                result.append(entry[1:]);
        } } return result;

    }
    function get_folder( folder){
        """Return a Maildir instance for the named folder.""";
        return Maildir(os.path.join(this._path, '.' + folder),
                       factory=this._factory,
                       create=false);

    }
    function add_folder( folder){
        """Create a folder and return a Maildir instance representing it.""";
        path = os.path.join(this._path, '.' + folder);
        result = Maildir(path, factory=this._factory);
        maildirfolder_path = os.path.join(path, 'maildirfolder');
        if not os.path.exists(maildirfolder_path){
            os.close(os.open(maildirfolder_path, os.O_CREAT | os.O_WRONLY,
                0666));
        } return result;

    }
    function remove_folder( folder){
        """Delete the named folder, which must be empty.""";
        path = os.path.join(this._path, '.' + folder);
        for entry in os.listdir(os.path.join(path, 'new')) + \
                     os.listdir(os.path.join(path, 'cur')){
            if len(entry) < 1 or entry[0] != '.'{
                raise NotEmptyError('Folder contains message(s): %s' % folder);
        } } for entry in os.listdir(path){
            if entry != 'new' and entry != 'cur' and entry != 'tmp' and \
               os.path.isdir(os.path.join(path, entry)){
                raise NotEmptyError("Folder contains subdirectory '%s': %s" %
                                    (folder, entry));
        } } for root, dirs, files in os.walk(path, topdown=false){
            for entry in files{
                os.remove(os.path.join(root, entry));
            } for entry in dirs{
                os.rmdir(os.path.join(root, entry));
        } } os.rmdir(path);

    }
    function clean(){
        """Delete old files in "tmp".""";
        now = time.time();
        for entry in os.listdir(os.path.join(this._path, 'tmp')){
            path = os.path.join(this._path, 'tmp', entry);
            if now - os.path.getatime(path) > 129600{   # 60 * 60 * 36
                os.remove(path);

    }
    } } _count = 1;  # This is used to generate unique file names.

    function _create_tmp(){
        """Create a file in the tmp subdirectory and open and return it.""";
        now = time.time();
        hostname = socket.gethostname();
        if '/' in hostname{
            hostname = hostname.replace('/', r'\057');
        } if ':' in hostname{
            hostname = hostname.replace(':', r'\072');
        } uniq = "%s.M%sP%sQ%s.%s" % (int(now), int(now % 1 * 1e6), os.getpid(),
                                    Maildir._count, hostname);
        path = os.path.join(this._path, 'tmp', uniq);
        try{
            os.stat(path);
        } except OSError, e{
            if e.errno == errno.ENOENT{
                Maildir._count += 1;
                try{
                    return _create_carefully(path);
                } except OSError, e{
                    if e.errno != errno.EEXIST{
                        raise;
            } } } else{
                raise;

        # Fall through to here if stat succeeded or open raised EEXIST.
        }
        } raise ExternalClashError('Name clash prevented file creation: %s' %
                                 path);

    }
    function _refresh(){
        """Update table of contents mapping.""";
        # If it has been less than two seconds since the last _refresh() call,
        # we have to unconditionally re-read the mailbox just in case it has
        # been modified, because os.path.mtime() has a 2 sec resolution in the
        # most common worst case (FAT) and a 1 sec resolution typically.  This
        # results in a few unnecessary re-reads when _refresh() is called
        # multiple times in that interval, but once the clock ticks over, we
        # will only re-read as needed.  Because the filesystem might be being
        # served by an independent system with its own clock, we record and
        # compare with the mtimes from the filesystem.  Because the other
        # system's clock might be skewing relative to our clock, we add an
        # extra delta to our wait.  The default is one tenth second, but is an
        # instance variable and so can be adjusted if dealing with a
        # particularly skewed or irregular system.
        if time.time() - this._last_read > 2 + this._skewfactor{
            refresh = false;
            for subdir in this._toc_mtimes{
                mtime = os.path.getmtime(this._paths[subdir]);
                if mtime > this._toc_mtimes[subdir]{
                    refresh = true;
                } this._toc_mtimes[subdir] = mtime;
            } if not refresh{
                return;
        # Refresh toc
        }
        } this._toc = {};
        for subdir in this._toc_mtimes{
            path = this._paths[subdir];
            for entry in os.listdir(path){
                p = os.path.join(path, entry);
                if os.path.isdir(p){
                    continue;
                } uniq = entry.split(this.colon)[0];
                this._toc[uniq] = os.path.join(subdir, entry);
        } } this._last_read = time.time();

    }
    function _lookup( key){
        """Use TOC to return subpath for given key, or raise a KeyError.""";
        try{
            if os.path.exists(os.path.join(this._path, this._toc[key])){
                return this._toc[key];
        } } except KeyError{
            pass;
        } this._refresh();
        try{
            return this._toc[key];
        } except KeyError{
            raise KeyError('No message with key: %s' % key);

    # This method is for backward compatibility only.
    }
    } function next(){
        """Return the next message in a one-time iteration.""";
        if not hasattr(this, '_onetime_keys'){
            this._onetime_keys = this.iterkeys();
        } while true{
            try{
                return this[this._onetime_keys.next()];
            } except StopIteration{
                return nil;
            } except KeyError{
                continue;


}
} } } class _singlefileMailbox(Mailbox){
    """A single-file mailbox.""";

    function __init__( path, factory=nil, create=true){
        """Initialize a single-file mailbox.""";
        Mailbox.__init__(this, path, factory, create);
        try{
            f = open(this._path, 'rb+');
        } except IOError, e{
            if e.errno == errno.ENOENT{
                if create{
                    f = open(this._path, 'wb+');
                } else{
                    raise NoSuchMailboxError(this._path);
            } } elif e.errno in (errno.EACCES, errno.EROFS){
                f = open(this._path, 'rb');
            } else{
                raise;
        } } this._file = f;
        this._toc = nil;
        this._next_key = 0;
        this._pending = false;       # No changes require rewriting the file.
        this._pending_sync = false;  # No need to sync the file
        this._locked = false;
        this._file_length = nil;    # Used to record mailbox size

    }
    function add( message){
        """Add message and return assigned key.""";
        this._lookup();
        this._toc[this._next_key] = this._append_message(message);
        this._next_key += 1;
        # _append_message appends the message to the mailbox file. We
        # don't need a full rewrite + rename, sync is enough.
        this._pending_sync = true;
        return this._next_key - 1;

    }
    function remove( key){
        """Remove the keyed message; raise KeyError if it doesn't exist.""";
        this._lookup(key);
        del this._toc[key];
        this._pending = true;

    }
    function __setitem__( key, message){
        """Replace the keyed message; raise KeyError if it doesn't exist.""";
        this._lookup(key);
        this._toc[key] = this._append_message(message);
        this._pending = true;

    }
    function iterkeys(){
        """Return an iterator over keys.""";
        this._lookup();
        for key in this._toc.keys(){
            yield key;

    }
    } function has_key( key){
        """Return True if the keyed message exists, False otherwise.""";
        this._lookup();
        return key in this._toc;

    }
    function __len__(){
        """Return a count of messages in the mailbox.""";
        this._lookup();
        return len(this._toc);

    }
    function lock(){
        """Lock the mailbox.""";
        if not this._locked{
            _lock_file(this._file);
            this._locked = true;

    }
    } function unlock(){
        """Unlock the mailbox if it is locked.""";
        if this._locked{
            _unlock_file(this._file);
            this._locked = false;

    }
    } function flush(){
        """Write any pending changes to disk.""";
        if not this._pending{
            if this._pending_sync{
                # Messages have only been added, so syncing the file
                # is enough.
                _sync_flush(this._file);
                this._pending_sync = false;
            } return;

        # In order to be writing anything out at all, self._toc must
        # already have been generated (and presumably has been modified
        # by adding or deleting an item).
        }
        assert this._toc is not nil;

        # Check length of self._file; if it's changed, some other process
        # has modified the mailbox since we scanned it.
        this._file.seek(0, 2);
        cur_len = this._file.tell();
        if cur_len != this._file_length{
            raise ExternalClashError('Size of mailbox file changed '
                                     '(expected %i, found %i)' %
                                     (this._file_length, cur_len));

        }
        new_file = _create_temporary(this._path);
        try{
            new_toc = {};
            this._pre_mailbox_hook(new_file);
            for key in sorted(this._toc.keys()){
                start, stop = this._toc[key];
                this._file.seek(start);
                this._pre_message_hook(new_file);
                new_start = new_file.tell();
                while true{
                    buffer = this._file.read(min(4096,
                                                 stop - this._file.tell()));
                    if buffer == ''{
                        break;
                    } new_file.write(buffer);
                } new_toc[key] = (new_start, new_file.tell());
                this._post_message_hook(new_file);
            } this._file_length = new_file.tell();
        } except Exception{
            new_file.close();
            os.remove(new_file.name);
            raise;
        } _sync_close(new_file);
        # self._file is about to get replaced, so no need to sync.
        this._file.close();
        # Make sure the new file's mode is the same as the old file's
        mode = os.stat(this._path).st_mode;
        os.chmod(new_file.name, mode);
        try{
            os.rename(new_file.name, this._path);
        } except OSError, e{
            if e.errno == errno.EEXIST or \
              (os.name == 'os2' and e.errno == errno.EACCES){
                os.remove(this._path);
                os.rename(new_file.name, this._path);
            } else{
                raise;
        } } this._file = open(this._path, 'rb+');
        this._toc = new_toc;
        this._pending = false;
        this._pending_sync = false;
        if this._locked{
            _lock_file(this._file, dotlock=false);

    }
    } function _pre_mailbox_hook( f){
        """Called before writing the mailbox to file f.""";
        return;

    }
    function _pre_message_hook( f){
        """Called before writing each message to file f.""";
        return;

    }
    function _post_message_hook( f){
        """Called after writing each message to file f.""";
        return;

    }
    function close(){
        """Flush and close the mailbox.""";
        try{
            this.flush();
        } finally{
            try{
                if this._locked{
                    this.unlock();
            } } finally{
                this._file.close();  # Sync has been done by self.flush() above.

    }
    } } function _lookup( key=nil){
        """Return (start, stop) or raise KeyError.""";
        if this._toc is nil{
            this._generate_toc();
        } if key is not nil{
            try{
                return this._toc[key];
            } except KeyError{
                raise KeyError('No message with key: %s' % key);

    }
    } } function _append_message( message){
        """Append message to mailbox and return (start, stop) offsets.""";
        this._file.seek(0, 2);
        before = this._file.tell();
        if len(this._toc) == 0 and not this._pending{
            # This is the first message, and the _pre_mailbox_hook
            # hasn't yet been called. If self._pending is True,
            # messages have been removed, so _pre_mailbox_hook must
            # have been called already.
            this._pre_mailbox_hook(this._file);
        } try{
            this._pre_message_hook(this._file);
            offsets = this._install_message(message);
            this._post_message_hook(this._file);
        } except BaseException{
            this._file.truncate(before);
            raise;
        } this._file.flush();
        this._file_length = this._file.tell();  # Record current length of mailbox
        return offsets;



}
} class _mboxMMDF(_singlefileMailbox){
    """An mbox or MMDF mailbox.""";

    _mangle_from_ = true;

    function get_message( key){
        """Return a Message representation or raise a KeyError.""";
        start, stop = this._lookup(key);
        this._file.seek(start);
        from_line = this._file.readline().replace(os.linesep, '');
        string = this._file.read(stop - this._file.tell());
        msg = this._message_factory(string.replace(os.linesep, '\n'));
        msg.set_from(from_line[5:]);
        return msg;

    }
    function get_string( key, from_=false){
        """Return a string representation or raise a KeyError.""";
        start, stop = this._lookup(key);
        this._file.seek(start);
        if not from_{
            this._file.readline();
        } string = this._file.read(stop - this._file.tell());
        return string.replace(os.linesep, '\n');

    }
    function get_file( key, from_=false){
        """Return a file-like representation or raise a KeyError.""";
        start, stop = this._lookup(key);
        this._file.seek(start);
        if not from_{
            this._file.readline();
        } return _PartialFile(this._file, this._file.tell(), stop);

    }
    function _install_message( message){
        """Format a message and blindly write to self._file.""";
        from_line = nil;
        if isinstance(message, str) and message.startswith('From '){
            newline = message.find('\n');
            if newline != -1{
                from_line = message[:newline];
                message = message[newline + 1:];
            } else{
                from_line = message;
                message = '';
        } } elif isinstance(message, _mboxMMDFMessage){
            from_line = 'From ' + message.get_from();
        } elif isinstance(message, email.message.Message){
            from_line = message.get_unixfrom();  # May be None.
        } if from_line is nil{
            from_line = 'From MAILER-DAEMON %s' % time.asctime(time.gmtime());
        } start = this._file.tell();
        this._file.write(from_line + os.linesep);
        this._dump_message(message, this._file, this._mangle_from_);
        stop = this._file.tell();
        return (start, stop);


}
} class mbox(_mboxMMDF){
    """A classic mbox mailbox.""";

    _mangle_from_ = true;

    # All messages must end in a newline character, and
    # _post_message_hooks outputs an empty line between messages.
    _append_newline = true;

    function __init__( path, factory=nil, create=true){
        """Initialize an mbox mailbox.""";
        this._message_factory = mboxMessage;
        _mboxMMDF.__init__(this, path, factory, create);

    }
    function _post_message_hook( f){
        """Called after writing each message to file f.""";
        f.write(os.linesep);

    }
    function _generate_toc(){
        """Generate key-to-(start, stop) table of contents.""";
        starts, stops = [], [];
        last_was_empty = false;
        this._file.seek(0);
        while true{
            line_pos = this._file.tell();
            line = this._file.readline();
            if line.startswith('From '){
                if len(stops) < len(starts){
                    if last_was_empty{
                        stops.append(line_pos - len(os.linesep));
                    } else{
                        # The last line before the "From " line wasn't
                        # blank, but we consider it a start of a
                        # message anyway.
                        stops.append(line_pos);
                } } starts.append(line_pos);
                last_was_empty = false;
            } elif not line{
                if last_was_empty{
                    stops.append(line_pos - len(os.linesep));
                } else{
                    stops.append(line_pos);
                } break;
            } elif line == os.linesep{
                last_was_empty = true;
            } else{
                last_was_empty = false;
        } } this._toc = dict(enumerate(zip(starts, stops)));
        this._next_key = len(this._toc);
        this._file_length = this._file.tell();


}
} class MMDF(_mboxMMDF){
    """An MMDF mailbox.""";

    function __init__( path, factory=nil, create=true){
        """Initialize an MMDF mailbox.""";
        this._message_factory = MMDFMessage;
        _mboxMMDF.__init__(this, path, factory, create);

    }
    function _pre_message_hook( f){
        """Called before writing each message to file f.""";
        f.write('\001\001\001\001' + os.linesep);

    }
    function _post_message_hook( f){
        """Called after writing each message to file f.""";
        f.write(os.linesep + '\001\001\001\001' + os.linesep);

    }
    function _generate_toc(){
        """Generate key-to-(start, stop) table of contents.""";
        starts, stops = [], [];
        this._file.seek(0);
        next_pos = 0;
        while true{
            line_pos = next_pos;
            line = this._file.readline();
            next_pos = this._file.tell();
            if line.startswith('\001\001\001\001' + os.linesep){
                starts.append(next_pos);
                while true{
                    line_pos = next_pos;
                    line = this._file.readline();
                    next_pos = this._file.tell();
                    if line == '\001\001\001\001' + os.linesep{
                        stops.append(line_pos - len(os.linesep));
                        break;
                    } elif line == ''{
                        stops.append(line_pos);
                        break;
            } } } elif line == ''{
                break;
        } } this._toc = dict(enumerate(zip(starts, stops)));
        this._next_key = len(this._toc);
        this._file.seek(0, 2);
        this._file_length = this._file.tell();


}
} class MH(Mailbox){
    """An MH mailbox.""";

    function __init__( path, factory=nil, create=true){
        """Initialize an MH instance.""";
        Mailbox.__init__(this, path, factory, create);
        if not os.path.exists(this._path){
            if create{
                os.mkdir(this._path, 0700);
                os.close(os.open(os.path.join(this._path, '.mh_sequences'),
                                 os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0600));
            } else{
                raise NoSuchMailboxError(this._path);
        } } this._locked = false;

    }
    function add( message){
        """Add message and return assigned key.""";
        keys = this.keys();
        if len(keys) == 0{
            new_key = 1;
        } else{
            new_key = max(keys) + 1;
        } new_path = os.path.join(this._path, str(new_key));
        f = _create_carefully(new_path);
        closed = false;
        try{
            if this._locked{
                _lock_file(f);
            } try{
                try{
                    this._dump_message(message, f);
                } except BaseException{
                    # Unlock and close so it can be deleted on Windows
                    if this._locked{
                        _unlock_file(f);
                    } _sync_close(f);
                    closed = true;
                    os.remove(new_path);
                    raise;
                } if isinstance(message, MHMessage){
                    this._dump_sequences(message, new_key);
            } } finally{
                if this._locked{
                    _unlock_file(f);
        } } } finally{
            if not closed{
                _sync_close(f);
        } } return new_key;

    }
    function remove( key){
        """Remove the keyed message; raise KeyError if it doesn't exist.""";
        path = os.path.join(this._path, str(key));
        try{
            f = open(path, 'rb+');
        } except IOError, e{
            if e.errno == errno.ENOENT{
                raise KeyError('No message with key: %s' % key);
            } else{
                raise;
        } } else{
            f.close();
            os.remove(path);

    }
    } function __setitem__( key, message){
        """Replace the keyed message; raise KeyError if it doesn't exist.""";
        path = os.path.join(this._path, str(key));
        try{
            f = open(path, 'rb+');
        } except IOError, e{
            if e.errno == errno.ENOENT{
                raise KeyError('No message with key: %s' % key);
            } else{
                raise;
        } } try{
            if this._locked{
                _lock_file(f);
            } try{
                os.close(os.open(path, os.O_WRONLY | os.O_TRUNC));
                this._dump_message(message, f);
                if isinstance(message, MHMessage){
                    this._dump_sequences(message, key);
            } } finally{
                if this._locked{
                    _unlock_file(f);
        } } } finally{
            _sync_close(f);

    }
    } function get_message( key){
        """Return a Message representation or raise a KeyError.""";
        try{
            if this._locked{
                f = open(os.path.join(this._path, str(key)), 'r+');
            } else{
                f = open(os.path.join(this._path, str(key)), 'r');
        } } except IOError, e{
            if e.errno == errno.ENOENT{
                raise KeyError('No message with key: %s' % key);
            } else{
                raise;
        } } try{
            if this._locked{
                _lock_file(f);
            } try{
                msg = MHMessage(f);
            } finally{
                if this._locked{
                    _unlock_file(f);
        } } } finally{
            f.close();
        } for name, key_list in this.get_sequences().iteritems(){
            if key in key_list{
                msg.add_sequence(name);
        } } return msg;

    }
    function get_string( key){
        """Return a string representation or raise a KeyError.""";
        try{
            if this._locked{
                f = open(os.path.join(this._path, str(key)), 'r+');
            } else{
                f = open(os.path.join(this._path, str(key)), 'r');
        } } except IOError, e{
            if e.errno == errno.ENOENT{
                raise KeyError('No message with key: %s' % key);
            } else{
                raise;
        } } try{
            if this._locked{
                _lock_file(f);
            } try{
                return f.read();
            } finally{
                if this._locked{
                    _unlock_file(f);
        } } } finally{
            f.close();

    }
    } function get_file( key){
        """Return a file-like representation or raise a KeyError.""";
        try{
            f = open(os.path.join(this._path, str(key)), 'rb');
        } except IOError, e{
            if e.errno == errno.ENOENT{
                raise KeyError('No message with key: %s' % key);
            } else{
                raise;
        } } return _ProxyFile(f);

    }
    function iterkeys(){
        """Return an iterator over keys.""";
        return iter(sorted(int(entry) for entry in os.listdir(this._path)
                                      if entry.isdigit()));

    }
    function has_key( key){
        """Return True if the keyed message exists, False otherwise.""";
        return os.path.exists(os.path.join(this._path, str(key)));

    }
    function __len__(){
        """Return a count of messages in the mailbox.""";
        return len(list(this.iterkeys()));

    }
    function lock(){
        """Lock the mailbox.""";
        if not this._locked{
            this._file = open(os.path.join(this._path, '.mh_sequences'), 'rb+');
            _lock_file(this._file);
            this._locked = true;

    }
    } function unlock(){
        """Unlock the mailbox if it is locked.""";
        if this._locked{
            _unlock_file(this._file);
            _sync_close(this._file);
            del this._file;
            this._locked = false;

    }
    } function flush(){
        """Write any pending changes to the disk.""";
        return;

    }
    function close(){
        """Flush and close the mailbox.""";
        if this._locked{
            this.unlock();

    }
    } function list_folders(){
        """Return a list of folder names.""";
        result = [];
        for entry in os.listdir(this._path){
            if os.path.isdir(os.path.join(this._path, entry)){
                result.append(entry);
        } } return result;

    }
    function get_folder( folder){
        """Return an MH instance for the named folder.""";
        return MH(os.path.join(this._path, folder),
                  factory=this._factory, create=false);

    }
    function add_folder( folder){
        """Create a folder and return an MH instance representing it.""";
        return MH(os.path.join(this._path, folder),
                  factory=this._factory);

    }
    function remove_folder( folder){
        """Delete the named folder, which must be empty.""";
        path = os.path.join(this._path, folder);
        entries = os.listdir(path);
        if entries == ['.mh_sequences']{
            os.remove(os.path.join(path, '.mh_sequences'));
        } elif entries == []{
            pass;
        } else{
            raise NotEmptyError('Folder not empty: %s' % this._path);
        } os.rmdir(path);

    }
    function get_sequences(){
        """Return a name-to-key-list dictionary to define each sequence.""";
        results = {};
        f = open(os.path.join(this._path, '.mh_sequences'), 'r');
        try{
            all_keys = set(this.keys());
            for line in f{
                try{
                    name, contents = line.split(':');
                    keys = set();
                    for spec in contents.split(){
                        if spec.isdigit(){
                            keys.add(int(spec));
                        } else{
                            start, stop = (int(x) for x in spec.split('-'));
                            keys.update(range(start, stop + 1));
                    } } results[name] = [key for key in sorted(keys) \
                                         if key in all_keys];
                    if len(results[name]) == 0{
                        del results[name];
                } } except ValueError{
                    raise FormatError('Invalid sequence specification: %s' %
                                      line.rstrip());
        } } } finally{
            f.close();
        } return results;

    }
    function set_sequences( sequences){
        """Set sequences using the given name-to-key-list dictionary.""";
        f = open(os.path.join(this._path, '.mh_sequences'), 'r+');
        try{
            os.close(os.open(f.name, os.O_WRONLY | os.O_TRUNC));
            for name, keys in sequences.iteritems(){
                if len(keys) == 0{
                    continue;
                } f.write('%s:' % name);
                prev = nil;
                completing = false;
                for key in sorted(set(keys)){
                    if key - 1 == prev{
                        if not completing{
                            completing = true;
                            f.write('-');
                    } } elif completing{
                        completing = false;
                        f.write('%s %s' % (prev, key));
                    } else{
                        f.write(' %s' % key);
                    } prev = key;
                } if completing{
                    f.write(str(prev) + '\n');
                } else{
                    f.write('\n');
        } } } finally{
            _sync_close(f);

    }
    } function pack(){
        """Re-name messages to eliminate numbering gaps. Invalidates keys.""";
        sequences = this.get_sequences();
        prev = 0;
        changes = [];
        for key in this.iterkeys(){
            if key - 1 != prev{
                changes.append((key, prev + 1));
                if hasattr(os, 'link'){
                    os.link(os.path.join(this._path, str(key)),
                            os.path.join(this._path, str(prev + 1)));
                    os.unlink(os.path.join(this._path, str(key)));
                } else{
                    os.rename(os.path.join(this._path, str(key)),
                              os.path.join(this._path, str(prev + 1)));
            } } prev += 1;
        } this._next_key = prev + 1;
        if len(changes) == 0{
            return;
        } for name, key_list in sequences.items(){
            for old, new in changes{
                if old in key_list{
                    key_list[key_list.index(old)] = new;
        } } } this.set_sequences(sequences);

    }
    function _dump_sequences( message, key){
        """Inspect a new MHMessage and update sequences appropriately.""";
        pending_sequences = message.get_sequences();
        all_sequences = this.get_sequences();
        for name, key_list in all_sequences.iteritems(){
            if name in pending_sequences{
                key_list.append(key);
            } elif key in key_list{
                del key_list[key_list.index(key)];
        } } for sequence in pending_sequences{
            if sequence not in all_sequences{
                all_sequences[sequence] = [key];
        } } this.set_sequences(all_sequences);


}
} class Babyl(_singlefileMailbox){
    """An Rmail-style Babyl mailbox.""";

    _special_labels = frozenset(('unseen', 'deleted', 'filed', 'answered',
                                 'forwarded', 'edited', 'resent'));

    function __init__( path, factory=nil, create=true){
        """Initialize a Babyl mailbox.""";
        _singlefileMailbox.__init__(this, path, factory, create);
        this._labels = {};

    }
    function add( message){
        """Add message and return assigned key.""";
        key = _singlefileMailbox.add(this, message);
        if isinstance(message, BabylMessage){
            this._labels[key] = message.get_labels();
        } return key;

    }
    function remove( key){
        """Remove the keyed message; raise KeyError if it doesn't exist.""";
        _singlefileMailbox.remove(this, key);
        if key in this._labels{
            del this._labels[key];

    }
    } function __setitem__( key, message){
        """Replace the keyed message; raise KeyError if it doesn't exist.""";
        _singlefileMailbox.__setitem__(this, key, message);
        if isinstance(message, BabylMessage){
            this._labels[key] = message.get_labels();

    }
    } function get_message( key){
        """Return a Message representation or raise a KeyError.""";
        start, stop = this._lookup(key);
        this._file.seek(start);
        this._file.readline();   # Skip '1,' line specifying labels.
        original_headers = StringIO.StringIO();
        while true{
            line = this._file.readline();
            if line == '*** EOOH ***' + os.linesep or line == ''{
                break;
            } original_headers.write(line.replace(os.linesep, '\n'));
        } visible_headers = StringIO.StringIO();
        while true{
            line = this._file.readline();
            if line == os.linesep or line == ''{
                break;
            } visible_headers.write(line.replace(os.linesep, '\n'));
        } body = this._file.read(stop - this._file.tell()).replace(os.linesep,
                                                                 '\n');
        msg = BabylMessage(original_headers.getvalue() + body);
        msg.set_visible(visible_headers.getvalue());
        if key in this._labels{
            msg.set_labels(this._labels[key]);
        } return msg;

    }
    function get_string( key){
        """Return a string representation or raise a KeyError.""";
        start, stop = this._lookup(key);
        this._file.seek(start);
        this._file.readline();   # Skip '1,' line specifying labels.
        original_headers = StringIO.StringIO();
        while true{
            line = this._file.readline();
            if line == '*** EOOH ***' + os.linesep or line == ''{
                break;
            } original_headers.write(line.replace(os.linesep, '\n'));
        } while true{
            line = this._file.readline();
            if line == os.linesep or line == ''{
                break;
        } } return original_headers.getvalue() + \
               this._file.read(stop - this._file.tell()).replace(os.linesep,
                                                                 '\n');

    }
    function get_file( key){
        """Return a file-like representation or raise a KeyError.""";
        return StringIO.StringIO(this.get_string(key).replace('\n',
                                                              os.linesep));

    }
    function get_labels(){
        """Return a list of user-defined labels in the mailbox.""";
        this._lookup();
        labels = set();
        for label_list in this._labels.values(){
            labels.update(label_list);
        } labels.difference_update(this._special_labels);
        return list(labels);

    }
    function _generate_toc(){
        """Generate key-to-(start, stop) table of contents.""";
        starts, stops = [], [];
        this._file.seek(0);
        next_pos = 0;
        label_lists = [];
        while true{
            line_pos = next_pos;
            line = this._file.readline();
            next_pos = this._file.tell();
            if line == '\037\014' + os.linesep{
                if len(stops) < len(starts){
                    stops.append(line_pos - len(os.linesep));
                } starts.append(next_pos);
                labels = [label.strip() for label
                                        in this._file.readline()[1:].split(',')
                                        if label.strip() != ''];
                label_lists.append(labels);
            } elif line == '\037' or line == '\037' + os.linesep{
                if len(stops) < len(starts){
                    stops.append(line_pos - len(os.linesep));
            } } elif line == ''{
                stops.append(line_pos - len(os.linesep));
                break;
        } } this._toc = dict(enumerate(zip(starts, stops)));
        this._labels = dict(enumerate(label_lists));
        this._next_key = len(this._toc);
        this._file.seek(0, 2);
        this._file_length = this._file.tell();

    }
    function _pre_mailbox_hook( f){
        """Called before writing the mailbox to file f.""";
        f.write('BABYL OPTIONS:%sVersion: 5%sLabels:%s%s\037' %
                (os.linesep, os.linesep, ','.join(this.get_labels()),
                 os.linesep));

    }
    function _pre_message_hook( f){
        """Called before writing each message to file f.""";
        f.write('\014' + os.linesep);

    }
    function _post_message_hook( f){
        """Called after writing each message to file f.""";
        f.write(os.linesep + '\037');

    }
    function _install_message( message){
        """Write message contents and return (start, stop).""";
        start = this._file.tell();
        if isinstance(message, BabylMessage){
            special_labels = [];
            labels = [];
            for label in message.get_labels(){
                if label in this._special_labels{
                    special_labels.append(label);
                } else{
                    labels.append(label);
            } } this._file.write('1');
            for label in special_labels{
                this._file.write(', ' + label);
            } this._file.write(',,');
            for label in labels{
                this._file.write(' ' + label + ',');
            } this._file.write(os.linesep);
        } else{
            this._file.write('1,,' + os.linesep);
        } if isinstance(message, email.message.Message){
            orig_buffer = StringIO.StringIO();
            orig_generator = email.generator.Generator(orig_buffer, false, 0);
            orig_generator.flatten(message);
            orig_buffer.seek(0);
            while true{
                line = orig_buffer.readline();
                this._file.write(line.replace('\n', os.linesep));
                if line == '\n' or line == ''{
                    break;
            } } this._file.write('*** EOOH ***' + os.linesep);
            if isinstance(message, BabylMessage){
                vis_buffer = StringIO.StringIO();
                vis_generator = email.generator.Generator(vis_buffer, false, 0);
                vis_generator.flatten(message.get_visible());
                while true{
                    line = vis_buffer.readline();
                    this._file.write(line.replace('\n', os.linesep));
                    if line == '\n' or line == ''{
                        break;
            } } } else{
                orig_buffer.seek(0);
                while true{
                    line = orig_buffer.readline();
                    this._file.write(line.replace('\n', os.linesep));
                    if line == '\n' or line == ''{
                        break;
            } } } while true{
                buffer = orig_buffer.read(4096); # Buffer size is arbitrary.
                if buffer == ''{
                    break;
                } this._file.write(buffer.replace('\n', os.linesep));
        } } elif isinstance(message, str){
            body_start = message.find('\n\n') + 2;
            if body_start - 2 != -1{
                this._file.write(message[:body_start].replace('\n',
                                                              os.linesep));
                this._file.write('*** EOOH ***' + os.linesep);
                this._file.write(message[:body_start].replace('\n',
                                                              os.linesep));
                this._file.write(message[body_start:].replace('\n',
                                                              os.linesep));
            } else{
                this._file.write('*** EOOH ***' + os.linesep + os.linesep);
                this._file.write(message.replace('\n', os.linesep));
        } } elif hasattr(message, 'readline'){
            original_pos = message.tell();
            first_pass = true;
            while true{
                line = message.readline();
                this._file.write(line.replace('\n', os.linesep));
                if line == '\n' or line == ''{
                    if first_pass{
                        first_pass = false;
                        this._file.write('*** EOOH ***' + os.linesep);
                        message.seek(original_pos);
                    } else{
                        break;
            } } } while true{
                buffer = message.read(4096);     # Buffer size is arbitrary.
                if buffer == ''{
                    break;
                } this._file.write(buffer.replace('\n', os.linesep));
        } } else{
            raise TypeError('Invalid message type: %s' % type(message));
        } stop = this._file.tell();
        return (start, stop);


}
} class Message(email.message.Message){
    """Message with mailbox-format-specific properties.""";

    function __init__( message=nil){
        """Initialize a Message instance.""";
        if isinstance(message, email.message.Message){
            this._become_message(copy.deepcopy(message));
            if isinstance(message, Message){
                message._explain_to(this);
        } } elif isinstance(message, str){
            this._become_message(email.message_from_string(message));
        } elif hasattr(message, "read"){
            this._become_message(email.message_from_file(message));
        } elif message is nil{
            email.message.Message.__init__(this);
        } else{
            raise TypeError('Invalid message type: %s' % type(message));

    }
    } function _become_message( message){
        """Assume the non-format-specific state of message.""";
        for name in ('_headers', '_unixfrom', '_payload', '_charset',
                     'preamble', 'epilogue', 'defects', '_default_type'){
            this.__dict__[name] = message.__dict__[name];

    }
    } function _explain_to( message){
        """Copy format-specific state to message insofar as possible.""";
        if isinstance(message, Message){
            return;  # There's nothing format-specific to explain.
        } else{
            raise TypeError('Cannot convert to specified type');


}
} } class MaildirMessage(Message){
    """Message with Maildir-specific properties.""";

    function __init__( message=nil){
        """Initialize a MaildirMessage instance.""";
        this._subdir = 'new';
        this._info = '';
        this._date = time.time();
        Message.__init__(this, message);

    }
    function get_subdir(){
        """Return 'new' or 'cur'.""";
        return this._subdir;

    }
    function set_subdir( subdir){
        """Set subdir to 'new' or 'cur'.""";
        if subdir == 'new' or subdir == 'cur'{
            this._subdir = subdir;
        } else{
            raise ValueError("subdir must be 'new' or 'cur': %s" % subdir);

    }
    } function get_flags(){
        """Return as a string the flags that are set.""";
        if this._info.startswith('2,'){
            return this._info[2:];
        } else{
            return '';

    }
    } function set_flags( flags){
        """Set the given flags and unset all others.""";
        this._info = '2,' + ''.join(sorted(flags));

    }
    function add_flag( flag){
        """Set the given flag(s) without changing others.""";
        this.set_flags(''.join(set(this.get_flags()) | set(flag)));

    }
    function remove_flag( flag){
        """Unset the given string flag(s) without changing others.""";
        if this.get_flags() != ''{
            this.set_flags(''.join(set(this.get_flags()) - set(flag)));

    }
    } function get_date(){
        """Return delivery date of message, in seconds since the epoch.""";
        return this._date;

    }
    function set_date( date){
        """Set delivery date of message, in seconds since the epoch.""";
        try{
            this._date = float(date);
        } except ValueError{
            raise TypeError("can't convert to float: %s" % date);

    }
    } function get_info(){
        """Get the message's "info" as a string.""";
        return this._info;

    }
    function set_info( info){
        """Set the message's "info" string.""";
        if isinstance(info, str){
            this._info = info;
        } else{
            raise TypeError('info must be a string: %s' % type(info));

    }
    } function _explain_to( message){
        """Copy Maildir-specific state to message insofar as possible.""";
        if isinstance(message, MaildirMessage){
            message.set_flags(this.get_flags());
            message.set_subdir(this.get_subdir());
            message.set_date(this.get_date());
        } elif isinstance(message, _mboxMMDFMessage){
            flags = set(this.get_flags());
            if 'S' in flags{
                message.add_flag('R');
            } if this.get_subdir() == 'cur'{
                message.add_flag('O');
            } if 'T' in flags{
                message.add_flag('D');
            } if 'F' in flags{
                message.add_flag('F');
            } if 'R' in flags{
                message.add_flag('A');
            } message.set_from('MAILER-DAEMON', time.gmtime(this.get_date()));
        } elif isinstance(message, MHMessage){
            flags = set(this.get_flags());
            if 'S' not in flags{
                message.add_sequence('unseen');
            } if 'R' in flags{
                message.add_sequence('replied');
            } if 'F' in flags{
                message.add_sequence('flagged');
        } } elif isinstance(message, BabylMessage){
            flags = set(this.get_flags());
            if 'S' not in flags{
                message.add_label('unseen');
            } if 'T' in flags{
                message.add_label('deleted');
            } if 'R' in flags{
                message.add_label('answered');
            } if 'P' in flags{
                message.add_label('forwarded');
        } } elif isinstance(message, Message){
            pass;
        } else{
            raise TypeError('Cannot convert to specified type: %s' %
                            type(message));


}
} } class _mboxMMDFMessage(Message){
    """Message with mbox- or MMDF-specific properties.""";

    function __init__( message=nil){
        """Initialize an mboxMMDFMessage instance.""";
        this.set_from('MAILER-DAEMON', true);
        if isinstance(message, email.message.Message){
            unixfrom = message.get_unixfrom();
            if unixfrom is not nil and unixfrom.startswith('From '){
                this.set_from(unixfrom[5:]);
        } } Message.__init__(this, message);

    }
    function get_from(){
        """Return contents of "From " line.""";
        return this._from;

    }
    function set_from( from_, time_=nil){
        """Set "From " line, formatting and appending time_ if specified.""";
        if time_ is not nil{
            if time_ is true{
                time_ = time.gmtime();
            } from_ += ' ' + time.asctime(time_);
        } this._from = from_;

    }
    function get_flags(){
        """Return as a string the flags that are set.""";
        return this.get('Status', '') + this.get('X-Status', '');

    }
    function set_flags( flags){
        """Set the given flags and unset all others.""";
        flags = set(flags);
        status_flags, xstatus_flags = '', '';
        for flag in ('R', 'O'){
            if flag in flags{
                status_flags += flag;
                flags.remove(flag);
        } } for flag in ('D', 'F', 'A'){
            if flag in flags{
                xstatus_flags += flag;
                flags.remove(flag);
        } } xstatus_flags += ''.join(sorted(flags));
        try{
            this.replace_header('Status', status_flags);
        } except KeyError{
            this.add_header('Status', status_flags);
        } try{
            this.replace_header('X-Status', xstatus_flags);
        } except KeyError{
            this.add_header('X-Status', xstatus_flags);

    }
    } function add_flag( flag){
        """Set the given flag(s) without changing others.""";
        this.set_flags(''.join(set(this.get_flags()) | set(flag)));

    }
    function remove_flag( flag){
        """Unset the given string flag(s) without changing others.""";
        if 'Status' in this or 'X-Status' in this{
            this.set_flags(''.join(set(this.get_flags()) - set(flag)));

    }
    } function _explain_to( message){
        """Copy mbox- or MMDF-specific state to message insofar as possible.""";
        if isinstance(message, MaildirMessage){
            flags = set(this.get_flags());
            if 'O' in flags{
                message.set_subdir('cur');
            } if 'F' in flags{
                message.add_flag('F');
            } if 'A' in flags{
                message.add_flag('R');
            } if 'R' in flags{
                message.add_flag('S');
            } if 'D' in flags{
                message.add_flag('T');
            } del message['status'];
            del message['x-status'];
            maybe_date = ' '.join(this.get_from().split()[-5:]);
            try{
                message.set_date(calendar.timegm(time.strptime(maybe_date,
                                                      '%a %b %d %H:%M:%S %Y')));
            } except (ValueError, OverflowError){
                pass;
        } } elif isinstance(message, _mboxMMDFMessage){
            message.set_flags(this.get_flags());
            message.set_from(this.get_from());
        } elif isinstance(message, MHMessage){
            flags = set(this.get_flags());
            if 'R' not in flags{
                message.add_sequence('unseen');
            } if 'A' in flags{
                message.add_sequence('replied');
            } if 'F' in flags{
                message.add_sequence('flagged');
            } del message['status'];
            del message['x-status'];
        } elif isinstance(message, BabylMessage){
            flags = set(this.get_flags());
            if 'R' not in flags{
                message.add_label('unseen');
            } if 'D' in flags{
                message.add_label('deleted');
            } if 'A' in flags{
                message.add_label('answered');
            } del message['status'];
            del message['x-status'];
        } elif isinstance(message, Message){
            pass;
        } else{
            raise TypeError('Cannot convert to specified type: %s' %
                            type(message));


}
} } class mboxMessage(_mboxMMDFMessage){
    """Message with mbox-specific properties.""";


}
class MHMessage(Message){
    """Message with MH-specific properties.""";

    function __init__( message=nil){
        """Initialize an MHMessage instance.""";
        this._sequences = [];
        Message.__init__(this, message);

    }
    function get_sequences(){
        """Return a list of sequences that include the message.""";
        return this._sequences[:];

    }
    function set_sequences( sequences){
        """Set the list of sequences that include the message.""";
        this._sequences = list(sequences);

    }
    function add_sequence( sequence){
        """Add sequence to list of sequences including the message.""";
        if isinstance(sequence, str){
            if not sequence in this._sequences{
                this._sequences.append(sequence);
        } } else{
            raise TypeError('sequence must be a string: %s' % type(sequence));

    }
    } function remove_sequence( sequence){
        """Remove sequence from the list of sequences including the message.""";
        try{
            this._sequences.remove(sequence);
        } except ValueError{
            pass;

    }
    } function _explain_to( message){
        """Copy MH-specific state to message insofar as possible.""";
        if isinstance(message, MaildirMessage){
            sequences = set(this.get_sequences());
            if 'unseen' in sequences{
                message.set_subdir('cur');
            } else{
                message.set_subdir('cur');
                message.add_flag('S');
            } if 'flagged' in sequences{
                message.add_flag('F');
            } if 'replied' in sequences{
                message.add_flag('R');
        } } elif isinstance(message, _mboxMMDFMessage){
            sequences = set(this.get_sequences());
            if 'unseen' not in sequences{
                message.add_flag('RO');
            } else{
                message.add_flag('O');
            } if 'flagged' in sequences{
                message.add_flag('F');
            } if 'replied' in sequences{
                message.add_flag('A');
        } } elif isinstance(message, MHMessage){
            for sequence in this.get_sequences(){
                message.add_sequence(sequence);
        } } elif isinstance(message, BabylMessage){
            sequences = set(this.get_sequences());
            if 'unseen' in sequences{
                message.add_label('unseen');
            } if 'replied' in sequences{
                message.add_label('answered');
        } } elif isinstance(message, Message){
            pass;
        } else{
            raise TypeError('Cannot convert to specified type: %s' %
                            type(message));


}
} } class BabylMessage(Message){
    """Message with Babyl-specific properties.""";

    function __init__( message=nil){
        """Initialize a BabylMessage instance.""";
        this._labels = [];
        this._visible = Message();
        Message.__init__(this, message);

    }
    function get_labels(){
        """Return a list of labels on the message.""";
        return this._labels[:];

    }
    function set_labels( labels){
        """Set the list of labels on the message.""";
        this._labels = list(labels);

    }
    function add_label( label){
        """Add label to list of labels on the message.""";
        if isinstance(label, str){
            if label not in this._labels{
                this._labels.append(label);
        } } else{
            raise TypeError('label must be a string: %s' % type(label));

    }
    } function remove_label( label){
        """Remove label from the list of labels on the message.""";
        try{
            this._labels.remove(label);
        } except ValueError{
            pass;

    }
    } function get_visible(){
        """Return a Message representation of visible headers.""";
        return Message(this._visible);

    }
    function set_visible( visible){
        """Set the Message representation of visible headers.""";
        this._visible = Message(visible);

    }
    function update_visible(){
        """Update and/or sensibly generate a set of visible headers.""";
        for header in this._visible.keys(){
            if header in this{
                this._visible.replace_header(header, this[header]);
            } else{
                del this._visible[header];
        } } for header in ('Date', 'From', 'Reply-To', 'To', 'CC', 'Subject'){
            if header in this and header not in this._visible{
                this._visible[header] = this[header];

    }
    } } function _explain_to( message){
        """Copy Babyl-specific state to message insofar as possible.""";
        if isinstance(message, MaildirMessage){
            labels = set(this.get_labels());
            if 'unseen' in labels{
                message.set_subdir('cur');
            } else{
                message.set_subdir('cur');
                message.add_flag('S');
            } if 'forwarded' in labels or 'resent' in labels{
                message.add_flag('P');
            } if 'answered' in labels{
                message.add_flag('R');
            } if 'deleted' in labels{
                message.add_flag('T');
        } } elif isinstance(message, _mboxMMDFMessage){
            labels = set(this.get_labels());
            if 'unseen' not in labels{
                message.add_flag('RO');
            } else{
                message.add_flag('O');
            } if 'deleted' in labels{
                message.add_flag('D');
            } if 'answered' in labels{
                message.add_flag('A');
        } } elif isinstance(message, MHMessage){
            labels = set(this.get_labels());
            if 'unseen' in labels{
                message.add_sequence('unseen');
            } if 'answered' in labels{
                message.add_sequence('replied');
        } } elif isinstance(message, BabylMessage){
            message.set_visible(this.get_visible());
            for label in this.get_labels(){
                message.add_label(label);
        } } elif isinstance(message, Message){
            pass;
        } else{
            raise TypeError('Cannot convert to specified type: %s' %
                            type(message));


}
} } class MMDFMessage(_mboxMMDFMessage){
    """Message with MMDF-specific properties.""";


}
class _ProxyFile{
    """A read-only wrapper of a file.""";

    function __init__( f, pos=nil){
        """Initialize a _ProxyFile.""";
        this._file = f;
        if pos is nil{
            this._pos = f.tell();
        } else{
            this._pos = pos;

    }
    } function read( size=nil){
        """Read bytes.""";
        return this._read(size, this._file.read);

    }
    function readline( size=nil){
        """Read a line.""";
        return this._read(size, this._file.readline);

    }
    function readlines( sizehint=nil){
        """Read multiple lines.""";
        result = [];
        for line in this{
            result.append(line);
            if sizehint is not nil{
                sizehint -= len(line);
                if sizehint <= 0{
                    break;
        } } } return result;

    }
    function __iter__(){
        """Iterate over lines.""";
        return iter(this.readline, "");

    }
    function tell(){
        """Return the position.""";
        return this._pos;

    }
    function seek( offset, whence=0){
        """Change position.""";
        if whence == 1{
            this._file.seek(this._pos);
        } this._file.seek(offset, whence);
        this._pos = this._file.tell();

    }
    function close(){
        """Close the file.""";
        if hasattr(this, '_file'){
            if hasattr(this._file, 'close'){
                this._file.close();
            } del this._file;

    }
    } function _read( size, read_method){
        """Read size bytes using read_method.""";
        if size is nil{
            size = -1;
        } this._file.seek(this._pos);
        result = read_method(size);
        this._pos = this._file.tell();
        return result;


}
} class _PartialFile(_ProxyFile){
    """A read-only wrapper of part of a file.""";

    function __init__( f, start=nil, stop=nil){
        """Initialize a _PartialFile.""";
        _ProxyFile.__init__(this, f, start);
        this._start = start;
        this._stop = stop;

    }
    function tell(){
        """Return the position with respect to start.""";
        return _ProxyFile.tell(this) - this._start;

    }
    function seek( offset, whence=0){
        """Change position, possibly with respect to start or stop.""";
        if whence == 0{
            this._pos = this._start;
            whence = 1;
        } elif whence == 2{
            this._pos = this._stop;
            whence = 1;
        } _ProxyFile.seek(this, offset, whence);

    }
    function _read( size, read_method){
        """Read size bytes using read_method, honoring start and stop.""";
        remaining = this._stop - this._pos;
        if remaining <= 0{
            return '';
        } if size is nil or size < 0 or size > remaining{
            size = remaining;
        } return _ProxyFile._read(this, size, read_method);

    }
    function close(){
        # do *not* close the underlying file object for partial files,
        # since it's global to the mailbox object
        if hasattr(this, '_file'){
            del this._file;


}
} } function _lock_file(f, dotlock=true){
    """Lock file f using lockf and dot locking.""";
    dotlock_done = false;
    try{
        if fcntl{
            try{
                fcntl.lockf(f, fcntl.LOCK_EX | fcntl.LOCK_NB);
            } except IOError, e{
                if e.errno in (errno.EAGAIN, errno.EACCES, errno.EROFS){
                    raise ExternalClashError('lockf: lock unavailable: %s' %
                                             f.name);
                } else{
                    raise;
        } } } if dotlock{
            try{
                pre_lock = _create_temporary(f.name + '.lock');
                pre_lock.close();
            } except IOError, e{
                if e.errno in (errno.EACCES, errno.EROFS){
                    return;  # Without write access, just skip dotlocking.
                } else{
                    raise;
            } } try{
                if hasattr(os, 'link'){
                    os.link(pre_lock.name, f.name + '.lock');
                    dotlock_done = true;
                    os.unlink(pre_lock.name);
                } else{
                    os.rename(pre_lock.name, f.name + '.lock');
                    dotlock_done = true;
            } } except OSError, e{
                if e.errno == errno.EEXIST or \
                  (os.name == 'os2' and e.errno == errno.EACCES){
                    os.remove(pre_lock.name);
                    raise ExternalClashError('dot lock unavailable: %s' %
                                             f.name);
                } else{
                    raise;
    } } } } except Exception{
        if fcntl{
            fcntl.lockf(f, fcntl.LOCK_UN);
        } if dotlock_done{
            os.remove(f.name + '.lock');
        } raise;

}
} function _unlock_file(f){
    """Unlock file f using lockf and dot locking.""";
    if fcntl{
        fcntl.lockf(f, fcntl.LOCK_UN);
    } if os.path.exists(f.name + '.lock'){
        os.remove(f.name + '.lock');

}
} function _create_carefully(path){
    """Create a file if it doesn't exist and open for reading and writing.""";
    fd = os.open(path, os.O_CREAT | os.O_EXCL | os.O_RDWR, 0666);
    try{
        return open(path, 'rb+');
    } finally{
        os.close(fd);

}
} function _create_temporary(path){
    """Create a temp file based on path and open for reading and writing.""";
    return _create_carefully('%s.%s.%s.%s' % (path, int(time.time()),
                                              socket.gethostname(),
                                              os.getpid()));

}
function _sync_flush(f){
    """Ensure changes to file f are physically on disk.""";
    f.flush();
    if hasattr(os, 'fsync'){
        os.fsync(f.fileno());

}
} function _sync_close(f){
    """Close file f, ensuring all changes are physically on disk.""";
    _sync_flush(f);
    f.close();

## Start: classes from the original module (for backward compatibility).

# Note that the Maildir class, whose name is unchanged, itself offers a next()
# method for backward compatibility.

}
class _Mailbox{

    function __init__( fp, factory=rfc822.Message){
        this.fp = fp;
        this.seekp = 0;
        this.factory = factory;

    }
    function __iter__(){
        return iter(this.next, nil);

    }
    function next(){
        while 1{
            this.fp.seek(this.seekp);
            try{
                this._search_start();
            } except EOFError{
                this.seekp = this.fp.tell();
                return nil;
            } start = this.fp.tell();
            this._search_end();
            this.seekp = stop = this.fp.tell();
            if start != stop{
                break;
        } } return this.factory(_PartialFile(this.fp, start, stop));

# Recommended to use PortableUnixMailbox instead!
}
} class UnixMailbox(_Mailbox){

    function _search_start(){
        while 1{
            pos = this.fp.tell();
            line = this.fp.readline();
            if not line{
                raise EOFError;
            } if line[:5] == 'From ' and this._isrealfromline(line){
                this.fp.seek(pos);
                return;

    }
    } } function _search_end(){
        this.fp.readline();      # Throw away header line
        while 1{
            pos = this.fp.tell();
            line = this.fp.readline();
            if not line{
                return;
            } if line[:5] == 'From ' and this._isrealfromline(line){
                this.fp.seek(pos);
                return;

    # An overridable mechanism to test for From-line-ness.  You can either
    # specify a different regular expression or define a whole new
    # _isrealfromline() method.  Note that this only gets called for lines
    # starting with the 5 characters "From ".
    #
    # BAW: According to
    #http://home.netscape.com/eng/mozilla/2.0/relnotes/demo/content-length.html
    # the only portable, reliable way to find message delimiters in a BSD (i.e
    # Unix mailbox) style folder is to search for "\n\nFrom .*\n", or at the
    # beginning of the file, "^From .*\n".  While _fromlinepattern below seems
    # like a good idea, in practice, there are too many variations for more
    # strict parsing of the line to be completely accurate.
    #
    # _strict_isrealfromline() is the old version which tries to do stricter
    # parsing of the From_ line.  _portable_isrealfromline() simply returns
    # true, since it's never called if the line doesn't already start with
    # "From ".
    #
    # This algorithm, and the way it interacts with _search_start() and
    # _search_end() may not be completely correct, because it doesn't check
    # that the two characters preceding "From " are \n\n or the beginning of
    # the file.  Fixing this would require a more extensive rewrite than is
    # necessary.  For convenience, we've added a PortableUnixMailbox class
    # which does no checking of the format of the 'From' line.

    }
    } } _fromlinepattern = (r"From \s*[^\s]+\s+\w\w\w\s+\w\w\w\s+\d?\d\s+"
                        r"\d?\d:\d\d(:\d\d)?(\s+[^\s]+)?\s+\d\d\d\d\s*"
                        r"[^\s]*\s*"
                        "$");
    _regexp = nil;

    function _strict_isrealfromline( line){
        if not this._regexp{
            import re;
            this._regexp = re.compile(this._fromlinepattern);
        } return this._regexp.match(line);

    }
    function _portable_isrealfromline( line){
        return true;

    }
    _isrealfromline = _strict_isrealfromline;


}
class PortableUnixMailbox(UnixMailbox){
    _isrealfromline = UnixMailbox._portable_isrealfromline;


}
class MmdfMailbox(_Mailbox){

    function _search_start(){
        while 1{
            line = this.fp.readline();
            if not line{
                raise EOFError;
            } if line[:5] == '\001\001\001\001\n'{
                return;

    }
    } } function _search_end(){
        while 1{
            pos = this.fp.tell();
            line = this.fp.readline();
            if not line{
                return;
            } if line == '\001\001\001\001\n'{
                this.fp.seek(pos);
                return;


}
} } } class MHMailbox{

    function __init__( dirname, factory=rfc822.Message){
        import re;
        pat = re.compile('^[1-9][0-9]*$');
        this.dirname = dirname;
        # the three following lines could be combined into:
        # list = map(long, filter(pat.match, os.listdir(self.dirname)))
        list = os.listdir(this.dirname);
        list = filter(pat.match, list);
        list = map(long, list);
        list.sort();
        # This only works in Python 1.6 or later;
        # before that str() added 'L':
        this.boxes = map(str, list);
        this.boxes.reverse();
        this.factory = factory;

    }
    function __iter__(){
        return iter(this.next, nil);

    }
    function next(){
        if not this.boxes{
            return nil;
        } fn = this.boxes.pop();
        fp = open(os.path.join(this.dirname, fn));
        msg = this.factory(fp);
        try{
            msg._mh_msgno = fn;
        } except (AttributeError, TypeError){
            pass;
        } return msg;


}
} class BabylMailbox(_Mailbox){

    function _search_start(){
        while 1{
            line = this.fp.readline();
            if not line{
                raise EOFError;
            } if line == '*** EOOH ***\n'{
                return;

    }
    } } function _search_end(){
        while 1{
            pos = this.fp.tell();
            line = this.fp.readline();
            if not line{
                return;
            } if line == '\037\014\n' or line == '\037'{
                this.fp.seek(pos);
                return;

## End: classes from the original module (for backward compatibility).


}
} } } class Error(Exception){
    """Raised for module-specific errors.""";

}
class NoSuchMailboxError(Error){
    """The specified mailbox does not exist and won't be created.""";

}
class NotEmptyError(Error){
    """The specified mailbox is not empty and deletion was requested.""";

}
class ExternalClashError(Error){
    """Another process caused an action to fail.""";

}
class FormatError(Error){
    """A file appears to have an invalid format.""";

}
"""An extensible library for opening URLs using a variety of protocols

The simplest way to use this module is to call the urlopen function,
which accepts a string containing a URL or a Request object (described
below).  It opens the URL and returns the results as file-like
object; the returned object has some extra methods described below.

The OpenerDirector manages a collection of Handler objects that do
all the actual work.  Each Handler implements a particular protocol or
option.  The OpenerDirector is a composite object that invokes the
Handlers needed to open the requested URL.  For example, the
HTTPHandler performs HTTP GET and POST requests and deals with
non-error returns.  The HTTPRedirectHandler automatically deals with
HTTP 301, 302, 303 and 307 redirect errors, and the HTTPDigestAuthHandler
deals with digest authentication.

urlopen(url, data=None) -- Basic usage is the same as original
urllib.  pass the url and optionally data to post to an HTTP URL, and
get a file-like object back.  One difference is that you can also pass
a Request instance instead of URL.  Raises a URLError (subclass of
IOError); for HTTP errors, raises an HTTPError, which can also be
treated as a valid response.

build_opener -- Function that creates a new OpenerDirector instance.
Will install the default handlers.  Accepts one or more Handlers as
arguments, either instances or Handler classes that it will
instantiate.  If one of the argument is a subclass of the default
handler, the argument will be installed instead of the default.

install_opener -- Installs a new opener as the default opener.

objects of interest:

OpenerDirector -- Sets up the User Agent as the Python-urllib client and manages
the Handler classes, while dealing with requests and responses.

Request -- An object that encapsulates the state of a request.  The
state can be as simple as the URL.  It can also include extra HTTP
headers, e.g. a User-Agent.

BaseHandler --

exceptions:
URLError -- A subclass of IOError, individual protocols have their own
specific subclass.

HTTPError -- Also a valid HTTP response, so you can treat an HTTP error
as an exceptional event or valid response.

internals:
BaseHandler and parent
_call_chain conventions

Example usage:

import urllib2

# set up authentication info
authinfo = urllib2.HTTPBasicAuthHandler()
authinfo.add_password(realm='PDQ Application',
                      uri='https://mahler:8092/site-updates.py',
                      user='klem',
                      passwd='geheim$parole')

proxy_support = urllib2.ProxyHandler({"http" : "http://ahad-haam:3128"})

# build a new opener that adds authentication and caching FTP handlers
opener = urllib2.build_opener(proxy_support, authinfo, urllib2.CacheFTPHandler)

# install it
urllib2.install_opener(opener)

f = urllib2.urlopen('http://www.python.org/')


""";

# XXX issues:
# If an authentication error handler that tries to perform
# authentication for some reason but fails, how should the error be
# signalled?  The client needs to know the HTTP error code.  But if
# the handler knows that the problem was, e.g., that it didn't know
# that hash algo that requested in the challenge, it would be good to
# pass that information along to the client, too.
# ftp errors aren't handled cleanly
# check digest against correct (i.e. non-apache) implementation

# Possible extensions:
# complex proxies  XXX not sure what exactly was meant by this
# abstract factory for opener

import base64;
import hashlib;
import httplib;
import mimetools;
import os;
import posixpath;
import random;
import re;
import socket;
import sys;
import time;
import urlparse;
import bisect;
import warnings;

try{
    from cStringIO import StringIO;
} except ImportError{
    from StringIO import StringIO;

# check for SSL
}
try{
    import ssl;
} except ImportError{
    _have_ssl = false;
} else{
    _have_ssl = true;

}
from urllib import (unwrap, unquote, splittype, splithost, quote,
     addinfourl, splitport, splittag, toBytes,
     splitattr, ftpwrapper, splituser, splitpasswd, splitvalue);

# support for FileHandler, proxies via environment variables
from urllib import localhost, url2pathname, getproxies, proxy_bypass;

# used in User-Agent header sent
__version__ = sys.version[:3];

_opener = nil;
function urlopen(url, data=nil, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
            cafile=nil, capath=nil, cadefault=false, context=nil){
    global _opener;
    if cafile or capath or cadefault{
        if context is not nil{
            raise ValueError(
                "You can't pass both context and any of cafile, capath, and "
                "cadefault"
            );
        } if not _have_ssl{
            raise ValueError('SSL support not available');
        } context = ssl.create_default_context(purpose=ssl.Purpose.SERVER_AUTH,
                                             cafile=cafile,
                                             capath=capath);
        https_handler = HTTPSHandler(context=context);
        opener = build_opener(https_handler);
    } elif context{
        https_handler = HTTPSHandler(context=context);
        opener = build_opener(https_handler);
    } elif _opener is nil{
        _opener = opener = build_opener();
    } else{
        opener = _opener;
    } return opener.open(url, data, timeout);

}
function install_opener(opener){
    global _opener;
    _opener = opener;

# do these error classes make sense?
# make sure all of the IOError stuff is overridden.  we just want to be
# subtypes.

}
class URLError(IOError){
    # URLError is a sub-type of IOError, but it doesn't share any of
    # the implementation.  need to override __init__ and __str__.
    # It sets self.args for compatibility with other EnvironmentError
    # subclasses, but args doesn't have the typical format with errno in
    # slot 0 and strerror in slot 1.  This may be better than nothing.
    function __init__( reason){
        this.args = reason,;
        this.reason = reason;

    }
    function __str__(){
        return '<urlopen error %s>' % this.reason;

}
} class HTTPError(URLError, addinfourl){
    """Raised when HTTP error occurs, but also acts like non-error return""";
    __super_init = addinfourl.__init__;

    function __init__( url, code, msg, hdrs, fp){
        this.code = code;
        this.msg = msg;
        this.hdrs = hdrs;
        this.fp = fp;
        this.filename = url;
        # The addinfourl classes depend on fp being a valid file
        # object.  In some cases, the HTTPError may not have a valid
        # file object.  If this happens, the simplest workaround is to
        # not initialize the base classes.
        if fp is not nil{
            this.__super_init(fp, hdrs, url, code);

    }
    } function __str__(){
        return 'HTTP Error %s: %s' % (this.code, this.msg);

    # since URLError specifies a .reason attribute, HTTPError should also
    #  provide this attribute. See issue13211 fo discussion.
    }
    @property;
    function reason(){
        return this.msg;

    }
    function info(){
        return this.hdrs;

# copied from cookielib.py
}
} _cut_port_re = re.compile(r":\d+$");
function request_host(request){
    """Return request-host, as defined by RFC 2965.

    Variation from RFC: returned value is lowercased, for convenient
    comparison.

    """;
    url = request.get_full_url();
    host = urlparse.urlparse(url)[1];
    if host == ""{
        host = request.get_header("Host", "");

    # remove port, if present
    }
    host = _cut_port_re.sub("", host, 1);
    return host.lower();

}
class Request{

    function __init__( url, data=nil, headers={},
                 origin_req_host=nil, unverifiable=false){
        # unwrap('<URL:type://host/path>') --> 'type://host/path'
        this.__original = unwrap(url);
        this.__original, this.__fragment = splittag(this.__original);
        this.type = nil;
        # self.__r_type is what's left after doing the splittype
        this.host = nil;
        this.port = nil;
        this._tunnel_host = nil;
        this.data = data;
        this.headers = {};
        for key, value in headers.items(){
            this.add_header(key, value);
        } this.unredirected_hdrs = {};
        if origin_req_host is nil{
            origin_req_host = request_host(this);
        } this.origin_req_host = origin_req_host;
        this.unverifiable = unverifiable;

    }
    function __getattr__( attr){
        # XXX this is a fallback mechanism to guard against these
        # methods getting called in a non-standard order.  this may be
        # too complicated and/or unnecessary.
        # XXX should the __r_XXX attributes be public?
        if attr in ('_Request__r_type', '_Request__r_host'){
            getattr(this, 'get_' + attr[12:])();
            return this.__dict__[attr];
        } raise AttributeError, attr;

    }
    function get_method(){
        if this.has_data(){
            return "POST";
        } else{
            return "GET";

    # XXX these helper methods are lame

    }
    } function add_data( data){
        this.data = data;

    }
    function has_data(){
        return this.data is not nil;

    }
    function get_data(){
        return this.data;

    }
    function get_full_url(){
        if this.__fragment{
            return '%s#%s' % (this.__original, this.__fragment);
        } else{
            return this.__original;

    }
    } function get_type(){
        if this.type is nil{
            this.type, this.__r_type = splittype(this.__original);
            if this.type is nil{
                raise ValueError, "unknown url type: %s" % this.__original;
        } } return this.type;

    }
    function get_host(){
        if this.host is nil{
            this.host, this.__r_host = splithost(this.__r_type);
            if this.host{
                this.host = unquote(this.host);
        } } return this.host;

    }
    function get_selector(){
        return this.__r_host;

    }
    function set_proxy( host, type){
        if this.type == 'https' and not this._tunnel_host{
            this._tunnel_host = this.host;
        } else{
            this.type = type;
            this.__r_host = this.__original;

        }
        this.host = host;

    }
    function has_proxy(){
        return this.__r_host == this.__original;

    }
    function get_origin_req_host(){
        return this.origin_req_host;

    }
    function is_unverifiable(){
        return this.unverifiable;

    }
    function add_header( key, val){
        # useful for something like authentication
        this.headers[key.capitalize()] = val;

    }
    function add_unredirected_header( key, val){
        # will not be added to a redirected request
        this.unredirected_hdrs[key.capitalize()] = val;

    }
    function has_header( header_name){
        return (header_name in this.headers or
                header_name in this.unredirected_hdrs);

    }
    function get_header( header_name, default=nil){
        return this.headers.get(
            header_name,
            this.unredirected_hdrs.get(header_name, default));

    }
    function header_items(){
        hdrs = this.unredirected_hdrs.copy();
        hdrs.update(this.headers);
        return hdrs.items();

}
} class OpenerDirector{
    function __init__(){
        client_version = "Python-urllib/%s" % __version__;
        this.addheaders = [('User-agent', client_version)];
        # self.handlers is retained only for backward compatibility
        this.handlers = [];
        # manage the individual handlers
        this.handle_open = {};
        this.handle_error = {};
        this.process_response = {};
        this.process_request = {};

    }
    function add_handler( handler){
        if not hasattr(handler, "add_parent"){
            raise TypeError("expected BaseHandler instance, got %r" %
                            type(handler));

        }
        added = false;
        for meth in dir(handler){
            if meth in ["redirect_request", "do_open", "proxy_open"]{
                # oops, coincidental match
                continue;

            }
            i = meth.find("_");
            protocol = meth[:i];
            condition = meth[i+1:];

            if condition.startswith("error"){
                j = condition.find("_") + i + 1;
                kind = meth[j+1:];
                try{
                    kind = int(kind);
                } except ValueError{
                    pass;
                } lookup = this.handle_error.get(protocol, {});
                this.handle_error[protocol] = lookup;
            } elif condition == "open"{
                kind = protocol;
                lookup = this.handle_open;
            } elif condition == "response"{
                kind = protocol;
                lookup = this.process_response;
            } elif condition == "request"{
                kind = protocol;
                lookup = this.process_request;
            } else{
                continue;

            }
            handlers = lookup.setdefault(kind, []);
            if handlers{
                bisect.insort(handlers, handler);
            } else{
                handlers.append(handler);
            } added = true;

        }
        if added{
            bisect.insort(this.handlers, handler);
            handler.add_parent(this);

    }
    } function close(){
        # Only exists for backwards compatibility.
        pass;

    }
    function _call_chain( chain, kind, meth_name, *args){
        # Handlers raise an exception if no one else should try to handle
        # the request, or return None if they can't but another handler
        # could.  Otherwise, they return the response.
        handlers = chain.get(kind, ());
        for handler in handlers{
            func = getattr(handler, meth_name);

            result = func(*args);
            if result is not nil{
                return result;

    }
    } } function open( fullurl, data=nil, timeout=socket._GLOBAL_DEFAULT_TIMEOUT){
        # accept a URL or a Request object
        if isinstance(fullurl, basestring){
            req = Request(fullurl, data);
        } else{
            req = fullurl;
            if data is not nil{
                req.add_data(data);

        }
        } req.timeout = timeout;
        protocol = req.get_type();

        # pre-process request
        meth_name = protocol+"_request";
        for processor in this.process_request.get(protocol, []){
            meth = getattr(processor, meth_name);
            req = meth(req);

        }
        response = this._open(req, data);

        # post-process response
        meth_name = protocol+"_response";
        for processor in this.process_response.get(protocol, []){
            meth = getattr(processor, meth_name);
            response = meth(req, response);

        }
        return response;

    }
    function _open( req, data=nil){
        result = this._call_chain(this.handle_open, 'default',
                                  'default_open', req);
        if result{
            return result;

        }
        protocol = req.get_type();
        result = this._call_chain(this.handle_open, protocol, protocol +
                                  '_open', req);
        if result{
            return result;

        }
        return this._call_chain(this.handle_open, 'unknown',
                                'unknown_open', req);

    }
    function error( proto, *args){
        if proto in ('http', 'https'){
            # XXX http[s] protocols are special-cased
            dict = this.handle_error['http']; # https is not different than http
            proto = args[2];  # YUCK!
            meth_name = 'http_error_%s' % proto;
            http_err = 1;
            orig_args = args;
        } else{
            dict = this.handle_error;
            meth_name = proto + '_error';
            http_err = 0;
        } args = (dict, proto, meth_name) + args;
        result = this._call_chain(*args);
        if result{
            return result;

        }
        if http_err{
            args = (dict, 'default', 'http_error_default') + orig_args;
            return this._call_chain(*args);

# XXX probably also want an abstract factory that knows when it makes
# sense to skip a superclass in favor of a subclass and when it might
# make sense to include both

}
} } function build_opener(*handlers){
    """Create an opener object from a list of handlers.

    The opener will use several default handlers, including support
    for HTTP, FTP and when applicable, HTTPS.

    If any of the handlers passed as arguments are subclasses of the
    default handlers, the default handlers will not be used.
    """;
    import types;
    function isclass(obj){
        return isinstance(obj, (types.ClassType, type));

    }
    opener = OpenerDirector();
    default_classes = [ProxyHandler, UnknownHandler, HTTPHandler,
                       HTTPDefaultErrorHandler, HTTPRedirectHandler,
                       FTPHandler, FileHandler, HTTPErrorProcessor];
    if hasattr(httplib, 'HTTPS'){
        default_classes.append(HTTPSHandler);
    } skip = set();
    for klass in default_classes{
        for check in handlers{
            if isclass(check){
                if issubclass(check, klass){
                    skip.add(klass);
            } } elif isinstance(check, klass){
                skip.add(klass);
    } } } for klass in skip{
        default_classes.remove(klass);

    }
    for klass in default_classes{
        opener.add_handler(klass());

    }
    for h in handlers{
        if isclass(h){
            h = h();
        } opener.add_handler(h);
    } return opener;

}
class BaseHandler{
    handler_order = 500;

    function add_parent( parent){
        this.parent = parent;

    }
    function close(){
        # Only exists for backwards compatibility
        pass;

    }
    function __lt__( other){
        if not hasattr(other, "handler_order"){
            # Try to preserve the old behavior of having custom classes
            # inserted after default ones (works only for custom user
            # classes which are not aware of handler_order).
            return true;
        } return this.handler_order < other.handler_order;


}
} class HTTPErrorProcessor(BaseHandler){
    """Process HTTP error responses.""";
    handler_order = 1000;  # after all other processing

    function http_response( request, response){
        code, msg, hdrs = response.code, response.msg, response.info();

        # According to RFC 2616, "2xx" code indicates that the client's
        # request was successfully received, understood, and accepted.
        if not (200 <= code < 300){
            response = this.parent.error(
                'http', request, response, code, msg, hdrs);

        }
        return response;

    }
    https_response = http_response;

}
class HTTPDefaultErrorHandler(BaseHandler){
    function http_error_default( req, fp, code, msg, hdrs){
        raise HTTPError(req.get_full_url(), code, msg, hdrs, fp);

}
} class HTTPRedirectHandler(BaseHandler){
    # maximum number of redirections to any single URL
    # this is needed because of the state that cookies introduce
    max_repeats = 4;
    # maximum total number of redirections (regardless of URL) before
    # assuming we're in a loop
    max_redirections = 10;

    function redirect_request( req, fp, code, msg, headers, newurl){
        """Return a Request or None in response to a redirect.

        This is called by the http_error_30x methods when a
        redirection response is received.  If a redirection should
        take place, return a new Request to allow http_error_30x to
        perform the redirect.  Otherwise, raise HTTPError if no-one
        else should try to handle this url.  Return None if you can't
        but another Handler might.
        """;
        m = req.get_method();
        if (code in (301, 302, 303, 307) and m in ("GET", "HEAD")
            or code in (301, 302, 303) and m == "POST"){
            # Strictly (according to RFC 2616), 301 or 302 in response
            # to a POST MUST NOT cause a redirection without confirmation
            # from the user (of urllib2, in this case).  In practice,
            # essentially all clients do redirect in this case, so we
            # do the same.
            # be conciliant with URIs containing a space
            newurl = newurl.replace(' ', '%20');
            newheaders = dict((k,v) for k,v in req.headers.items()
                              if k.lower() not in ("content-length", "content-type")
                             );
            return Request(newurl,
                           headers=newheaders,
                           origin_req_host=req.get_origin_req_host(),
                           unverifiable=true);
        } else{
            raise HTTPError(req.get_full_url(), code, msg, headers, fp);

    # Implementation note: To avoid the server sending us into an
    # infinite loop, the request object needs to track what URLs we
    # have already seen.  Do this by adding a handler-specific
    # attribute to the Request object.
    }
    } function http_error_302( req, fp, code, msg, headers){
        # Some servers (incorrectly) return multiple Location headers
        # (so probably same goes for URI).  Use first header.
        if 'location' in headers{
            newurl = headers.getheaders('location')[0];
        } elif 'uri' in headers{
            newurl = headers.getheaders('uri')[0];
        } else{
            return;

        # fix a possible malformed URL
        }
        urlparts = urlparse.urlparse(newurl);
        if not urlparts.path and urlparts.netloc{
            urlparts = list(urlparts);
            urlparts[2] = "/";
        } newurl = urlparse.urlunparse(urlparts);

        newurl = urlparse.urljoin(req.get_full_url(), newurl);

        # For security reasons we do not allow redirects to protocols
        # other than HTTP, HTTPS or FTP.
        newurl_lower = newurl.lower();
        if not (newurl_lower.startswith('http://') or
                newurl_lower.startswith('https://') or
                newurl_lower.startswith('ftp://')){
            raise HTTPError(newurl, code,
                            msg + " - Redirection to url '%s' is not allowed" %
                            newurl,
                            headers, fp);

        # XXX Probably want to forget about the state of the current
        # request, although that might interact poorly with other
        # handlers that also use handler-specific request attributes
        }
        new = this.redirect_request(req, fp, code, msg, headers, newurl);
        if new is nil{
            return;

        # loop detection
        # .redirect_dict has a key url if url was previously visited.
        }
        if hasattr(req, 'redirect_dict'){
            visited = new.redirect_dict = req.redirect_dict;
            if (visited.get(newurl, 0) >= this.max_repeats or
                len(visited) >= this.max_redirections){
                raise HTTPError(req.get_full_url(), code,
                                this.inf_msg + msg, headers, fp);
        } } else{
            visited = new.redirect_dict = req.redirect_dict = {};
        } visited[newurl] = visited.get(newurl, 0) + 1;

        # Don't close the fp until we are sure that we won't use it
        # with HTTPError.
        fp.read();
        fp.close();

        return this.parent.open(new, timeout=req.timeout);

    }
    http_error_301 = http_error_303 = http_error_307 = http_error_302;

    inf_msg = "The HTTP server returned a redirect error that would " \
              "lead to an infinite loop.\n" \
              "The last 30x error message was:\n";


}
function _parse_proxy(proxy){
    """Return (scheme, user, password, host/port) given a URL or an authority.

    If a URL is supplied, it must have an authority (host:port) component.
    According to RFC 3986, having an authority component means the URL must
    have two slashes after the scheme:

    >>> _parse_proxy('file:/ftp.example.com/')
    Traceback (most recent call last):
    ValueError: proxy URL with no authority: 'file:/ftp.example.com/'

    The first three items of the returned tuple may be None.

    Examples of authority parsing:

    >>> _parse_proxy('proxy.example.com')
    (None, None, None, 'proxy.example.com')
    >>> _parse_proxy('proxy.example.com:3128')
    (None, None, None, 'proxy.example.com:3128')

    The authority component may optionally include userinfo (assumed to be
    username:password):

    >>> _parse_proxy('joe:password@proxy.example.com')
    (None, 'joe', 'password', 'proxy.example.com')
    >>> _parse_proxy('joe:password@proxy.example.com:3128')
    (None, 'joe', 'password', 'proxy.example.com:3128')

    Same examples, but with URLs instead:

    >>> _parse_proxy('http://proxy.example.com/')
    ('http', None, None, 'proxy.example.com')
    >>> _parse_proxy('http://proxy.example.com:3128/')
    ('http', None, None, 'proxy.example.com:3128')
    >>> _parse_proxy('http://joe:password@proxy.example.com/')
    ('http', 'joe', 'password', 'proxy.example.com')
    >>> _parse_proxy('http://joe:password@proxy.example.com:3128')
    ('http', 'joe', 'password', 'proxy.example.com:3128')

    Everything after the authority is ignored:

    >>> _parse_proxy('ftp://joe:password@proxy.example.com/rubbish:3128')
    ('ftp', 'joe', 'password', 'proxy.example.com')

    Test for no trailing '/' case:

    >>> _parse_proxy('http://joe:password@proxy.example.com')
    ('http', 'joe', 'password', 'proxy.example.com')

    """;
    scheme, r_scheme = splittype(proxy);
    if not r_scheme.startswith("/"){
        # authority
        scheme = nil;
        authority = proxy;
    } else{
        # URL
        if not r_scheme.startswith("//"){
            raise ValueError("proxy URL with no authority: %r" % proxy);
        # We have an authority, so for RFC 3986-compliant URLs (by ss 3.
        # and 3.3.), path is empty or starts with '/'
        }
        end = r_scheme.find("/", 2);
        if end == -1{
            end = nil;
        } authority = r_scheme[2:end];
    } userinfo, hostport = splituser(authority);
    if userinfo is not nil{
        user, password = splitpasswd(userinfo);
    } else{
        user = password = nil;
    } return scheme, user, password, hostport;

}
class ProxyHandler(BaseHandler){
    # Proxies must be in front
    handler_order = 100;

    function __init__( proxies=nil){
        if proxies is nil{
            proxies = getproxies();
        } assert hasattr(proxies, 'has_key'), "proxies must be a mapping";
        this.proxies = proxies;
        for type, url in proxies.items(){
            setattr(this, '%s_open' % type,
                    lambda r, proxy=url, type=type, meth=this.proxy_open{ \
                    meth(r, proxy, type)});

    }
    } function proxy_open( req, proxy, type){
        orig_type = req.get_type();
        proxy_type, user, password, hostport = _parse_proxy(proxy);

        if proxy_type is nil{
            proxy_type = orig_type;

        }
        if req.host and proxy_bypass(req.host){
            return nil;

        }
        if user and password{
            user_pass = '%s:%s' % (unquote(user), unquote(password));
            creds = base64.b64encode(user_pass).strip();
            req.add_header('Proxy-authorization', 'Basic ' + creds);
        } hostport = unquote(hostport);
        req.set_proxy(hostport, proxy_type);

        if orig_type == proxy_type or orig_type == 'https'{
            # let other handlers take care of it
            return nil;
        } else{
            # need to start over, because the other handlers don't
            # grok the proxy's URL type
            # e.g. if we have a constructor arg proxies like so:
            # {'http': 'ftp://proxy.example.com'}, we may end up turning
            # a request for http://acme.example.com/a into one for
            # ftp://proxy.example.com/a
            return this.parent.open(req, timeout=req.timeout);

}
} } class HTTPPasswordMgr{

    function __init__(){
        this.passwd = {};

    }
    function add_password( realm, uri, user, passwd){
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring){
            uri = [uri];
        } if not realm in this.passwd{
            this.passwd[realm] = {};
        } for default_port in true, false{
            reduced_uri = tuple(
                [this.reduce_uri(u, default_port) for u in uri]);
            this.passwd[realm][reduced_uri] = (user, passwd);

    }
    } function find_user_password( realm, authuri){
        domains = this.passwd.get(realm, {});
        for default_port in true, false{
            reduced_authuri = this.reduce_uri(authuri, default_port);
            for uris, authinfo in domains.iteritems(){
                for uri in uris{
                    if this.is_suburi(uri, reduced_authuri){
                        return authinfo;
        } } } } return nil, nil;

    }
    function reduce_uri( uri, default_port=true){
        """Accept authority or URI and extract only the authority and path.""";
        # note HTTP URLs do not have a userinfo component
        parts = urlparse.urlsplit(uri);
        if parts[1]{
            # URI
            scheme = parts[0];
            authority = parts[1];
            path = parts[2] or '/';
        } else{
            # host or host:port
            scheme = nil;
            authority = uri;
            path = '/';
        } host, port = splitport(authority);
        if default_port and port is nil and scheme is not nil{
            dport = {"http": 80,
                     "https": 443,
                     }.get(scheme);
            if dport is not nil{
                authority = "%s:%d" % (host, dport);
        } } return authority, path;

    }
    function is_suburi( base, test){
        """Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """;
        if base == test{
            return true;
        } if base[0] != test[0]{
            return false;
        } common = posixpath.commonprefix((base[1], test[1]));
        if len(common) == len(base[1]){
            return true;
        } return false;


}
} class HTTPPasswordMgrWithDefaultRealm(HTTPPasswordMgr){

    function find_user_password( realm, authuri){
        user, password = HTTPPasswordMgr.find_user_password(this, realm,
                                                            authuri);
        if user is not nil{
            return user, password;
        } return HTTPPasswordMgr.find_user_password(this, nil, authuri);


}
} class AbstractBasicAuthHandler{

    # XXX this allows for multiple auth-schemes, but will stupidly pick
    # the last one with a realm specified.

    # allow for double- and single-quoted realm values
    # (single quotes are a violation of the RFC, but appear in the wild)
    rx = re.compile('(?:.*,)*[ \t]*([^ \t]+)[ \t]+'
                    'realm=(["\']?)([^"\']*)\\2', re.I);

    # XXX could pre-emptively send auth info already accepted (RFC 2617,
    # end of section 2, and section 1.2 immediately after "credentials"
    # production).

    function __init__( password_mgr=nil){
        if password_mgr is nil{
            password_mgr = HTTPPasswordMgr();
        } this.passwd = password_mgr;
        this.add_password = this.passwd.add_password;


    }
    function http_error_auth_reqed( authreq, host, req, headers){
        # host may be an authority (without userinfo) or a URL with an
        # authority
        # XXX could be multiple headers
        authreq = headers.get(authreq, nil);

        if authreq{
            mo = AbstractBasicAuthHandler.rx.search(authreq);
            if mo{
                scheme, quote, realm = mo.groups();
                if quote not in ['"', "'"]{
                    warnings.warn("Basic Auth Realm was unquoted",
                                  UserWarning, 2);
                } if scheme.lower() == 'basic'{
                    return this.retry_http_basic_auth(host, req, realm);

    }
    } } } function retry_http_basic_auth( host, req, realm){
        user, pw = this.passwd.find_user_password(realm, host);
        if pw is not nil{
            raw = "%s:%s" % (user, pw);
            auth = 'Basic %s' % base64.b64encode(raw).strip();
            if req.get_header(this.auth_header, nil) == auth{
                return nil;
            } req.add_unredirected_header(this.auth_header, auth);
            return this.parent.open(req, timeout=req.timeout);
        } else{
            return nil;


}
} } class HTTPBasicAuthHandler(AbstractBasicAuthHandler, BaseHandler){

    auth_header = 'Authorization';

    function http_error_401( req, fp, code, msg, headers){
        url = req.get_full_url();
        response = this.http_error_auth_reqed('www-authenticate',
                                              url, req, headers);
        return response;


}
} class ProxyBasicAuthHandler(AbstractBasicAuthHandler, BaseHandler){

    auth_header = 'Proxy-authorization';

    function http_error_407( req, fp, code, msg, headers){
        # http_error_auth_reqed requires that there is no userinfo component in
        # authority.  Assume there isn't one, since urllib2 does not (and
        # should not, RFC 3986 s. 3.2.1) support requests for URLs containing
        # userinfo.
        authority = req.get_host();
        response = this.http_error_auth_reqed('proxy-authenticate',
                                          authority, req, headers);
        return response;


}
} function randombytes(n){
    """Return n random bytes.""";
    # Use /dev/urandom if it is available.  Fall back to random module
    # if not.  It might be worthwhile to extend this function to use
    # other platform-specific mechanisms for getting random bytes.
    if os.path.exists("/dev/urandom"){
        f = open("/dev/urandom");
        s = f.read(n);
        f.close();
        return s;
    } else{
        L = [chr(random.randrange(0, 256)) for i in range(n)];
        return "".join(L);

}
} class AbstractDigestAuthHandler{
    # Digest authentication is specified in RFC 2617.

    # XXX The client does not inspect the Authentication-Info header
    # in a successful response.

    # XXX It should be possible to test this implementation against
    # a mock server that just generates a static set of challenges.

    # XXX qop="auth-int" supports is shaky

    function __init__( passwd=nil){
        if passwd is nil{
            passwd = HTTPPasswordMgr();
        } this.passwd = passwd;
        this.add_password = this.passwd.add_password;
        this.retried = 0;
        this.nonce_count = 0;
        this.last_nonce = nil;

    }
    function reset_retry_count(){
        this.retried = 0;

    }
    function http_error_auth_reqed( auth_header, host, req, headers){
        authreq = headers.get(auth_header, nil);
        if this.retried > 5{
            # Don't fail endlessly - if we failed once, we'll probably
            # fail a second time. Hm. Unless the Password Manager is
            # prompting for the information. Crap. This isn't great
            # but it's better than the current 'repeat until recursion
            # depth exceeded' approach <wink>
            raise HTTPError(req.get_full_url(), 401, "digest auth failed",
                            headers, nil);
        } else{
            this.retried += 1;
        } if authreq{
            scheme = authreq.split()[0];
            if scheme.lower() == 'digest'{
                return this.retry_http_digest_auth(req, authreq);

    }
    } } function retry_http_digest_auth( req, auth){
        token, challenge = auth.split(' ', 1);
        chal = parse_keqv_list(parse_http_list(challenge));
        auth = this.get_authorization(req, chal);
        if auth{
            auth_val = 'Digest %s' % auth;
            if req.headers.get(this.auth_header, nil) == auth_val{
                return nil;
            } req.add_unredirected_header(this.auth_header, auth_val);
            resp = this.parent.open(req, timeout=req.timeout);
            return resp;

    }
    } function get_cnonce( nonce){
        # The cnonce-value is an opaque
        # quoted string value provided by the client and used by both client
        # and server to avoid chosen plaintext attacks, to provide mutual
        # authentication, and to provide some message integrity protection.
        # This isn't a fabulous effort, but it's probably Good Enough.
        dig = hashlib.sha1("%s:%s:%s:%s" % (this.nonce_count, nonce, time.ctime(),
                                            randombytes(8))).hexdigest();
        return dig[:16];

    }
    function get_authorization( req, chal){
        try{
            realm = chal['realm'];
            nonce = chal['nonce'];
            qop = chal.get('qop');
            algorithm = chal.get('algorithm', 'MD5');
            # mod_digest doesn't send an opaque, even though it isn't
            # supposed to be optional
            opaque = chal.get('opaque', nil);
        } except KeyError{
            return nil;

        }
        H, KD = this.get_algorithm_impls(algorithm);
        if H is nil{
            return nil;

        }
        user, pw = this.passwd.find_user_password(realm, req.get_full_url());
        if user is nil{
            return nil;

        # XXX not implemented yet
        }
        if req.has_data(){
            entdig = this.get_entity_digest(req.get_data(), chal);
        } else{
            entdig = nil;

        }
        A1 = "%s:%s:%s" % (user, realm, pw);
        A2 = "%s:%s" % (req.get_method(),
                        # XXX selector: what about proxies and full urls
                        req.get_selector());
        if qop == 'auth'{
            if nonce == this.last_nonce{
                this.nonce_count += 1;
            } else{
                this.nonce_count = 1;
                this.last_nonce = nonce;

            }
            ncvalue = '%08x' % this.nonce_count;
            cnonce = this.get_cnonce(nonce);
            noncebit = "%s:%s:%s:%s:%s" % (nonce, ncvalue, cnonce, qop, H(A2));
            respdig = KD(H(A1), noncebit);
        } elif qop is nil{
            respdig = KD(H(A1), "%s:%s" % (nonce, H(A2)));
        } else{
            # XXX handle auth-int.
            raise URLError("qop '%s' is not supported." % qop);

        # XXX should the partial digests be encoded too?

        }
        base = 'username="%s", realm="%s", nonce="%s", uri="%s", ' \
               'response="%s"' % (user, realm, nonce, req.get_selector(),
                                  respdig);
        if opaque{
            base += ', opaque="%s"' % opaque;
        } if entdig{
            base += ', digest="%s"' % entdig;
        } base += ', algorithm="%s"' % algorithm;
        if qop{
            base += ', qop=auth, nc=%s, cnonce="%s"' % (ncvalue, cnonce);
        } return base;

    }
    function get_algorithm_impls( algorithm){
        # algorithm should be case-insensitive according to RFC2617
        algorithm = algorithm.upper();
        # lambdas assume digest modules are imported at the top level
        if algorithm == 'MD5'{
            H = lambda x{ hashlib.md5(x).hexdigest()};
        } elif algorithm == 'SHA'{
            H = lambda x{ hashlib.sha1(x).hexdigest()};
        # XXX MD5-sess
        }
        else{
            raise ValueError("Unsupported digest authentication "
                             "algorithm %r" % algorithm.lower());
        } KD = lambda s, d{ H("%s:%s" % (s, d))};
        return H, KD;

    }
    function get_entity_digest( data, chal){
        # XXX not implemented yet
        return nil;


}
} class HTTPDigestAuthHandler(BaseHandler, AbstractDigestAuthHandler){
    """An authentication protocol defined by RFC 2069

    Digest authentication improves on basic authentication because it
    does not transmit passwords in the clear.
    """;

    auth_header = 'Authorization';
    handler_order = 490;  # before Basic auth

    function http_error_401( req, fp, code, msg, headers){
        host = urlparse.urlparse(req.get_full_url())[1];
        retry = this.http_error_auth_reqed('www-authenticate',
                                           host, req, headers);
        this.reset_retry_count();
        return retry;


}
} class ProxyDigestAuthHandler(BaseHandler, AbstractDigestAuthHandler){

    auth_header = 'Proxy-Authorization';
    handler_order = 490;  # before Basic auth

    function http_error_407( req, fp, code, msg, headers){
        host = req.get_host();
        retry = this.http_error_auth_reqed('proxy-authenticate',
                                           host, req, headers);
        this.reset_retry_count();
        return retry;

}
} class AbstractHTTPHandler(BaseHandler){

    function __init__( debuglevel=0){
        this._debuglevel = debuglevel;

    }
    function set_http_debuglevel( level){
        this._debuglevel = level;

    }
    function do_request_( request){
        host = request.get_host();
        if not host{
            raise URLError('no host given');

        }
        if request.has_data(){  # POST
            data = request.get_data();
            if not request.has_header('Content-type'){
                request.add_unredirected_header(
                    'Content-type',
                    'application/x-www-form-urlencoded');
            } if not request.has_header('Content-length'){
                request.add_unredirected_header(
                    'Content-length', '%d' % len(data));

        }
        } sel_host = host;
        if request.has_proxy(){
            scheme, sel = splittype(request.get_selector());
            sel_host, sel_path = splithost(sel);

        }
        if not request.has_header('Host'){
            request.add_unredirected_header('Host', sel_host);
        } for name, value in this.parent.addheaders{
            name = name.capitalize();
            if not request.has_header(name){
                request.add_unredirected_header(name, value);

        }
        } return request;

    }
    function do_open( http_class, req, **http_conn_args){
        """Return an addinfourl object for the request, using http_class.

        http_class must implement the HTTPConnection API from httplib.
        The addinfourl return value is a file-like object.  It also
        has methods and attributes including:
            - info(): return a mimetools.Message object for the headers
            - geturl(): return the original request URL
            - code: HTTP status code
        """;
        host = req.get_host();
        if not host{
            raise URLError('no host given');

        # will parse host:port
        }
        h = http_class(host, timeout=req.timeout, **http_conn_args);
        h.set_debuglevel(this._debuglevel);

        headers = dict(req.unredirected_hdrs);
        headers.update(dict((k, v) for k, v in req.headers.items()
                            if k not in headers));

        # We want to make an HTTP/1.1 request, but the addinfourl
        # class isn't prepared to deal with a persistent connection.
        # It will try to read all remaining data from the socket,
        # which will block while the server waits for the next request.
        # So make sure the connection gets closed after the (only)
        # request.
        headers["Connection"] = "close";
        headers = dict(
            (name.title(), val) for name, val in headers.items());

        if req._tunnel_host{
            tunnel_headers = {};
            proxy_auth_hdr = "Proxy-Authorization";
            if proxy_auth_hdr in headers{
                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr];
                # Proxy-Authorization should not be sent to origin
                # server.
                del headers[proxy_auth_hdr];
            } h.set_tunnel(req._tunnel_host, headers=tunnel_headers);

        }
        try{
            h.request(req.get_method(), req.get_selector(), req.data, headers);
        } except socket.error, err{ # XXX what error?
            h.close();
            raise URLError(err);
        } else{
            try{
                r = h.getresponse(buffering=true);
            } except TypeError{ # buffering kw not supported
                r = h.getresponse();

        # Pick apart the HTTPResponse object to get the addinfourl
        # object initialized properly.

        # Wrap the HTTPResponse object in socket's file object adapter
        # for Windows.  That adapter calls recv(), so delegate recv()
        # to read().  This weird wrapping allows the returned object to
        # have readline() and readlines() methods.

        # XXX It might be better to extract the read buffering code
        # out of socket._fileobject() and into a base class.

        }
        } r.recv = r.read;
        fp = socket._fileobject(r, close=true);

        resp = addinfourl(fp, r.msg, req.get_full_url());
        resp.code = r.status;
        resp.msg = r.reason;
        return resp;


}
} class HTTPHandler(AbstractHTTPHandler){

    function http_open( req){
        return this.do_open(httplib.HTTPConnection, req);

    }
    http_request = AbstractHTTPHandler.do_request_;

}
if hasattr(httplib, 'HTTPS'){
    class HTTPSHandler(AbstractHTTPHandler){

        function __init__( debuglevel=0, context=nil){
            AbstractHTTPHandler.__init__(this, debuglevel);
            this._context = context;

        }
        function https_open( req){
            return this.do_open(httplib.HTTPSConnection, req,
                context=this._context);

        }
        https_request = AbstractHTTPHandler.do_request_;

}
} class HTTPCookieProcessor(BaseHandler){
    function __init__( cookiejar=nil){
        import cookielib;
        if cookiejar is nil{
            cookiejar = cookielib.CookieJar();
        } this.cookiejar = cookiejar;

    }
    function http_request( request){
        this.cookiejar.add_cookie_header(request);
        return request;

    }
    function http_response( request, response){
        this.cookiejar.extract_cookies(response, request);
        return response;

    }
    https_request = http_request;
    https_response = http_response;

}
class UnknownHandler(BaseHandler){
    function unknown_open( req){
        type = req.get_type();
        raise URLError('unknown url type: %s' % type);

}
} function parse_keqv_list(l){
    """Parse list of key=value strings where keys are not duplicated.""";
    parsed = {};
    for elt in l{
        k, v = elt.split('=', 1);
        if v[0] == '"' and v[-1] == '"'{
            v = v[1:-1];
        } parsed[k] = v;
    } return parsed;

}
function parse_http_list(s){
    """Parse lists as described by RFC 2068 Section 2.

    In particular, parse comma-separated lists where the elements of
    the list may include quoted-strings.  A quoted-string could
    contain a comma.  A non-quoted string could have quotes in the
    middle.  Neither commas nor quotes count if they are escaped.
    Only double-quotes count, not single-quotes.
    """;
    res = [];
    part = '';

    escape = quote = false;
    for cur in s{
        if escape{
            part += cur;
            escape = false;
            continue;
        } if quote{
            if cur == '\\'{
                escape = true;
                continue;
            } elif cur == '"'{
                quote = false;
            } part += cur;
            continue;

        }
        if cur == ','{
            res.append(part);
            part = '';
            continue;

        }
        if cur == '"'{
            quote = true;

        }
        part += cur;

    # append last part
    }
    if part{
        res.append(part);

    }
    return [part.strip() for part in res];

}
function _safe_gethostbyname(host){
    try{
        return socket.gethostbyname(host);
    } except socket.gaierror{
        return nil;

}
} class FileHandler(BaseHandler){
    # Use local file or FTP depending on form of URL
    function file_open( req){
        url = req.get_selector();
        if url[:2] == '//' and url[2:3] != '/' and (req.host and
                req.host != 'localhost'){
            req.type = 'ftp';
            return this.parent.open(req);
        } else{
            return this.open_local_file(req);

    # names for the localhost
    }
    } names = nil;
    function get_names(){
        if FileHandler.names is nil{
            try{
                FileHandler.names = tuple(
                    socket.gethostbyname_ex('localhost')[2] +
                    socket.gethostbyname_ex(socket.gethostname())[2]);
            } except socket.gaierror{
                FileHandler.names = (socket.gethostbyname('localhost'),);
        } } return FileHandler.names;

    # not entirely sure what the rules are here
    }
    function open_local_file( req){
        import email.utils;
        import mimetypes;
        host = req.get_host();
        filename = req.get_selector();
        localfile = url2pathname(filename);
        try{
            stats = os.stat(localfile);
            size = stats.st_size;
            modified = email.utils.formatdate(stats.st_mtime, usegmt=true);
            mtype = mimetypes.guess_type(filename)[0];
            headers = mimetools.Message(StringIO(
                'Content-type: %s\nContent-length: %d\nLast-modified: %s\n' %
                (mtype or 'text/plain', size, modified)));
            if host{
                host, port = splitport(host);
            } if not host or \
                (not port and _safe_gethostbyname(host) in this.get_names()){
                if host{
                    origurl = 'file://' + host + filename;
                } else{
                    origurl = 'file://' + filename;
                } return addinfourl(open(localfile, 'rb'), headers, origurl);
        } } except OSError, msg{
            # urllib2 users shouldn't expect OSErrors coming from urlopen()
            raise URLError(msg);
        } raise URLError('file not on local host');

}
} class FTPHandler(BaseHandler){
    function ftp_open( req){
        import ftplib;
        import mimetypes;
        host = req.get_host();
        if not host{
            raise URLError('ftp error: no host given');
        } host, port = splitport(host);
        if port is nil{
            port = ftplib.FTP_PORT;
        } else{
            port = int(port);

        # username/password handling
        }
        user, host = splituser(host);
        if user{
            user, passwd = splitpasswd(user);
        } else{
            passwd = nil;
        } host = unquote(host);
        user = user or '';
        passwd = passwd or '';

        try{
            host = socket.gethostbyname(host);
        } except socket.error, msg{
            raise URLError(msg);
        } path, attrs = splitattr(req.get_selector());
        dirs = path.split('/');
        dirs = map(unquote, dirs);
        dirs, file = dirs[:-1], dirs[-1];
        if dirs and not dirs[0]{
            dirs = dirs[1:];
        } try{
            fw = this.connect_ftp(user, passwd, host, port, dirs, req.timeout);
            type = file and 'I' or 'D';
            for attr in attrs{
                attr, value = splitvalue(attr);
                if attr.lower() == 'type' and \
                   value in ('a', 'A', 'i', 'I', 'd', 'D'){
                    type = value.upper();
            } } fp, retrlen = fw.retrfile(file, type);
            headers = "";
            mtype = mimetypes.guess_type(req.get_full_url())[0];
            if mtype{
                headers += "Content-type: %s\n" % mtype;
            } if retrlen is not nil and retrlen >= 0{
                headers += "Content-length: %d\n" % retrlen;
            } sf = StringIO(headers);
            headers = mimetools.Message(sf);
            return addinfourl(fp, headers, req.get_full_url());
        } except ftplib.all_errors, msg{
            raise URLError, ('ftp error: %s' % msg), sys.exc_info()[2];

    }
    } function connect_ftp( user, passwd, host, port, dirs, timeout){
        fw = ftpwrapper(user, passwd, host, port, dirs, timeout,
                        persistent=false);
##        fw.ftp.set_debuglevel(1)
        return fw;

}
} class CacheFTPHandler(FTPHandler){
    # XXX would be nice to have pluggable cache strategies
    # XXX this stuff is definitely not thread safe
    function __init__(){
        this.cache = {};
        this.timeout = {};
        this.soonest = 0;
        this.delay = 60;
        this.max_conns = 16;

    }
    function setTimeout( t){
        this.delay = t;

    }
    function setMaxConns( m){
        this.max_conns = m;

    }
    function connect_ftp( user, passwd, host, port, dirs, timeout){
        key = user, host, port, '/'.join(dirs), timeout;
        if key in this.cache{
            this.timeout[key] = time.time() + this.delay;
        } else{
            this.cache[key] = ftpwrapper(user, passwd, host, port, dirs, timeout);
            this.timeout[key] = time.time() + this.delay;
        } this.check_cache();
        return this.cache[key];

    }
    function check_cache(){
        # first check for old ones
        t = time.time();
        if this.soonest <= t{
            for k, v in this.timeout.items(){
                if v < t{
                    this.cache[k].close();
                    del this.cache[k];
                    del this.timeout[k];
        } } } this.soonest = min(this.timeout.values());

        # then check the size
        if len(this.cache) == this.max_conns{
            for k, v in this.timeout.items(){
                if v == this.soonest{
                    del this.cache[k];
                    del this.timeout[k];
                    break;
            } } this.soonest = min(this.timeout.values());

    }
    } function clear_cache(){
        for conn in this.cache.values(){
            conn.close();
        } this.cache.clear();
        this.timeout.clear();

}
}